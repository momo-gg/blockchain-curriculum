# 2.1 Ethereum: Code on the Blockchain

> *"What Bitcoin does for payments, Ethereum does for anything that can be programmed."*
> â€” Vitalik Buterin, 2014

---

## Why This Matters

Bitcoin proved that decentralized money works. But Vitalik Buterin, then a 19-year-old programmer, saw something bigger: if you can decentralize money, you can decentralize *any* agreement.

Ethereum introduced the concept of **smart contracts** â€” self-executing code that lives on the blockchain. This single innovation created an entirely new category: decentralized applications (dApps), DeFi, NFTs, DAOs, and eventually, the need for faster blockchains like Solana.

---

## ðŸŸ¢ General Understanding

### From Digital Cash to Digital Contracts

Bitcoin = programmable money
Ethereum = programmable *anything*

**The Vending Machine Analogy**

A vending machine is a simple "contract":
1. You insert money
2. You press a button
3. You receive a snack

No human is involved. The machine enforces the agreement automatically.

Now imagine a vending machine that:
- Can hold any digital asset (not just snacks)
- Can have any rules (not just "insert coins, press button")
- Can talk to other vending machines
- Cannot be turned off or modified by anyone (unless designed with admin controls)
- Runs exactly as programmed, forever (unless upgraded or paused by authorized keys)

That's a smart contract.

> âš ï¸ **Data Disclaimer**: Some smart contracts are upgradeable or pausable by design.
> Always check whether a contract uses proxies or admin keys (as of common upgrade
> patterns documented in [docs.soliditylang.org](https://docs.soliditylang.org/) and
> [docs.openzeppelin.com](https://docs.openzeppelin.com/)).

### Real Examples of Smart Contracts

**Escrow Without a Middleman**
```
Rules:
- Buyer sends payment to contract
- Contract holds payment
- If seller delivers (verified by oracle), payment releases
- If 30 days pass with no delivery, payment returns to buyer
```

No lawyer, no escrow company, no trust required.

**Automatic Loan Repayment**
```
Rules:
- Borrower deposits collateral (e.g., ETH)
- Contract issues loan (e.g., USDC)
- If collateral value drops below 150% of loan, liquidate
- When loan + interest repaid, return collateral
```

No bank, no credit check, no human approval.

**Decentralized Exchange**
```
Rules:
- Anyone can add liquidity (paired tokens)
- Anyone can swap Token A for Token B
- Price determined by ratio in pool
- Liquidity providers earn fees
```

No Coinbase, no NYSE, no order book, no intermediary.

> ðŸ’¡ **Key Insight**: Smart contracts don't just automate existing processes â€” they enable entirely new ones that weren't possible with trusted intermediaries.

### Where Does "The Protocol" Actually Live?

This is a question many newcomers ask: *Where is Ethereum? Who runs it?*

**The Answer: Everywhere and Nowhere**

```
The Ethereum "protocol" is:

1. A SPECIFICATION (the rules)
   â””â”€â”€ Written in the Yellow Paper and EIPs
   â””â”€â”€ Defines what valid transactions/blocks look like

2. CLIENT SOFTWARE (the implementation)
   â””â”€â”€ Programs that follow the specification
   â””â”€â”€ Examples: Geth, Nethermind, Besu, Erigon

3. A NETWORK (the participants)
   â””â”€â”€ Thousands of computers running client software
   â””â”€â”€ All agreeing on the same state
```

**What is a Blockchain Client?**

A client is software that:
- Connects to peer nodes (other clients)
- Downloads and validates the blockchain
- Maintains current state (all account balances, contract storage)
- Broadcasts transactions
- (If validator) Proposes and votes on blocks

```
Your Computer
     â”‚
     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Geth Client    â”‚  â† Software following Ethereum rules
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ - Blockchain DB â”‚  â† Full history of all transactions
â”‚ - State DB      â”‚  â† Current balances and contract data
â”‚ - P2P Network   â”‚  â† Connections to other nodes
â”‚ - JSON-RPC API  â”‚  â† How wallets/apps talk to it
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚
     â–¼
   Network
   (10,000+ other nodes running clients)
```

**Can You Create Your Own Client?**

Yes! This is actually encouraged:
- Multiple clients = network resilience
- Bug in one client doesn't break the network
- Different teams, different codebases, same specification

**Who Funds Client Development?**
| Client | Funded By |
|--------|-----------|
| Geth | Ethereum Foundation |
| Nethermind | Nethermind Ltd (grants + commercial) |
| Besu | ConsenSys (Hyperledger project) |
| Erigon | Independent team + grants |

> ðŸ’¡ **Key Insight**: The protocol is just rules. Multiple independent teams write software that follows those rules. The network is all the computers running that software, agreeing on state.

### The Ethereum Virtual Machine (EVM)

The EVM is a virtual computer that runs smart contracts:

```
Traditional Computer              Ethereum Virtual Machine
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€             â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
CPU executes code                 EVM executes bytecode
RAM stores data                   Blockchain stores state
Hard drive persists               World state is permanent
One owner                         Everyone verifies
Can be modified                   Immutable once deployed
```

Every node runs the same code and gets the same result. This is how thousands of computers agree on state without trusting each other.

> âœ… **Check Your Understanding**
> - [ ] What can a smart contract do that a regular contract can't?
> - [ ] Where does the Ethereum protocol "live"?
> - [ ] What is a blockchain client?
> - [ ] Why is having multiple clients beneficial?

---

## ðŸŸ¡ PM/EM Depth

### Why Blockchains Need Native Coins

Every blockchain has a native currency (ETH, SOL, BTC). Why?

**The Spam Problem**

Without cost:
- Attacker sends 1 billion transactions
- Network grinds to a halt
- Nodes waste resources processing garbage

**The Solution: Gas**

Every operation costs "gas":
| Operation | Gas Cost |
|-----------|----------|
| Send ETH | 21,000 |
| Store 32 bytes | 20,000 |
| Create contract | 32,000+ |
| Complex math | Variable |

Users pay: `gas_used Ã— gas_price = fee in ETH`

**Why Native Coins (Not Dollars)?**

1. **Decentralized**: No bank needed to process payments
2. **Programmable**: Contracts can receive and send fees
3. **Aligned incentives**: Coin value = network security budget
4. **Permissionless**: Anyone can pay, no account needed

> ðŸ“Š **Business Context**: Gas fees are the "cost of decentralization." Centralized systems (AWS) charge for compute too, but with simpler pricing. Blockchain fees fluctuate with demand, creating UX challenges.

### The Account Model vs. UTXO

Ethereum uses an **account model** (like a bank), not Bitcoin's UTXO model:

**Bitcoin (UTXO)**
```
Alice's "balance" = sum of unspent outputs she can spend
Each transaction consumes outputs and creates new ones
No concept of "account balance" at protocol level
```

**Ethereum (Accounts)**
```
Alice's balance = stored number in account
Transactions directly modify balances
Contracts have their own accounts with code + storage
```

| Aspect | UTXO (Bitcoin) | Account (Ethereum) |
|--------|----------------|-------------------|
| State | Scattered outputs | Centralized per account |
| Parallelism | Naturally parallel | Requires careful handling |
| Smart contracts | Difficult | Natural |
| Privacy | Better (new address per tx) | Worse (single address) |
| Simplicity | Complex for users | Intuitive |

### Composability: The DeFi Superpower

Ethereum contracts can call other contracts. This creates **composability** â€” the ability to combine protocols like Lego blocks:

```
User wants to:
1. Swap ETH for USDC
2. Deposit USDC into lending protocol
3. Borrow DAI against that deposit
4. Use DAI to buy an NFT

Traditional Finance: 4 separate institutions, days of paperwork
Ethereum: 1 transaction, ~30 seconds, all atomic
```

**Flash Loans: Composability in Action**

Borrow millions, use it, repay â€” all in one transaction:

```
1. Borrow $10M USDC (no collateral!)
2. Buy asset on Exchange A at $100
3. Sell asset on Exchange B at $101
4. Repay $10M + tiny fee
5. Keep $100K profit

If any step fails, entire transaction reverts.
Risk = 0 (for borrower). Made possible by atomicity.
```

> ðŸ“Š **Business Context**: Composability is Ethereum's moat. Every new protocol adds capabilities that all other protocols can use. This network effect is extremely powerful â€” and why "Ethereum killers" struggle to gain traction.

### Governance and Upgrades

How does Ethereum change without a CEO?

**Ethereum Improvement Proposals (EIPs)**
1. Anyone can write an EIP
2. Community discusses on forums, calls, conferences
3. Core developers decide inclusion in client updates
4. Node operators choose to upgrade (or not)
5. If majority upgrades, change is live

**The Ethereum Foundation**
- Non-profit supporting Ethereum development
- Funds research, grants, developer conferences
- Does NOT control the protocol
- Influential but not authoritative

**Hard Forks**
When changes aren't backward-compatible:
- All nodes must upgrade simultaneously
- Non-upgraders continue on old chain
- Example: The DAO hack led to ETH/ETC split

> âœ… **Check Your Understanding**
> - [ ] Why does Ethereum need a native coin (ETH)?
> - [ ] What's the difference between account model and UTXO?
> - [ ] What is composability and why does it matter?
> - [ ] How do protocol upgrades happen without central authority?

---

## ðŸ”µ Engineer Depth

### EVM Architecture Deep Dive

The EVM is a stack-based virtual machine:

**Stack Machine**
```
Most CPUs: Register-based (mov eax, 5)
EVM: Stack-based (PUSH 5)

Operations pop inputs from stack, push results

Example: 2 + 3
  PUSH 2    Stack: [2]
  PUSH 3    Stack: [2, 3]
  ADD       Stack: [5]
```

**EVM Components**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    EVM Instance                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Stack          â”‚ 1024 items max, 256-bit words       â”‚
â”‚  Memory         â”‚ Volatile, byte-addressed, per-call   â”‚
â”‚  Storage        â”‚ Persistent, 256-bit key-value store  â”‚
â”‚  Calldata       â”‚ Input to current call (read-only)    â”‚
â”‚  Return Data    â”‚ Output from last call                â”‚
â”‚  Program Counterâ”‚ Current bytecode position            â”‚
â”‚  Gas            â”‚ Remaining computation budget         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Key Opcodes**

| Opcode | Gas | Description |
|--------|-----|-------------|
| ADD | 3 | Pop 2 values, push sum |
| MUL | 5 | Multiplication |
| SLOAD | 2100 | Load from storage |
| SSTORE | 20000/5000 | Write to storage (new/modify) |
| CALL | Variable | Call another contract |
| CREATE | 32000 | Deploy new contract |
| SELFDESTRUCT | 5000 | Delete contract (deprecated) |

**Why Storage is Expensive**

Storage operations are expensive because:
- State must be stored by every node forever
- State affects block validation speed
- State rent/cleanup is unsolved problem

```solidity
// This costs ~20,000 gas
uint256 public counter;

function increment() public {
    counter += 1;  // SSTORE operation
}
```

### Solidity and Contract Development

Solidity is the primary EVM language:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract SimpleStorage {
    // State variable (stored on-chain)
    uint256 private value;

    // Events (logged, not stored)
    event ValueChanged(uint256 oldValue, uint256 newValue);

    // Write function (costs gas)
    function setValue(uint256 _value) public {
        uint256 oldValue = value;
        value = _value;
        emit ValueChanged(oldValue, _value);
    }

    // Read function (free when called externally)
    function getValue() public view returns (uint256) {
        return value;
    }
}
```

**Contract Lifecycle**
```
Source Code (.sol)
     â”‚
     â–¼ (Compile with solc)
Bytecode + ABI
     â”‚
     â–¼ (Deploy transaction)
Contract at Address 0x123...
     â”‚
     â–¼ (Interact via transactions)
State Changes
```

### Transaction Anatomy

An Ethereum transaction contains:

```javascript
{
  nonce: 42,           // Sender's transaction count
  to: "0x123...",      // Recipient (null for contract creation)
  value: 1000000,      // Wei to transfer (1 ETH = 10^18 Wei)
  data: "0xa9059...",  // Calldata (function + arguments)
  gasLimit: 100000,    // Max gas willing to use
  maxFeePerGas: 20,    // Max gwei per gas (EIP-1559)
  maxPriorityFeePerGas: 2,  // Tip to validator
  chainId: 1,          // Mainnet = 1 (prevents replay attacks)
  v, r, s: ...         // Signature components
}
```

**Transaction Types**

| Type | To | Value | Data |
|------|-----|-------|------|
| ETH Transfer | Address | > 0 | Empty |
| Contract Call | Contract | Optional | Function call |
| Contract Deploy | Empty | Optional | Bytecode |

### State Trie and Storage

Ethereum uses a Modified Merkle Patricia Trie:

```
State Root (in block header)
     â”‚
     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 World State Trie                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Address â†’ Account                                     â”‚
â”‚                                                       â”‚
â”‚ 0x123... â†’ {nonce, balance, storageRoot, codeHash}   â”‚
â”‚ 0x456... â†’ {nonce, balance, storageRoot, codeHash}   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
                    â–¼ (for contracts)
           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
           â”‚  Storage Trie   â”‚
           â”‚ key â†’ value     â”‚
           â”‚ (256-bit each)  â”‚
           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Why Merkle Tries?**
- Efficient proofs: Prove account state without full state
- Cryptographic binding: State root in block header commits to entire state
- Incremental updates: Only changed branches need recalculation

### Message Calls and Internal Transactions

Contracts can call other contracts:

```solidity
contract A {
    function callB(address b) public {
        // External call to contract B
        (bool success, bytes memory result) = b.call(
            abi.encodeWithSignature("doSomething()")
        );
        require(success, "Call failed");
    }
}
```

**Call Stack and Gas Forwarding**
```
User Transaction
  â””â”€â”€ Contract A (receives 100,000 gas)
        â””â”€â”€ Calls Contract B (forwards 63/64 of remaining gas)
              â””â”€â”€ Calls Contract C (forwards 63/64 of remaining)
                    â””â”€â”€ ...
```

**Reentrancy: The Classic Vulnerability**

```solidity
// VULNERABLE CONTRACT
contract Victim {
    mapping(address => uint) balances;

    function withdraw() public {
        uint amount = balances[msg.sender];
        (bool success,) = msg.sender.call{value: amount}("");  // Calls attacker
        // Attacker's receive() calls withdraw() AGAIN
        // State not yet updated!
        balances[msg.sender] = 0;  // Too late!
    }
}
```

The DAO hack (2016) exploited this, draining $60M and splitting Ethereum/Ethereum Classic.

**Prevention**: Checks-Effects-Interactions pattern
```solidity
function withdraw() public {
    uint amount = balances[msg.sender];
    balances[msg.sender] = 0;  // Update state FIRST
    (bool success,) = msg.sender.call{value: amount}("");  // Then interact
    require(success);
}
```

### ABI Encoding

The ABI (Application Binary Interface) defines how data is encoded:

```javascript
// Function: transfer(address to, uint256 amount)
// Selector: first 4 bytes of keccak256("transfer(address,uint256)")
//         = 0xa9059cbb

// Call: transfer(0x123..., 1000)
// Encoded:
// 0xa9059cbb                                             // Function selector
// 0000000000000000000000000123...                        // address (padded to 32 bytes)
// 00000000000000000000000000000000000000000000000003e8  // 1000 in hex (32 bytes)
```

Understanding ABI encoding is essential for:
- Debugging failed transactions
- Building low-level integrations
- Security auditing

> âœ… **Check Your Understanding**
> - [ ] How does the EVM stack machine work?
> - [ ] Why is storage expensive compared to memory?
> - [ ] What is the state trie and why use a Merkle structure?
> - [ ] Explain the reentrancy vulnerability and how to prevent it
> - [ ] How is function call data ABI-encoded?

---

## Key Takeaways

1. **Smart contracts** are self-executing code that lives on the blockchain forever
2. **The protocol** is a specification + multiple client implementations + a network
3. **Gas** prevents spam and aligns incentives using the native coin
4. **The EVM** is a deterministic virtual machine that all nodes run identically
5. **Composability** allows protocols to build on each other like Lego blocks
6. **State is expensive** because every node stores it forever

Ethereum proved programmable blockchains work. It enabled DeFi, NFTs, and DAOs. But success brought problems: network congestion, high fees, and scalability limits.

---

## Next

Ethereum became a victim of its own success. When everyone wants to use it, fees skyrocket and the network slows. Let's explore why.

â†’ [2.2 Ethereum's Growing Pains](./2.2-ethereums-growing-pains.md)
