# 3.2 How Solana Works

> *"Solana is like a finely-tuned race car. Every component is optimized, and they all work together."*

---

## Why This Matters

Understanding Solana's internals helps you:
- Debug issues in your applications
- Choose the right infrastructure
- Understand trade-offs in design decisions
- Appreciate why certain behaviors exist

This module covers the eight innovations in depth, plus the network architecture and client ecosystem.

---

## ðŸŸ¢ General Understanding

### The Eight Innovations Working Together

Think of Solana as a factory assembly line:

```
Transaction arrives
    â”‚
    â–¼ (Gulf Stream: skip the waiting room)
Leader receives
    â”‚
    â–¼ (PoH: stamp with verifiable time)
Transaction ordered
    â”‚
    â–¼ (Sealevel: process in parallel)
Transaction executed
    â”‚
    â–¼ (Pipelining: like a CPU pipeline)
Block created
    â”‚
    â–¼ (Turbine: spread like gossip)
Block propagated
    â”‚
    â–¼ (Tower BFT: validators vote)
Block confirmed
    â”‚
    â–¼ (Cloudbreak: save to disk fast)
State updated
```

Each innovation handles one step, optimized for speed.

### How the Peer-to-Peer Network Stays Connected

**The Gossip Protocol**

How do thousands of computers find and talk to each other without a central server?

```
Traditional (Client-Server):
  All computers â†’ Central Server â†’ All computers

  Problem: Server is single point of failure

Peer-to-Peer (Gossip):
  Each computer knows a few others
  Shares information like rumors
  Eventually everyone knows everything
```

**How Gossip Works**

```
1. Node A learns something new (a transaction, a vote)

2. Node A tells its "neighbors" (e.g., 6 random peers)
   A â†’ B, C, D, E, F, G

3. Each neighbor tells THEIR neighbors
   B â†’ H, I, J, ...
   C â†’ K, L, M, ...

4. Information spreads exponentially
   Round 1: 1 node knows
   Round 2: 7 nodes know
   Round 3: 49 nodes know
   Round 4: 343 nodes know
   ...

5. Within seconds, all 1,500+ validators know
```

**Why Random Peer Selection?**

- If peers were fixed, attackers could target them
- Random selection means unpredictable topology
- Network self-heals (if peer dies, choose another)

**Seed Nodes**

New validators need to find the network:

```
1. New validator starts
2. Contacts "seed nodes" (well-known entry points)
3. Seed nodes provide list of active peers
4. New validator connects to peers
5. Learns about more peers through gossip
6. Eventually has many connections
```

Seed nodes are bootstrap points, not central authorities. After connecting, they're not needed.

### How Solana Launched from Genesis

Every blockchain starts from a "genesis block." But how?

**Genesis Configuration**

The genesis defines initial state:
```yaml
# Simplified genesis.yaml
cluster_type: mainnet-beta
genesis_time: "2020-03-16T14:00:00Z"

initial_validators:
  - pubkey: "Vote111..."
    stake: 1000000
  - pubkey: "Vote222..."
    stake: 1000000
  # ... founding validators

initial_accounts:
  - address: "Foundation..."
    lamports: 500000000000000000  # Initial supply allocation

programs:
  - bpf_loader: "BPFLoader..."
  - system_program: "11111111..."
  - token_program: "TokenkegQ..."
```

**The Launch Sequence**

```
1. PREPARATION (Months before)
   - Genesis configuration finalized
   - Founding validators set up hardware
   - Private testnet runs
   - Security audits complete

2. GENESIS (T=0)
   - All founding validators start simultaneously
   - Load identical genesis configuration
   - First PoH tick begins
   - Validators begin voting

3. FIRST BLOCKS
   - Leaders selected from genesis validator set
   - First transactions processed
   - Network stabilizes

4. OPENING UP
   - New validators can join
   - Stake delegation enabled
   - Applications deployed
```

**Why This Works**

All validators:
- Start with identical state (genesis)
- Follow identical rules (client software)
- Build on the same chain

The chain "emerges" from consensus, not from a central server.

> âœ… **Check Your Understanding**
> - [ ] How does gossip protocol spread information?
> - [ ] What are seed nodes and why are they needed?
> - [ ] What's in a genesis configuration?
> - [ ] How do all validators start with the same state?

---

## ðŸŸ¡ PM/EM Depth

### What Are Blockchain "Clients"?

A **client** is software that implements the blockchain protocol. Think of it like different web browsers implementing HTTP:

```
The Protocol (Rules)          Clients (Implementations)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€          â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Solana Protocol      â†’       Agave (Rust, by Anza)
                             Firedancer (C, by Jump)
                             Sig (Zig, by)

Just like:
HTTP Protocol        â†’       Chrome, Firefox, Safari
```

**Why Multiple Clients Matter**

| Benefit | Explanation |
|---------|-------------|
| No single point of failure | Bug in one client doesn't affect others |
| Defense in depth | Different codebases, different bugs |
| Competition | Drives performance improvements |
| Decentralization | No single team controls the software |

**Solana's Client History**

```
2017-2020: Original Solana Labs client
    â”‚
2024: Solana Labs archived, Anza formed
    â”‚
    â”œâ”€â”€ Agave (Anza)
    â”‚   â””â”€â”€ Production-ready, runs mainnet
    â”‚
    â”œâ”€â”€ Firedancer (Jump Crypto)
    â”‚   â””â”€â”€ Complete rewrite in C
    â”‚   â””â”€â”€ Focus on performance
    â”‚   â””â”€â”€ Expected late 2024/early 2025
    â”‚
    â””â”€â”€ Sig (syndica)
        â””â”€â”€ Zig implementation
        â””â”€â”€ Research/experimental
```

**The Anza Split**

In 2024, Solana Labs spun off its validator team into **Anza**:
- Solana Labs: Focus on ecosystem, investments
- Anza: Focus on Agave client development
- Clearer organizational boundaries
- Similar to how Ethereum Foundation doesn't develop Geth

### Firedancer: Why It Matters

Jump Crypto (major trading firm) is building Firedancer from scratch:

**Technical Goals**
- 1 million TPS theoretical max
- Written in C for maximum performance
- Clean-room implementation (no shared code with Agave)
- Formal verification for critical paths

**Business Implications**
- Trading firm needs reliable infrastructure
- Different incentives than original team
- Major investment ($100M+ estimated)
- Legitimizes Solana for institutional use

**What It Means for the Network**
```
Today: ~90% Agave, ~10% testing Firedancer
Future: 50% Agave, 50% Firedancer (goal)

If Agave has a bug: Firedancer validators keep running
If Firedancer has a bug: Agave validators keep running
Network stays live in either case
```

### Feature Gates: How Protocol Changes Deploy

Unlike traditional software, you can't just push updates. All validators must upgrade together.

**The Feature Gate System**

```
1. DEVELOPMENT
   - Feature coded, tested, audited
   - Merged with feature flag disabled

2. ACTIVATION PROPOSAL
   - Solana Improvement Document (SIMD) written
   - Community discussion
   - Validator voting (stake-weighted)

3. ACTIVATION
   - Once threshold stake has upgraded
   - Feature flag enabled at specific slot
   - All validators activate simultaneously

4. ENFORCEMENT
   - Blocks without feature: Valid before activation slot
   - Blocks without feature: Invalid after activation slot
```

**Example: QUIC Migration**

```
Old: UDP for transaction submission (spammable)
New: QUIC (connection-oriented, rate-limitable)

Timeline:
- Development: 6+ months
- Testing on devnet: 2 months
- Testing on testnet: 1 month
- Mainnet activation: Gradual rollout
- UDP deprecated: After 95% adoption
```

> ðŸ“Š **Business Context**: Feature gates enable upgrades without hard forks. This is more flexible than Ethereum but requires validator coordination. Controversial features still require social consensus.

### Governance: How Decisions Are Made

Solana has informal governance (no on-chain voting like some DAOs):

**Decision-Making Layers**

| Layer | What It Decides | Who Decides |
|-------|-----------------|-------------|
| Protocol | Technical changes (SIMDs) | Core contributors + validators |
| Validator | Run features, choose clients | Individual operators |
| Foundation | Grants, ecosystem support | Foundation board |
| Labs/Anza | Client development priorities | Engineering teams |

**Solana Improvement Documents (SIMDs)**

```
SIMD-0001: Proposal format
SIMD-0046: Add transaction size limit
SIMD-0096: Partial signing API
...

Process:
1. Draft â†’ 2. Review â†’ 3. Last Call â†’ 4. Accepted/Rejected
```

**Validator Voting**

On-chain stake-weighted voting for feature activation:
- Validators signal readiness by running upgraded software
- Activation requires threshold (e.g., 95% of stake)
- Prevents minority from blocking or rushing changes

> âœ… **Check Your Understanding**
> - [ ] What is a blockchain client?
> - [ ] Why did Anza split from Solana Labs?
> - [ ] What's Firedancer and who's building it?
> - [ ] How do feature gates prevent network splits?
> - [ ] Who decides on protocol changes?

---

## ðŸ”µ Engineer Depth

### Proof of History: Deep Technical Dive

**The Hash Chain**

```rust
// Simplified PoH loop
fn poh_tick(state: &mut PohState) {
    loop {
        state.hash = sha256(&state.hash);
        state.tick_count += 1;

        if state.tick_count % TICKS_PER_SLOT == 0 {
            // Slot boundary
            break;
        }
    }
}
```

**Mixing Data Into PoH**

When transactions arrive:

```rust
fn mix_transaction(state: &mut PohState, tx: &Transaction) {
    // Hash includes previous hash AND transaction data
    let mut hasher = Sha256::new();
    hasher.update(&state.hash);
    hasher.update(&tx.serialize());
    state.hash = hasher.finalize();

    // Record the position
    state.entries.push(Entry {
        hash: state.hash,
        transactions: vec![tx.clone()],
        tick_count: state.tick_count,
    });
}
```

**Verification**

```rust
fn verify_poh(entries: &[Entry]) -> bool {
    let mut expected_hash = entries[0].previous_hash;

    for entry in entries {
        // Verify each entry's hash chain
        for _ in 0..entry.num_ticks {
            expected_hash = sha256(&expected_hash);
        }

        // Mix in transactions
        for tx in &entry.transactions {
            expected_hash = sha256([expected_hash, tx.hash()]);
        }

        if expected_hash != entry.hash {
            return false;
        }
    }
    true
}
```

### Tower BFT Consensus

Tower BFT is PBFT modified to use PoH:

**Vote Lockouts**

When a validator votes for a slot, they're "locked" to that fork:

```
Vote for slot 100:
- Locked for 2 slots (can't vote for conflicting fork for slots 100-101)

Vote for slot 101 (same fork):
- Previous lockout doubles: 4 slots
- New vote: 2 slots

Vote for slot 102 (same fork):
- Previous lockouts: 8 slots, 4 slots
- New vote: 2 slots

Each consecutive vote doubles the oldest lockout.
```

**Why Lockouts Work**

```
Validator wants to vote for conflicting fork:
- Must wait out all lockouts first
- Exponential lockouts mean long waits
- Other validators have moved on
- Fork becomes impossible to finalize

This provides "finality" without explicit finalization messages.
```

> ðŸ’¡ **ELI5: Tower BFT**
>
> Imagine a **betting game where you can change your mind, but it gets expensive**:
> - You bet $1 on Team A. To change your bet, wait 2 minutes.
> - You bet again on Team A. Now wait 4 minutes to change.
> - Bet again? Wait 8 minutes. Then 16. Then 32...
>
> **The clever part**: After a few bets on the same team, you'd have to wait hours to switch. By then, the game is over! Everyone knows you're committed.
>
> **How this creates finality**: Once enough validators have voted on the same chain several times, they're all "locked in" â€” switching would take so long that the network moves on without them. No need to wait for a special "this is final!" message.

**Vote Structure**

```rust
struct Vote {
    slots: Vec<Slot>,           // Slots being voted for
    hash: Hash,                  // Blockhash of last slot
    timestamp: Option<i64>,      // Unix timestamp (leader only)
    authorized_voter: Pubkey,    // Who's voting
}
```

### Turbine: Block Propagation

How do you send a 128 MB block to 1,500 validators quickly?

**Shredding**

```
Block (128 MB)
    â”‚
    â–¼
Split into "shreds" (1280 bytes each)
    â”‚
    â–¼
~100,000 shreds per block
    â”‚
    â–¼
Add erasure coding (Reed-Solomon)
    â”‚
    â–¼
Can reconstruct from 2/3 of shreds
```

**Tree Propagation**

Instead of leader sending to everyone:

```
        Leader
       /  |  \
      V1  V2  V3     Layer 1 (fanout = 200)
     /|\ /|\ /|\
    ... ... ...      Layer 2
   /|\ /|\ /|\ /|\
  ... ... ... ...    Layer 3

Depth = log_200(1500) â‰ˆ 2-3 layers
Total time: ~100-200ms to reach everyone
```

**Neighborhood Structure**

Validators organized into "neighborhoods" based on stake:

```
High stake: Early layers (more responsibility)
Low stake: Later layers (less critical path)

Benefits:
- High-stake validators are well-connected
- Attack on small validators doesn't affect propagation
- Stake-weighted importance
```

### Gulf Stream: Transaction Forwarding

Traditional blockchains typically expose a public mempool. Solana avoids a public, gossip-based mempool, but validators still maintain local queues and forward transactions directly to scheduled leaders.

**Traditional Mempool**

```
User â†’ RPC â†’ Mempool (waiting room) â†’ Leader picks transactions
                    â†‘
           Transactions wait here
```

**Gulf Stream**

```
User â†’ RPC â†’ Forward directly to current/next leader
                    â†‘
           Skip the waiting room
```

**Leader Schedule**

```
The schedule is known in advance:

Slot 100: Leader = Validator A
Slot 101: Leader = Validator B
Slot 102: Leader = Validator C
Slot 103: Leader = Validator A
...

RPC knows who to send transactions to.
```

**Benefits**
- Lower latency (no mempool queueing)
- Less spam (leaders can apply stake-weighted QoS)
- More predictable (know when your transaction will be processed)

**QUIC Protocol**

Solana uses QUIC (not UDP) for transaction submission:

```
QUIC provides:
- Connection authentication (prevents spoofing)
- Stream multiplexing (many transactions per connection)
- Rate limiting (prevent spam)
- Congestion control (don't overwhelm nodes)
```

### Sealevel: Parallel Execution

Solana can execute non-conflicting transactions in parallel:

**The Key Insight**

Transactions declare which accounts they'll read/write:

```rust
Transaction {
    accounts: [
        AccountMeta { pubkey: A, is_writable: true },   // Write A
        AccountMeta { pubkey: B, is_writable: false },  // Read B
        AccountMeta { pubkey: C, is_writable: true },   // Write C
    ],
    instructions: [...],
}
```

**Conflict Detection**

```
Transaction 1: Write A, Read B
Transaction 2: Read A, Write C
Transaction 3: Write A, Read D

Conflicts:
- Tx1 and Tx2: Tx1 writes A, Tx2 reads A â†’ CONFLICT
- Tx1 and Tx3: Both write A â†’ CONFLICT
- Tx2 and Tx3: Tx2 reads A, Tx3 writes A â†’ CONFLICT

Execution:
- Tx1 runs first (or Tx3)
- Tx2 runs after (needs Tx1's A)
- Tx3 runs after Tx2 (or before Tx1)

If Transaction 4: Write E, Read F â†’ NO CONFLICT with any, run in parallel
```

**Parallel Execution Engine**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Batch of Transactions                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Conflict Analysis                            â”‚
â”‚    Build graph: transaction â†’ accounts accessed                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Parallel Scheduling                          â”‚
â”‚    Non-conflicting batches run on different CPU cores           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Core 1 â”‚ â”‚ Core 2 â”‚ â”‚ Core 3 â”‚ â”‚ Core 4 â”‚  ...
â”‚ Batch Aâ”‚ â”‚ Batch Bâ”‚ â”‚ Batch Câ”‚ â”‚ Batch Dâ”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Pipelining: GPU + CPU Coordination

Like a CPU pipeline, different stages happen simultaneously:

```
Time  â†’  T1      T2      T3      T4      T5
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Fetch     B1      B2      B3      B4      B5
          â”‚       â”‚       â”‚       â”‚
Verify    â”‚       B1      B2      B3      B4
          â”‚       â”‚       â”‚       â”‚
Execute   â”‚       â”‚       B1      B2      B3
          â”‚       â”‚       â”‚       â”‚
Commit    â”‚       â”‚       â”‚       B1      B2

B1 = Batch 1, etc.

Different batches at different stages simultaneously.
```

**Hardware Utilization**

| Stage | Hardware |
|-------|----------|
| Fetch | Network card, memory |
| Verify signatures | GPU (parallel crypto) |
| Execute transactions | CPU |
| Commit state | NVMe drive |

### Cloudbreak: Accounts Database

Solana's accounts are stored in a memory-mapped structure:

```
Accounts Database
â”œâ”€â”€ accounts.index (in-memory, maps pubkey â†’ location)
â”œâ”€â”€ accounts/
â”‚   â”œâ”€â”€ slot_100.accounts (mmap'd files)
â”‚   â”œâ”€â”€ slot_101.accounts
â”‚   â””â”€â”€ ...
â””â”€â”€ snapshots/
    â””â”€â”€ slot_X/ (periodic full state)
```

**Memory Mapping**

```c
// Simplified
void* accounts = mmap(NULL, size, PROT_READ | PROT_WRITE,
                      MAP_SHARED, fd, 0);

// Access account like regular memory
Account* acc = &accounts[offset];

// OS handles paging to/from disk
// Fast for sequential access patterns
```

**Why NVMe Matters**

```
HDD: 100 IOPS, 100MB/s
SSD: 10,000 IOPS, 500MB/s
NVMe: 500,000 IOPS, 7,000MB/s

Solana targets NVMe performance characteristics.
Validators without NVMe can't keep up.
```

> âœ… **Check Your Understanding**
> - [ ] How does PoH provide ordering guarantees?
> - [ ] Explain the vote lockout mechanism in Tower BFT
> - [ ] How does Turbine achieve fast block propagation?
> - [ ] What makes Gulf Stream different from a mempool?
> - [ ] How does Sealevel determine which transactions can run in parallel?

---

## Key Takeaways

1. **PoH is a verifiable clock** â€” proves time without synchronization
2. **Tower BFT uses exponential lockouts** â€” provides finality without explicit messages
3. **Turbine uses tree propagation** â€” O(log n) latency for block spread
4. **Gulf Stream skips mempools** â€” transactions go directly to leaders
5. **Sealevel parallelizes execution** â€” non-conflicting transactions run simultaneously
6. **Multiple clients improve resilience** â€” Agave + Firedancer in production
7. **Gossip keeps the network connected** â€” decentralized peer discovery
8. **Feature gates enable upgrades** â€” coordinated without hard forks

---

## Next

Now let's understand Solana's unique account model â€” the foundation for all program development.

â†’ [3.3 The Solana Account Model](./3.3-solana-account-model.md)
