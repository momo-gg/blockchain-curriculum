# 3.3 The Solana Account Model

> *"In Solana, programs are stateless. All state lives in accounts. This is the key insight that enables parallelism."*

---

## Why This Matters

Solana's account model is fundamentally different from Ethereum's contract model. Understanding this difference is essential for:
- Building applications on Solana
- Understanding why Solana can execute in parallel
- Debugging issues and optimizing performance
- Grasping the mental model of Solana development

This is the "aha moment" module for most developers.

---

## ðŸŸ¢ General Understanding

### The Big Difference

**Ethereum Model: Smart Contracts Store Their Own Data**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         Token Contract             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Code: transfer(), mint(), etc.    â”‚
â”‚                                    â”‚
â”‚  Storage:                          â”‚
â”‚    balances[Alice] = 100           â”‚
â”‚    balances[Bob] = 50              â”‚
â”‚    balances[Carol] = 200           â”‚
â”‚    ...                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Everything in one "object"
```

**Solana Model: Programs Are Code-Only, Data Lives Separately**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Token Program     â”‚     â† Just code, no data
â”‚   (Deployed once)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚
          â”‚ operates on
          â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Alice's Token      â”‚  â”‚  Bob's Token        â”‚  â”‚  Carol's Token      â”‚
â”‚  Account            â”‚  â”‚  Account            â”‚  â”‚  Account            â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€    â”‚  â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€    â”‚  â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€    â”‚
â”‚  Owner: Token Prog  â”‚  â”‚  Owner: Token Prog  â”‚  â”‚  Owner: Token Prog  â”‚
â”‚  Balance: 100       â”‚  â”‚  Balance: 50        â”‚  â”‚  Balance: 200       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Code and data are separate
```

### Why This Matters for Users

**1. Lower Costs**

In Ethereum, every token contract is deployed separately. In Solana, one token program handles all tokens:

```
Ethereum:
  USDC contract: Deployed, pays for code storage
  USDT contract: Deployed, pays for code storage
  DAI contract: Deployed, pays for code storage
  ... each pays for redundant code

Solana:
  Token program: Deployed once
  USDC mint: Just an account
  USDT mint: Just an account
  DAI mint: Just an account
  ... minimal overhead per token
```

**2. Predictable Addresses**

Your token account address is deterministic:

```
Your USDC account = derived from (your wallet + USDC mint + token program)

You can calculate it without ever seeing it on-chain.
No need to deploy anything.
```

**3. Parallel Execution**

Since data is separate:
- Alice transferring tokens doesn't touch Bob's account
- Both can happen simultaneously
- This is why Solana can run transactions in parallel

### What Is an Account?

An account is a data container with metadata:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      Solana Account                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  lamports: 1000000000          (Balance in lamports)       â”‚
â”‚  owner: TokenkegQ...           (Which program controls it) â”‚
â”‚  executable: false             (Is this code or data?)     â”‚
â”‚  rent_epoch: 432               (When rent was last paid)   â”‚
â”‚  data: [0x01, 0x00, ...]       (Arbitrary bytes)          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Address: 7xKX...abc123 (32-byte public key)
```

**Key Fields**

| Field | Purpose |
|-------|---------|
| `lamports` | Balance (1 SOL = 1 billion lamports) |
| `owner` | Program that can modify this account's data |
| `executable` | If true, this account holds program code |
| `data` | The actual content (interpreted by the owner program) |

### The Ownership Model

Every account has an "owner" â€” a program that controls it:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   System Program    â”‚  â† Owns your wallet (native SOL accounts)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Token Program     â”‚  â† Owns token accounts
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Your Program      â”‚  â† Owns your custom accounts
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Only the owner can:**
- Modify the account's data
- Subtract lamports from the account

**Anyone can:**
- Read the account's data
- Add lamports to the account

> ðŸ’¡ **Key Insight**: Ownership determines write permission. You "own" your tokens because the Token Program recognizes your wallet as the token account's authority, not because you own the account directly.

> âœ… **Check Your Understanding**
> - [ ] How does Solana's account model differ from Ethereum's?
> - [ ] Why does separation of code and data enable parallelism?
> - [ ] What does "owner" mean for an account?
> - [ ] Can anyone read an account's data?

---

## ðŸŸ¡ PM/EM Depth

### Rent: Paying for Storage

Storage isn't free. Accounts must be funded to be rent-exempt (rent collection is currently disabled on Solana, but minimum balances still apply):

**The Rent Model**

```
Option: Rent-exempt (what everyone uses)
  - Deposit minimum balance upfront
  - Account stays forever
  - Minimum: ~0.00203 SOL per KB of data
```

**Rent-Exempt Calculation**

```
Minimum balance = data_size Ã— rent_per_byte Ã— 2_years_of_rent

Example (token account, 165 bytes):
  165 bytes Ã— 0.00000348 SOL/byte Ã— 2 = ~0.00203 SOL

This is deposited when account is created.
It can be recovered if the account is closed.
```

**Business Implications**

| Consideration | Impact |
|---------------|--------|
| Account creation cost | ~$0.01-0.50 depending on data size |
| Closing accounts | Recovers rent deposit |
| Large data storage | Can become expensive at scale |
| Account reuse | More efficient than creating new |

### Account Types in Practice

**1. Wallet Accounts (System-Owned)**
```
Owner: System Program
Data: Empty (balance only)
Purpose: Hold SOL, sign transactions
```

**2. Token Accounts**
```
Owner: Token Program
Data: 165 bytes
Contains: mint address, owner wallet, balance, delegate, etc.
```

**3. Program Accounts**
```
Owner: BPF Loader
Executable: true
Data: Compiled program bytecode
```

**4. Program Data Accounts (PDAs)**
```
Owner: Your program
Data: Whatever your program needs
Purpose: Store application state
```

### Associated Token Accounts

The most common pattern for token storage:

```
Problem:
  - Token accounts need unique addresses
  - Users don't want to manage many addresses
  - Apps need to know where to send tokens

Solution: Associated Token Accounts (ATAs)
  - Deterministic address per (wallet, mint) pair
  - Created automatically when needed
  - Standard location everyone agrees on
```

**ATA Address Derivation**

```
ATA address = PDA derived from:
  - Wallet address
  - Token mint address
  - Token program address
  - Associated Token Program address

// Same inputs always give same output
const ata = await getAssociatedTokenAddress(
  mint,           // Which token
  wallet,         // Whose tokens
);
```

> ðŸ“Š **Business Context**: ATAs solved a major UX problem. Before ATAs, sending someone tokens might fail if they didn't have an account for that token. Now, the sender can create the recipient's account automatically.

### Account Lookup Tables (ALTs)

Transactions have a limited size. Each account reference is 32 bytes. ALTs compress this:

```
Without ALT:
  Transaction includes: [32B addr, 32B addr, 32B addr, ...]
  10 accounts = 320 bytes just for addresses

With ALT:
  Lookup table has: [addr1, addr2, addr3, ...]
  Transaction includes: [table_addr, index, index, index, ...]
  10 accounts = 32B table + 10 bytes = 42 bytes
```

**When to Use**
- Complex transactions with many accounts
- DeFi swaps (touch many pools)
- Batch operations

> âœ… **Check Your Understanding**
> - [ ] What's the rent-exempt minimum and why does it exist?
> - [ ] What's the difference between a wallet and a token account?
> - [ ] How do Associated Token Accounts solve a UX problem?
> - [ ] When would you use Account Lookup Tables?

---

## ðŸ”µ Engineer Depth

### Account Data Layout

Programs interpret account data according to their own schema:

**Token Account Layout (165 bytes)**

```rust
pub struct Account {
    pub mint: Pubkey,               // 32 bytes: Which token
    pub owner: Pubkey,              // 32 bytes: Who controls it
    pub amount: u64,                // 8 bytes: Balance
    pub delegate: COption<Pubkey>,  // 36 bytes: Optional spender
    pub state: AccountState,        // 1 byte: Initialized/Frozen
    pub is_native: COption<u64>,    // 12 bytes: Wrapped SOL info
    pub delegated_amount: u64,      // 8 bytes: Delegated balance
    pub close_authority: COption<Pubkey>, // 36 bytes: Who can close
}
// Total: 165 bytes
```

**Serialization**

Solana programs typically use Borsh (Binary Object Representation Serializer for Hashing):

```rust
use borsh::{BorshDeserialize, BorshSerialize};

#[derive(BorshSerialize, BorshDeserialize)]
pub struct Counter {
    pub count: u64,
    pub authority: Pubkey,
}

// Serialize
let data = counter.try_to_vec()?;

// Deserialize
let counter = Counter::try_from_slice(&account.data)?;
```

### Program Derived Addresses (PDAs)

PDAs are addresses derived deterministically without a private key:

**Why PDAs Exist**

Regular accounts need a signature to authorize changes. But programs can't sign (no private key). PDAs solve this:

```
Regular Address:
  - Has a private key
  - Lives on the ed25519 curve
  - Only the key holder can sign

PDA:
  - Has NO private key
  - "Bumped off" the curve
  - Program can "sign" for it
```

**PDA Derivation**

```rust
let (pda, bump) = Pubkey::find_program_address(
    &[
        b"my-seed",           // Static seed
        user.key.as_ref(),    // Dynamic seed (user's key)
    ],
    &program_id,
);

// The "bump" is a number (0-255) that makes the address invalid as a key
// We store the bump to reconstruct the PDA later
```

**How "Bump" Works**

```
sha256(seeds + program_id + bump) â†’ candidate address

Try bump = 255:
  If candidate is on the curve â†’ not valid, try bump = 254
  If candidate is off the curve â†’ found PDA!

The first valid bump is called the "canonical bump"
```

**Signing with PDAs**

Programs can authorize actions for PDAs they derived:

```rust
// In your program
invoke_signed(
    &transfer_instruction,
    &[source.clone(), destination.clone(), pda.clone()],
    &[&[b"my-seed", user.key.as_ref(), &[bump]]],  // PDA seeds
)?;
```

### Account Constraints in Anchor

Anchor framework simplifies account validation:

```rust
#[derive(Accounts)]
pub struct Transfer<'info> {
    #[account(mut)]  // Must be writable
    pub from: Account<'info, TokenAccount>,

    #[account(mut)]
    pub to: Account<'info, TokenAccount>,

    #[account(
        constraint = from.owner == authority.key(),  // Custom constraint
    )]
    pub authority: Signer<'info>,

    pub token_program: Program<'info, Token>,
}
```

**Common Constraints**

| Constraint | Purpose |
|------------|---------|
| `mut` | Account is writable |
| `signer` | Account must sign transaction |
| `init` | Create new account |
| `seeds`, `bump` | Validate PDA derivation |
| `has_one` | Field must match expected value |
| `constraint` | Custom validation logic |

### Cross-Program Invocations (CPIs)

Programs can call other programs:

```rust
// Your program calling the Token Program
use anchor_spl::token::{self, Transfer};

pub fn transfer_tokens(ctx: Context<TransferTokens>, amount: u64) -> Result<()> {
    let cpi_accounts = Transfer {
        from: ctx.accounts.from.to_account_info(),
        to: ctx.accounts.to.to_account_info(),
        authority: ctx.accounts.authority.to_account_info(),
    };

    let cpi_program = ctx.accounts.token_program.to_account_info();
    let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);

    token::transfer(cpi_ctx, amount)?;
    Ok(())
}
```

**CPI Depth Limit**

```
Your Transaction
  â””â”€â”€ Your Program (depth 0)
        â””â”€â”€ Token Program (depth 1)
              â””â”€â”€ Another Program (depth 2)
                    â””â”€â”€ Yet Another (depth 3)
                          â””â”€â”€ ... (max depth 4)
```

CPIs are limited to depth 4 to prevent stack overflow.

### Account Ownership Transitions

Accounts can change owners:

```rust
// System Program creates account owned by your program
invoke(
    &system_instruction::create_account(
        &payer.key(),           // Who pays
        &new_account.key(),     // New account address
        rent_lamports,          // Rent deposit
        data_len as u64,        // Size
        &your_program_id,       // Owner = your program
    ),
    &[payer, new_account],
)?;
```

**Ownership Transfer Rules**

| Action | Who Can Do It |
|--------|---------------|
| Create with specific owner | System Program |
| Change owner | Current owner program |
| Assign to System Program | Any owner (giving up ownership) |
| Close account | Owner program with close authority |

### Compute Units and Account Limits

Transactions have limits:

```rust
// Account limits
const MAX_ACCOUNTS_PER_TX: usize = 64;      // Without ALT
const MAX_ACCOUNTS_WITH_ALT: usize = 256;   // With ALT

// Size limits
const MAX_ACCOUNT_DATA: usize = 10 * 1024 * 1024;  // 10 MB max
const INITIAL_ACCOUNT_DATA: usize = 10 * 1024;      // 10 KB initial

// Compute limits
const DEFAULT_COMPUTE_UNITS: u64 = 200_000;
const MAX_COMPUTE_UNITS: u64 = 1_400_000;
```

**Compute Unit Considerations**

```rust
// Request more compute units if needed
let compute_budget_ix = ComputeBudgetInstruction::set_compute_unit_limit(400_000);

// Add priority fee
let priority_fee_ix = ComputeBudgetInstruction::set_compute_unit_price(1_000);
```

> âœ… **Check Your Understanding**
> - [ ] What is Borsh and why is it used?
> - [ ] How do PDAs differ from regular addresses?
> - [ ] Why can programs "sign" for PDAs?
> - [ ] What's the purpose of Account Lookup Tables?
> - [ ] What happens during a Cross-Program Invocation?

---

## Key Takeaways

1. **Programs are stateless** â€” all data lives in accounts, code is separate
2. **Accounts have owners** â€” only the owner program can modify data
3. **PDAs enable program-controlled accounts** â€” addresses without private keys
4. **Rent-exemption** â€” deposit ~2 years of rent for permanent storage
5. **ATAs standardize token storage** â€” deterministic addresses for tokens
6. **CPIs enable composability** â€” programs can call other programs
7. **This model enables parallelism** â€” non-overlapping accounts can execute simultaneously

---

## Next

Now let's understand who runs the network and how they're incentivized.

â†’ [3.4 Validators & Network Architecture](./3.4-validators-network.md)
