# 3.5 Staking Mechanics

---

## Why This Matters

Staking isn't just "locking up tokens for yield." It's the mechanism that:
- Secures the network (stake = weight in consensus)
- Distributes inflation rewards
- Aligns incentives between token holders and validators
- Creates economic consequences for misbehavior

Understanding staking helps you make informed decisions about where to stake, what risks you're taking, and how rewards actually work.

> âš ï¸ **Note**: Numeric examples in this module are illustrative. Verify current parameters and network values in Solanaâ€™s staking documentation and on-chain dashboards (as of [docs.solanalabs.com/consensus/stake-delegation-and-rewards](https://docs.solanalabs.com/consensus/stake-delegation-and-rewards)).

---

## ğŸŸ¢ General Understanding

### What Is Staking?

Staking means delegating your SOL to a validator to increase their voting power:

```
Your SOL (unstaked)
    â”‚
    â–¼ (You delegate to Validator A)
Validator A's total stake increases
    â”‚
    â–¼ (Validator A votes with more weight)
Network is more secure
    â”‚
    â–¼ (Validator A earns rewards proportional to stake)
You receive your share of rewards
```

**You're not giving away your SOL:**
- You retain ownership
- You can unstake anytime (after cooldown)
- Validator cannot access your funds
- Only the inflation rewards are shared

### How Rewards Work

Solana has built-in inflation that rewards stakers. The exact schedule changes over time; see the official staking/inflation docs (as of [solana.com/docs](https://solana.com/docs/references/staking)).

**Where Rewards Come From**

```
New SOL Minted:
  - Distributed to stakers proportionally
  - Defined by the protocolâ€™s inflation schedule

Distribution:
  - Rewards go to staked validators and their delegators
  - Validators share with delegators (minus commission)
```

**Your APY Calculation**

```
Example (illustrative only):
Network staking rate: 70%
Network inflation: 5%

Nominal APY = inflation / staking_rate

Minus validator commission (e.g., 5%):
  Effective APY = nominal APY Ã— (1 - commission)
```

> ğŸ’¡ **Key Insight**: The less SOL is staked, the higher the APY for those who do stake. This incentivizes more staking until an equilibrium.

### When Are Rewards Distributed?

**Per Epoch (~2 days)**

Epoch length is derived from Solana slot constants (as of [`solana-labs/solana` source](https://github.com/solana-labs/solana/blob/master/sdk/program/src/clock.rs)).

```
Epoch ends
    â†“
Reward calculation runs
    â†“
Credits counted for each validator
    â†“
Rewards deposited to stake accounts
    â†“
Next epoch begins

Your stake account balance increases automatically (as of Solana epoch timing constants).
```

### Stake Lifecycle (Simplified)

```
Delegate â†’ Activating â†’ Active â†’ Deactivating â†’ Withdrawable
          (warmup)                  (cooldown)
```

**How Rewards Compound**

Rewards are added to your stake account and count toward your effective stake in future epochs (as of [docs.solanalabs.com/consensus/stake-delegation-and-rewards](https://docs.solanalabs.com/consensus/stake-delegation-and-rewards)).

### How Do I Choose Where to Stake?

**Key Metrics to Consider**

| Metric | What to Look For |
|--------|------------------|
| Commission | Compare across validators; lower commission = higher rewards |
| APY | Higher isn't always better (check why) |
| Skip rate | Lower is better |
| Stake concentration | Avoid top validators (decentralization) |
| Uptime | Higher is better |
| Version | Current version = up to date |

**Does It Matter Where I Stake?**

Yes:
- Higher commission = lower rewards for you
- Bad validator = lower rewards (skip rate)
- Concentrated validators = bad for network
- Slashing risk (currently minimal on Solana)

**Recommended Approach**

```
1. Avoid the most stake-concentrated validators
2. Check commission relative to peers
3. Verify performance metrics on dashboards
4. Consider geography (different regions = resilience)
5. Evaluate validator's reputation and track record
```

> âœ… **Check Your Understanding**
> - [ ] Where do staking rewards come from?
> - [ ] How often are rewards distributed?
> - [ ] Why does less staking mean higher APY?
> - [ ] What should you consider when choosing a validator?

---

## ğŸŸ¡ PM/EM Depth

### Does Bitcoin Have Staking?

**Bitcoin = Proof of Work = No Native Staking**

```
Bitcoin:
  - Miners compete with hardware
  - No concept of "staking" at protocol level
  - Energy expenditure = security

Solana:
  - Validators stake SOL
  - Stake weight = voting power
  - Economic stake = security
```

**"Staking" in Bitcoin Ecosystem**

There are derivative products:
- Wrapped BTC on other chains (wBTC staking)
- Bitcoin DeFi protocols (Stacks, RSK)
- Centralized "earn" products (Celsius-style, risky)

But these aren't native Bitcoin staking â€” they're third-party products with counterparty risk.

### What Happens If My Validator Gets Slashed?

**Current State: Slashing Policy**

See Solana staking documentation for current enforcement details (as of [docs.solanalabs.com/consensus/stake-delegation-and-rewards](https://docs.solanalabs.com/consensus/stake-delegation-and-rewards)):

```
Ethereum Slashing:
  - Immediate financial penalty
  - Up to entire stake can be lost
  - Forced exit from validator set

Solana Slashing:
  - Enforcement differs from Ethereum
  - Check current policy in Solana staking documentation
```

**What Validators Can Be Punished For**

| Offense | Current Consequence |
|---------|---------------------|
| Double voting | Potential future slashing |
| Going offline | Lost rewards for those epochs |
| Poor performance | Stakers leave (market punishment) |
| Malicious behavior | Social slashing (community excludes) |

**Delegator Risk**

Currently very low:
- If validator performs poorly â†’ lower rewards
- If validator goes offline â†’ no rewards during downtime
- Your principal is safe

Future (if slashing activates):
- Potential for stake loss
- Important to diversify across validators

### Are Staked Tokens Visible On-Chain?

**Yes, completely transparent:**

```
Your wallet: 7xKX...abc123
  â””â”€â”€ Token Account: 100 USDC
  â””â”€â”€ Stake Account: 1000 SOL delegated to Validator A
  â””â”€â”€ Stake Account: 500 SOL delegated to Validator B

All visible on any block explorer.
```

**Do They Count in Your Wallet Balance?**

Depends on the wallet:
- Most wallets show staked SOL separately
- Some combine into total balance
- Staked SOL can't be spent without unstaking first

### What Does "50% of Fees Are Burned" Mean?

**Fee Distribution**

```
Example (illustrative):
User pays: 0.000005 SOL transaction fee

Distribution:
  - 50% burned: 0.0000025 SOL destroyed forever
  - 50% to leader: 0.0000025 SOL to block producer

"Burned" means:
  - Removed from circulation
  - Reduces total supply
  - Deflationary pressure
```

Fee burn percentage is defined in the protocol (as of [`solana-labs/solana` source](https://github.com/solana-labs/solana/blob/master/runtime/src/bank.rs)).

**Why Burn?**

```
Without burn:
  Inflation adds supply â†’ dilutes value
  Fees add more supply (to validators) â†’ more dilution

With burn:
  Inflation adds supply â†’ dilutes value
  Fees partially offset inflation â†’ less dilution

If fees burned > inflation:
  Net deflationary (hasn't happened yet)
```

**Who "Suffers"?**

```
Direct impact: Validators get less (only 50% of fees)
Indirect benefit: Token holders (less dilution)

The burn benefits all SOL holders by reducing supply.
Validators benefit from price appreciation if burn helps price.
```

### Liquid Staking: mSOL, jitoSOL, bSOL

**The Problem with Regular Staking**

```
Example (illustrative):
You stake 100 SOL
  â†’ SOL is locked during the cooldown period (can span multiple epochs)
  â†’ Can't use in DeFi
  â†’ Opportunity cost
```

**Liquid Staking Solution**

```
Example (illustrative):
You deposit 100 SOL into a liquid staking protocol
  â†’ Receive 100 mSOL (Marinade) or jitoSOL (Jito) or bSOL (Blaze)
  â†’ Protocol stakes your SOL across many validators
  â†’ You use mSOL in DeFi (swap, lend, LP)
  â†’ mSOL value increases over time (accrues rewards)
```

**How Value Accrues**

```
Day 1 (illustrative):
  - Deposit: 100 SOL
  - Receive: 100 mSOL
  - mSOL/SOL rate: 1.0

Day 365 (illustrative):
  - Your 100 mSOL is now worth more SOL
  - mSOL/SOL rate increases over time
  - You didn't do anything â€” rewards auto-compound

To exit:
  - Swap mSOL â†’ SOL on DEX (instant, small fee)
  - Or unstake through protocol (wait period, no fee)
```

**Comparison**

| Token | Protocol | Validator Strategy |
|-------|----------|-------------------|
| mSOL | Marinade | Score-based selection |
| jitoSOL | Jito | Jito validator set |
| bSOL | Blaze | Community validators |
| jupSOL | Jupiter | Jupiter validator set |

**Liquid Staking Trade-offs**
- **Smart contract risk**: protocol bugs or governance changes
- **Liquidity risk**: LSTs can trade at a discount or premium to SOL
- **DeFi risk**: using LSTs as collateral can trigger liquidations
- **Operational risk**: validator performance affects rewards

### Stake Concentration Concerns

**The Problem**

```
Stake concentration changes frequently. Check current distribution and Nakamoto coefficient at [Validators.app](https://www.validators.app/) or [Solana Beach](https://solanabeach.io/validators) (as of those sources).
```

**Why Concentration Happens**

```
Stakers choose:
  - Big exchanges (easy, trusted brand)
  - Top APY (often unsustainably subsidized)
  - Default options in wallets

Result:
  - Rich get richer
  - Small validators struggle
  - Network becomes less decentralized
```

**What You Can Do**

```
Stake with:
  - Validators outside top 33
  - Different geographic regions
  - Different entity types (not all exchanges)

Use liquid staking that spreads stake:
  - Multi-validator strategies reduce concentration risk
```

> âœ… **Check Your Understanding**
> - [ ] Does Bitcoin have native staking?
> - [ ] What happens to delegators if their validator is slashed?
> - [ ] How does liquid staking solve the "locked capital" problem?
> - [ ] Why is stake concentration a concern?

---

## ğŸ”µ Engineer Depth

### Stake Account Structure

```rust
pub struct StakeState {
    pub meta: Meta,
    pub stake: Option<Stake>,
}

pub struct Meta {
    pub rent_exempt_reserve: u64,    // Minimum balance
    pub authorized: Authorized,       // Who can stake/withdraw
    pub lockup: Lockup,               // Optional time lock
}

pub struct Stake {
    pub delegation: Delegation,
    pub credits_observed: u64,        // For reward calculation
}

pub struct Delegation {
    pub voter_pubkey: Pubkey,         // Which validator
    pub stake: u64,                   // Amount delegated
    pub activation_epoch: Epoch,      // When delegation started
    pub deactivation_epoch: Epoch,    // When unstaking started
    pub warmup_cooldown_rate: f64,    // 0.25 by default
}
```

### Stake Account Lifecycle

```
1. CREATE (System Program)
   create_account() â†’ empty account

2. INITIALIZE (Stake Program)
   initialize() â†’ set authorities, lockup

3. DELEGATE (Stake Program)
   delegate() â†’ specify validator vote account
   - Stake is "activating"
   - Takes 1 epoch to become active

4. ACTIVE
   - Earning rewards each epoch
   - Counted in validator's voting weight

5. DEACTIVATE (Stake Program)
   deactivate() â†’ start cooldown
   - Takes 1 epoch to fully deactivate
   - Still earns partial rewards during cooldown

6. WITHDRAW (Stake Program)
   withdraw() â†’ remove SOL after deactivation
   - Only after deactivation_epoch + 1
```

### Reward Calculation

```rust
// Simplified reward calculation
fn calculate_stake_rewards(
    stake: &Stake,
    vote_state: &VoteState,
    point_value: f64,
) -> u64 {
    // Credits earned by validator this epoch
    let credits_earned = vote_state.epoch_credits.last()
        - stake.credits_observed;

    // Points = stake Ã— credits
    let points = stake.delegation.stake * credits_earned;

    // Rewards = points Ã— point_value
    let rewards = (points as f64 * point_value) as u64;

    // Apply validator commission
    let commission = vote_state.commission as f64 / 100.0;
    let delegator_rewards = rewards * (1.0 - commission);

    delegator_rewards
}
```

**Point Value Calculation**

```rust
// Total points in epoch
let total_points: u128 = all_stakes.iter()
    .map(|s| s.stake * s.credits_earned)
    .sum();

// Total rewards available
let total_rewards = inflation_for_epoch();

// Value per point
let point_value = total_rewards as f64 / total_points as f64;
```

### Stake Warmup and Cooldown

```rust
const WARMUP_COOLDOWN_RATE: f64 = 0.25;

fn effective_stake(
    stake: u64,
    current_epoch: Epoch,
    activation_epoch: Epoch,
    deactivation_epoch: Epoch,
) -> u64 {
    if current_epoch < activation_epoch {
        // Not yet activating
        return 0;
    }

    if deactivation_epoch != Epoch::MAX {
        // Deactivating
        let epochs_since_deactivation = current_epoch - deactivation_epoch;
        let remaining = (1.0 - WARMUP_COOLDOWN_RATE).powi(epochs_since_deactivation);
        return (stake as f64 * remaining) as u64;
    }

    // Activating or fully active
    let epochs_since_activation = current_epoch - activation_epoch;
    let progress = 1.0 - (1.0 - WARMUP_COOLDOWN_RATE).powi(epochs_since_activation);
    (stake as f64 * progress.min(1.0)) as u64
}
```

### Split and Merge Operations

**Splitting a Stake Account**

```rust
pub fn split(
    stake_account: &Pubkey,
    authorized: &Keypair,
    lamports: u64,
    split_stake: &Keypair,
) -> Instruction {
    stake_instruction::split(
        stake_account,
        &authorized.pubkey(),
        lamports,
        &split_stake.pubkey(),
    )
}

// Use case: Move some stake to different validator
// Original: 1000 SOL delegated to Validator A
// After split:
//   - Original: 600 SOL â†’ Validator A
//   - Split: 400 SOL â†’ Redelegate to Validator B
```

**Merging Stake Accounts**

```rust
pub fn merge(
    destination: &Pubkey,
    source: &Pubkey,
    authorized: &Keypair,
) -> Instruction {
    stake_instruction::merge(
        destination,
        source,
        &authorized.pubkey(),
    )
}

// Requirements:
// - Same authorized staker
// - Same lockup
// - Both active or both inactive
// - Same validator if active
```

### Epoch Boundary Processing

```
Epoch N ends
    â”‚
    â–¼
REWARD DISTRIBUTION (compute-intensive)
    â”‚
    â”œâ”€â”€ Calculate total credits per validator
    â”œâ”€â”€ Calculate point value
    â”œâ”€â”€ For each stake account:
    â”‚     â””â”€â”€ Calculate and credit rewards
    â”œâ”€â”€ Credit validator commissions
    â””â”€â”€ Update stake account credits_observed
    â”‚
    â–¼
LEADER SCHEDULE GENERATION
    â”‚
    â”œâ”€â”€ Snapshot effective stake
    â”œâ”€â”€ Generate random schedule
    â””â”€â”€ Publish for next epoch
    â”‚
    â–¼
Epoch N+1 begins
```

Epoch reward distribution mechanics evolve via SIMDs; see the proposals index for current details (as of [docs.solanalabs.com/proposals](https://docs.solanalabs.com/proposals)).

### Liquid Staking: Technical Implementation

**Marinade (mSOL) Architecture**

```
User deposits SOL
    â”‚
    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          Marinade State Account              â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€   â”‚
â”‚  total_deposited: <sol>                     â”‚
â”‚  total_mSOL: <msol>                         â”‚
â”‚  msol_price: total_deposited / total_mSOL   â”‚
â”‚                                              â”‚
â”‚  Validator Stake Distribution:               â”‚
â”‚    Multiple validators                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â”‚
    â–¼
User receives mSOL (value increases over time)
```

**Price Update Mechanism**

```rust
// Each epoch, after rewards:
fn update_msol_price(state: &mut MarinadeState) {
    // Total value = all staked SOL + rewards
    let total_sol = state.stake_accounts.iter()
        .map(|s| s.balance)
        .sum::<u64>();

    // mSOL supply is fixed (only changes on deposits/withdrawals)
    let msol_supply = state.total_msol;

    // New price
    state.msol_price = total_sol as f64 / msol_supply as f64;
}

// Example:
// Start: 1,000,000 SOL backing 1,000,000 mSOL = 1.0
// After rewards: 1,070,000 SOL backing 1,000,000 mSOL = 1.07
```

> âœ… **Check Your Understanding**
> - [ ] What's the structure of a stake account?
> - [ ] How are staking rewards calculated?
> - [ ] Why does stake warmup/cooldown exist?
> - [ ] How does liquid staking price appreciation work?

---

## Key Takeaways

1. **Staking = delegating to validators** â€” you keep ownership
2. **Rewards come from inflation** â€” check current inflation parameters
3. **APY depends on staking rate** â€” fewer stakers = higher APY
4. **Validator choice matters** â€” commission, performance, decentralization
5. **Slashing policy varies** â€” check current enforcement and delegator risks
6. **Liquid staking unlocks capital** â€” use staked SOL in DeFi
7. **Stake concentration is a concern** â€” stake outside top validators

---

## Next

Transaction ordering creates profit opportunities. Let's understand MEV on Solana.

â†’ [3.6 MEV on Solana](./3.6-mev-on-solana.md)
