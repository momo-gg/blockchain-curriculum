# 4.2 Your First Solana Program

> *"The best way to learn is to build."*

---

## Why This Matters

In this module, you'll build a complete Solana program from scratch â€” a simple counter that can be incremented and read. This covers the fundamental patterns you'll use in every Solana program.

---

## ğŸŸ¢ General Understanding

### What Is a Solana Program?

A Solana program is like a vending machine on the blockchain:
- **Stateless**: The program itself has no memory â€” it's just rules
- **Accounts store data**: Like storage lockers the program can access
- **Instructions trigger actions**: Like pressing a button on the vending machine

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Program vs Accounts                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                      â”‚
â”‚   PROGRAM (The Rules)              ACCOUNTS (The Data)              â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚
â”‚   â”‚ Counter Program â”‚              â”‚ Counter Account â”‚              â”‚
â”‚   â”‚                 â”‚              â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚              â”‚
â”‚   â”‚ initialize()    â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚ â”‚ count: 42   â”‚ â”‚              â”‚
â”‚   â”‚ increment()     â”‚   reads/     â”‚ â”‚ authority:  â”‚ â”‚              â”‚
â”‚   â”‚ reset()         â”‚   writes     â”‚ â”‚  Alice      â”‚ â”‚              â”‚
â”‚   â”‚                 â”‚              â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚              â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚
â”‚                                                                      â”‚
â”‚   The program defines              Accounts store the               â”‚
â”‚   WHAT can happen                  actual values                    â”‚
â”‚                                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ELI5: Programs and Accounts

**Think of a board game:**
- The **program** is the rulebook â€” it never changes during the game
- The **accounts** are the game pieces and score cards â€” they change as you play
- **Instructions** are like taking a turn â€” "I want to move my piece 3 spaces"

---

## ğŸŸ¡ PM/EM Depth

### Program Structure Overview

Every Anchor program has three main parts:

| Part | Purpose | Example |
|------|---------|---------|
| **declare_id!** | Unique program address on blockchain | Like an API endpoint URL |
| **#[program]** | Functions users can call | Like REST API handlers |
| **#[account]** | Data structures stored on-chain | Like database schemas |

### Development Cycle

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Build â†’ Test â†’ Deploy Cycle                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                      â”‚
â”‚   1. Write Rust code                                                 â”‚
â”‚   2. anchor build (compiles, generates IDL + types)                  â”‚
â”‚   3. anchor test (runs local validator, executes tests)              â”‚
â”‚   4. Fix issues, repeat 1-3                                          â”‚
â”‚   5. anchor deploy (push to devnet/mainnet)                          â”‚
â”‚                                                                      â”‚
â”‚   Typical iteration: 30 seconds to rebuild and test                  â”‚
â”‚                                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### What the Counter Program Demonstrates

| Feature | Why It Matters |
|---------|----------------|
| Account initialization | Creating storage for your program |
| State mutations | Changing on-chain data |
| Authority checks | Access control (who can do what) |
| Error handling | Graceful failure with meaningful messages |

---

## ğŸ”µ Engineer Depth

## The Counter Program

We'll build a program that:
1. Initializes a counter account
2. Increments the counter
3. Allows reading the current value

### Project Setup

```bash
# Create new project
anchor init counter
cd counter

# Open in your editor
code .
```

### The Complete Program

Replace `programs/counter/src/lib.rs`:

```rust
use anchor_lang::prelude::*;

declare_id!("CounterProgram111111111111111111111111111");

#[program]
pub mod counter {
    use super::*;

    /// Initialize a new counter account
    pub fn initialize(ctx: Context<Initialize>) -> Result<()> {
        let counter = &mut ctx.accounts.counter;
        counter.count = 0;
        counter.authority = ctx.accounts.authority.key();
        counter.bump = ctx.bumps.counter;

        msg!("Counter initialized! Current count: {}", counter.count);
        Ok(())
    }

    /// Increment the counter by 1
    pub fn increment(ctx: Context<Increment>) -> Result<()> {
        let counter = &mut ctx.accounts.counter;
        counter.count = counter.count.checked_add(1)
            .ok_or(ErrorCode::Overflow)?;

        msg!("Counter incremented! New count: {}", counter.count);
        Ok(())
    }

    /// Increment the counter by a specific amount
    pub fn increment_by(ctx: Context<Increment>, amount: u64) -> Result<()> {
        let counter = &mut ctx.accounts.counter;
        counter.count = counter.count.checked_add(amount)
            .ok_or(ErrorCode::Overflow)?;

        msg!("Counter incremented by {}! New count: {}", amount, counter.count);
        Ok(())
    }

    /// Reset the counter to zero (only authority can do this)
    pub fn reset(ctx: Context<Reset>) -> Result<()> {
        let counter = &mut ctx.accounts.counter;
        counter.count = 0;

        msg!("Counter reset to 0");
        Ok(())
    }
}

/// Account structure for the counter
#[account]
#[derive(InitSpace)]
pub struct Counter {
    pub authority: Pubkey,  // 32 bytes: Who can reset
    pub count: u64,         // 8 bytes: Current count
    pub bump: u8,           // 1 byte: PDA bump seed
}

/// Accounts required for initialization
#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(
        init,
        payer = authority,
        space = 8 + Counter::INIT_SPACE,
        seeds = [b"counter", authority.key().as_ref()],
        bump
    )]
    pub counter: Account<'info, Counter>,

    #[account(mut)]
    pub authority: Signer<'info>,

    pub system_program: Program<'info, System>,
}

/// Accounts required for incrementing
#[derive(Accounts)]
pub struct Increment<'info> {
    #[account(
        mut,
        seeds = [b"counter", counter.authority.as_ref()],
        bump = counter.bump
    )]
    pub counter: Account<'info, Counter>,
}

/// Accounts required for reset (authority only)
#[derive(Accounts)]
pub struct Reset<'info> {
    #[account(
        mut,
        seeds = [b"counter", authority.key().as_ref()],
        bump = counter.bump,
        has_one = authority
    )]
    pub counter: Account<'info, Counter>,

    pub authority: Signer<'info>,
}

/// Custom error codes
#[error_code]
pub enum ErrorCode {
    #[msg("Counter overflow")]
    Overflow,
}
```

---

## Understanding Each Part

### 1. Program Declaration

```rust
use anchor_lang::prelude::*;

declare_id!("CounterProgram111111111111111111111111111");
```

- `use anchor_lang::prelude::*` â€” imports common Anchor types
- `declare_id!` â€” your program's unique address on-chain

**Get your actual program ID:**
```bash
anchor keys list
# counter: Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS

# Update declare_id! with this value
```

### 2. The #[program] Module

```rust
#[program]
pub mod counter {
    use super::*;

    pub fn initialize(ctx: Context<Initialize>) -> Result<()> {
        // ...
    }
}
```

- `#[program]` â€” marks this module as containing instruction handlers
- Each `pub fn` is an instruction clients can call
- `Context<T>` â€” contains accounts for instruction `T`
- Returns `Result<()>` â€” success or error

### 3. Account Structs

```rust
#[account]
#[derive(InitSpace)]
pub struct Counter {
    pub authority: Pubkey,  // 32 bytes
    pub count: u64,         // 8 bytes
    pub bump: u8,           // 1 byte
}
```

- `#[account]` â€” marks as an Anchor account type
- `#[derive(InitSpace)]` â€” auto-calculates space needed
- Fields are serialized with Borsh

**Space Calculation:**
```
8 bytes (Anchor discriminator) +
32 bytes (Pubkey) +
8 bytes (u64) +
1 byte (u8)
= 49 bytes
```

### 4. Account Validation

```rust
#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(
        init,                                    // Create new account
        payer = authority,                       // Who pays rent
        space = 8 + Counter::INIT_SPACE,         // Space needed
        seeds = [b"counter", authority.key().as_ref()],  // PDA seeds
        bump                                     // Auto-find bump
    )]
    pub counter: Account<'info, Counter>,

    #[account(mut)]                              // Mutable (pays SOL)
    pub authority: Signer<'info>,                // Must sign transaction

    pub system_program: Program<'info, System>,  // For account creation
}
```

**Common Constraints:**

| Constraint | Purpose |
|------------|---------|
| `init` | Create new account |
| `mut` | Account is writable |
| `seeds`, `bump` | Validate/derive PDA |
| `has_one = field` | Validate field matches |
| `constraint = expr` | Custom boolean check |
| `close = target` | Close account, send rent to target |

### 5. Error Handling

```rust
#[error_code]
pub enum ErrorCode {
    #[msg("Counter overflow")]
    Overflow,
}

// Usage:
counter.count.checked_add(1).ok_or(ErrorCode::Overflow)?
```

- Custom errors for clear failure messages
- Use `?` to propagate errors
- Anchor errors auto-include helpful context

---

## Writing Tests

Replace `tests/counter.ts`:

```typescript
import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { Counter } from "../target/types/counter";
import { expect } from "chai";

describe("counter", () => {
  // Configure the client
  const provider = anchor.AnchorProvider.env();
  anchor.setProvider(provider);

  const program = anchor.workspace.Counter as Program<Counter>;
  const authority = provider.wallet;

  // Derive the counter PDA
  const [counterPda] = anchor.web3.PublicKey.findProgramAddressSync(
    [Buffer.from("counter"), authority.publicKey.toBuffer()],
    program.programId
  );

  it("Initializes the counter", async () => {
    const tx = await program.methods
      .initialize()
      .accounts({
        counter: counterPda,
        authority: authority.publicKey,
        systemProgram: anchor.web3.SystemProgram.programId,
      })
      .rpc();

    console.log("Initialize tx:", tx);

    // Fetch the counter account
    const counter = await program.account.counter.fetch(counterPda);

    expect(counter.count.toNumber()).to.equal(0);
    expect(counter.authority.toString()).to.equal(authority.publicKey.toString());
  });

  it("Increments the counter", async () => {
    await program.methods
      .increment()
      .accounts({
        counter: counterPda,
      })
      .rpc();

    const counter = await program.account.counter.fetch(counterPda);
    expect(counter.count.toNumber()).to.equal(1);
  });

  it("Increments by a specific amount", async () => {
    await program.methods
      .incrementBy(new anchor.BN(5))
      .accounts({
        counter: counterPda,
      })
      .rpc();

    const counter = await program.account.counter.fetch(counterPda);
    expect(counter.count.toNumber()).to.equal(6);
  });

  it("Resets the counter", async () => {
    await program.methods
      .reset()
      .accounts({
        counter: counterPda,
        authority: authority.publicKey,
      })
      .rpc();

    const counter = await program.account.counter.fetch(counterPda);
    expect(counter.count.toNumber()).to.equal(0);
  });

  it("Fails when non-authority tries to reset", async () => {
    // Create a different keypair
    const otherUser = anchor.web3.Keypair.generate();

    try {
      await program.methods
        .reset()
        .accounts({
          counter: counterPda,
          authority: otherUser.publicKey,
        })
        .signers([otherUser])
        .rpc();

      expect.fail("Should have thrown an error");
    } catch (err) {
      expect(err.toString()).to.include("has_one");
    }
  });
});
```

### Run Tests

```bash
# Build and test
anchor test

# Expected output:
# counter
#   âœ” Initializes the counter
#   âœ” Increments the counter
#   âœ” Increments by a specific amount
#   âœ” Resets the counter
#   âœ” Fails when non-authority tries to reset
#
# 5 passing
```

---

## Understanding the Flow

### What Happens When You Call `initialize()`?

```
Client (TypeScript)
    â”‚
    â–¼ Build transaction with:
        - Instruction: initialize
        - Accounts: counter (PDA), authority (signer), system_program
        - Sign with authority
    â”‚
    â–¼ Send to Solana
        â”‚
        â–¼ RPC receives, forwards to leader
            â”‚
            â–¼ Leader executes program
                â”‚
                â–¼ Anchor validates accounts:
                    - counter: Creates PDA, allocates space, sets owner to program
                    - authority: Verified as signer, marked mutable
                    - system_program: Verified as system program
                â”‚
                â–¼ Your code runs:
                    - counter.count = 0
                    - counter.authority = authority.key()
                    - counter.bump = bump
                â”‚
                â–¼ Anchor serializes counter account data
                â”‚
                â–¼ Transaction committed to block
    â”‚
    â–¼ Client receives confirmation
```

### Where Is the Counter Stored?

```
Counter PDA: derived from ["counter", authority_pubkey]

Account on-chain:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Address: 7xKX...abc123 (the PDA)                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Owner: CounterProgram111...                                     â”‚
â”‚ Lamports: 1141440 (rent-exempt minimum)                         â”‚
â”‚ Data: [discriminator][authority][count][bump]                   â”‚
â”‚       [8 bytes    ][32 bytes  ][8 bytes][1 byte]               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Common Patterns

### Pattern 1: PDA for User-Specific Data

```rust
#[derive(Accounts)]
pub struct UserAction<'info> {
    #[account(
        seeds = [b"user-data", user.key().as_ref()],
        bump
    )]
    pub user_data: Account<'info, UserData>,

    pub user: Signer<'info>,
}
```

Each user gets their own data account, derived from their public key.

### Pattern 2: Global State

```rust
#[derive(Accounts)]
pub struct GlobalAction<'info> {
    #[account(
        seeds = [b"global-state"],
        bump
    )]
    pub global_state: Account<'info, GlobalState>,
}
```

Single account for program-wide state.

### Pattern 3: Authorization Checks

```rust
#[derive(Accounts)]
pub struct AdminAction<'info> {
    #[account(
        mut,
        has_one = admin,  // config.admin must match admin account
    )]
    pub config: Account<'info, Config>,

    pub admin: Signer<'info>,
}
```

Only the admin stored in config can call this instruction.

---

## Deploying to Devnet

```bash
# Ensure correct network
solana config set --url devnet

# Check balance (ensure you have sufficient SOL for fees and rent)
solana balance

# Build
anchor build

# Update program ID in lib.rs and Anchor.toml
anchor keys list

# Deploy
anchor deploy

# Verify deployment
solana program show <YOUR_PROGRAM_ID>
```

---

## Exercises

### Exercise 1: Add a Decrement Function

Add a function that decrements the counter, but prevents going below zero.

<details>
<summary>Solution</summary>

```rust
pub fn decrement(ctx: Context<Increment>) -> Result<()> {
    let counter = &mut ctx.accounts.counter;
    counter.count = counter.count.checked_sub(1)
        .ok_or(ErrorCode::Underflow)?;
    Ok(())
}

#[error_code]
pub enum ErrorCode {
    #[msg("Counter overflow")]
    Overflow,
    #[msg("Counter underflow")]
    Underflow,
}
```
</details>

### Exercise 2: Add Last Updated Timestamp

Track when the counter was last modified.

<details>
<summary>Solution</summary>

```rust
use anchor_lang::solana_program::clock::Clock;

#[account]
#[derive(InitSpace)]
pub struct Counter {
    pub authority: Pubkey,
    pub count: u64,
    pub bump: u8,
    pub last_updated: i64,  // Unix timestamp
}

pub fn increment(ctx: Context<Increment>) -> Result<()> {
    let counter = &mut ctx.accounts.counter;
    let clock = Clock::get()?;

    counter.count = counter.count.checked_add(1)
        .ok_or(ErrorCode::Overflow)?;
    counter.last_updated = clock.unix_timestamp;

    Ok(())
}
```
</details>

---

## Key Takeaways

1. **Programs are stateless** â€” all data lives in accounts
2. **PDAs provide deterministic addresses** â€” derive from seeds
3. **Anchor validates accounts** â€” constraints catch errors early
4. **Every instruction needs accounts** â€” specified in the `Accounts` struct
5. **Tests should cover happy path AND errors** â€” verify authorization works

---

## Next

Let's dive deeper into accounts and PDAs â€” the foundation of Solana programs.

â†’ [4.3 Deep Dive: Accounts & PDAs](./4.3-accounts-and-pdas.md)
