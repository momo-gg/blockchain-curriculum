# 4.3 Deep Dive: Accounts & PDAs

> *"Accounts are the fundamental unit of state in Solana. Master them, and you master Solana."*

---

## Why This Matters

Every piece of data on Solana lives in an account. Understanding accounts deeply â€” how they're created, owned, modified, and derived â€” is essential for building secure, efficient programs.

This module explores:
- Account anatomy and ownership
- Program Derived Addresses (PDAs)
- Account creation patterns
- Common pitfalls and best practices

---

## ğŸŸ¢ General Understanding

### What Are Accounts?

Accounts are Solana's way of storing data. Think of them as "storage lockers" on the blockchain.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Accounts = Storage Lockers                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                      â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”‚
â”‚   â”‚ Locker #1   â”‚  â”‚ Locker #2   â”‚  â”‚ Locker #3   â”‚                â”‚
â”‚   â”‚ Owner: You  â”‚  â”‚ Owner: App  â”‚  â”‚ Owner: Tokenâ”‚                â”‚
â”‚   â”‚ Data: $500  â”‚  â”‚ Data: Game  â”‚  â”‚ Data: 1000  â”‚                â”‚
â”‚   â”‚             â”‚  â”‚  state      â”‚  â”‚  USDC       â”‚                â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â”‚
â”‚                                                                      â”‚
â”‚   Every locker has:                                                  â”‚
â”‚   â€¢ An address (how to find it)                                      â”‚
â”‚   â€¢ An owner (who controls it)                                       â”‚
â”‚   â€¢ Data (what's stored)                                            â”‚
â”‚   â€¢ Balance (rent payment)                                          â”‚
â”‚                                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ELI5: PDAs (Program Derived Addresses)

**PDAs are like keyless lockers that only the program can open.**

Imagine a vending machine that has a small storage box inside:
- Regular wallets are like lockers with keys â€” you need the key (private key) to open them
- PDAs are like the vending machine's internal cash box â€” only the machine itself can access it
- The machine (program) doesn't need a physical key â€” it proves it's the machine using math

**Why use PDAs?**
- Programs can control accounts without needing private keys
- Users can find PDA addresses deterministically (predictably)
- Safe from human error â€” no keys to lose

### PDA Derivation (Visual)

```
Seeds + Program ID + Bump
        â†“
  find_program_address()
        â†“
     PDA Address
```

---

## ğŸŸ¡ PM/EM Depth

### Account Types Overview

| Account Type | Owner | Use Case | Example |
|--------------|-------|----------|---------|
| **Wallet** | System Program | Hold SOL | User's main wallet |
| **Token Account** | Token Program | Hold tokens | Your USDC balance |
| **Data Account** | Your Program | Store app state | Game save data |
| **PDA** | Your Program | Program-controlled | Escrow holding funds |

### PDA Use Cases

| Pattern | Description | Example |
|---------|-------------|---------|
| **Escrow** | Hold funds until conditions met | NFT auction payments |
| **State storage** | Deterministic per-user storage | User profile per app |
| **Authority** | Program-controlled signing | Swap pool liquidity |
| **Config** | Global program settings | Fee percentages |

### Rent Economics

Accounts must hold a rent-exempt balance to exist on Solana (rent collection is currently disabled, but minimums still apply):

| Account Size | Rent-Exempt Amount | Notes |
|--------------|-------------------|-------|
| Minimum (0 bytes) | Varies | Just the header |
| Token Account | Varies | 165 bytes |
| 1 KB | Varies | Small data |
| 10 KB | Varies | Medium data |

**Key Insight**: Rent is refunded when accounts are closed.

---

## ğŸ”µ Engineer Depth

### Digital Signatures: Ed25519 in Solana

Solana uses Ed25519 signatures for transactions. At a high level:

**Elliptic Curve Basics**
- A private key is a random scalar `a`.
- A public key is a curve point `A = a * B` where `B` is the base point.
- Scalar multiplication is one-way: easy to compute, hard to reverse.

**Signing (EdDSA over edwards25519)**
```
Given message m and private key a:
1) r = H(prefix || m)                // deterministic nonce
2) R = r * B                         // nonce point
3) s = r + H(R, A, m) * a mod L
Signature = (R, s)
```

**Verification**
```
Check: s * B == R + H(R, A, m) * A
```

This proves the signer knew `a` without revealing it. Every Solana transaction includes one or more Ed25519 signatures over the message bytes.

## Account Anatomy

Every account has the same structure:

```rust
pub struct AccountInfo<'a> {
    pub key: &'a Pubkey,              // 32 bytes: Account address
    pub lamports: Rc<RefCell<&'a mut u64>>,  // Balance
    pub data: Rc<RefCell<&'a mut [u8]>>,     // Arbitrary data
    pub owner: &'a Pubkey,            // 32 bytes: Owning program
    pub rent_epoch: Epoch,            // When rent was last paid
    pub is_signer: bool,              // Did this account sign?
    pub is_writable: bool,            // Can this account be modified?
    pub executable: bool,             // Is this a program?
}
```

### The Ownership Model

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         OWNERSHIP RULES                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                      â”‚
â”‚   ONLY THE OWNER CAN:                                               â”‚
â”‚   â”œâ”€â”€ Modify the account's data                                     â”‚
â”‚   â””â”€â”€ Debit lamports from the account                               â”‚
â”‚                                                                      â”‚
â”‚   ANYONE CAN:                                                       â”‚
â”‚   â”œâ”€â”€ Read the account's data                                       â”‚
â”‚   â””â”€â”€ Credit lamports to the account                                â”‚
â”‚                                                                      â”‚
â”‚   SPECIAL CASES:                                                    â”‚
â”‚   â”œâ”€â”€ System Program owns "wallet" accounts                         â”‚
â”‚   â”œâ”€â”€ BPF Loader owns program accounts                              â”‚
â”‚   â””â”€â”€ Your program owns accounts it creates                         â”‚
â”‚                                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Account Types by Owner

| Owner | Account Type | Contains |
|-------|--------------|----------|
| System Program | Native account (wallet) | Just SOL balance |
| Token Program | Token account | Token balance, mint, owner |
| Your Program | Data account | Whatever you define |
| BPF Loader | Program account | Executable code |

---

## Program Derived Addresses (PDAs)

PDAs are addresses derived deterministically without a private key.

### Why PDAs Exist

```
PROBLEM:
  Regular accounts need a private key to sign
  Programs don't have private keys
  How can a program control an account?

SOLUTION:
  PDAs are derived from seeds + program ID
  They're "off the curve" (no valid private key)
  The program can "sign" for them using invoke_signed
```

### How PDA Derivation Works

```rust
// Find a PDA
let (pda, bump) = Pubkey::find_program_address(
    &[
        b"user-account",           // Static seed
        user.key().as_ref(),       // Dynamic seed
    ],
    &program_id,
);

// Under the hood:
// 1. hash = sha256(seeds || program_id || 255)
// 2. If hash is a valid public key, try bump = 254
// 3. Repeat until hash is NOT a valid public key
// 4. That hash is the PDA, bump is the "canonical bump"
```

### The Bump Seed

```rust
// The bump makes the address "fall off" the curve
// It's a u8 (0-255), found by trying 255, 254, 253... until valid PDA

// Always store the bump!
#[account]
pub struct UserAccount {
    pub user: Pubkey,
    pub data: u64,
    pub bump: u8,  // Store this!
}

// Recreate PDA with stored bump (faster than find_program_address)
let pda = Pubkey::create_program_address(
    &[
        b"user-account",
        user.key().as_ref(),
        &[stored_bump],
    ],
    &program_id,
)?;
```

### PDA Seed Patterns

**Pattern 1: Per-User Account**
```rust
seeds = [b"user-data", user.key().as_ref()]
// Each user gets exactly one account
```

**Pattern 2: Per-Item Account**
```rust
seeds = [b"item", item_id.to_le_bytes().as_ref()]
// Each item ID gets an account
```

**Pattern 3: User + Context**
```rust
seeds = [b"user-game-score", user.key().as_ref(), game_id.as_ref()]
// User's score for a specific game
```

**Pattern 4: Global Singleton**
```rust
seeds = [b"global-config"]
// Only one such account can exist
```

---

## Account Creation

### Method 1: Anchor's `init`

```rust
#[derive(Accounts)]
pub struct CreateAccount<'info> {
    #[account(
        init,
        payer = user,
        space = 8 + MyAccount::INIT_SPACE,
        seeds = [b"my-account", user.key().as_ref()],
        bump
    )]
    pub my_account: Account<'info, MyAccount>,

    #[account(mut)]
    pub user: Signer<'info>,

    pub system_program: Program<'info, System>,
}
```

### Method 2: Manual Creation (Native)

```rust
use anchor_lang::solana_program::{
    program::invoke_signed,
    system_instruction,
};

pub fn create_account_manually(ctx: Context<CreateManually>) -> Result<()> {
    let space = 100; // bytes
    let lamports = Rent::get()?.minimum_balance(space);

    let seeds = &[
        b"my-account",
        ctx.accounts.user.key.as_ref(),
        &[ctx.bumps.my_account],
    ];
    let signer_seeds = &[&seeds[..]];

    invoke_signed(
        &system_instruction::create_account(
            ctx.accounts.user.key,
            ctx.accounts.my_account.key,
            lamports,
            space as u64,
            ctx.program_id,
        ),
        &[
            ctx.accounts.user.to_account_info(),
            ctx.accounts.my_account.to_account_info(),
            ctx.accounts.system_program.to_account_info(),
        ],
        signer_seeds,
    )?;

    Ok(())
}
```

### Rent and Space

```rust
// Rent exemption: pay ~2 years of rent upfront = account lives forever
let rent = Rent::get()?;
let minimum_balance = rent.minimum_balance(space);

// Space calculation:
// 8 bytes (Anchor discriminator) +
// Your account fields

#[account]
#[derive(InitSpace)]
pub struct MyAccount {
    pub authority: Pubkey,    // 32 bytes
    pub data: u64,            // 8 bytes
    pub bump: u8,             // 1 byte
    #[max_len(100)]
    pub name: String,         // 4 + 100 bytes (length prefix + max chars)
}
// Total: 8 + 32 + 8 + 1 + 104 = 153 bytes
```

---

## Account Constraints in Depth

### Initialization Constraints

```rust
#[account(
    init,                              // Create account
    init_if_needed,                    // Create only if doesn't exist
    payer = someone,                   // Who pays rent
    space = 100,                       // Bytes to allocate
    seeds = [...],                     // PDA seeds
    bump,                              // Auto-find bump
    owner = other_program,             // Set different owner
)]
```

### Validation Constraints

```rust
#[account(
    mut,                               // Writable
    seeds = [...],                     // Validate PDA
    bump = account.bump,               // Use stored bump
    has_one = authority,               // account.authority == authority.key()
    has_one = mint @ ErrorCode::WrongMint,  // With custom error
    constraint = account.is_active,    // Boolean expression
    constraint = amount > 0 @ ErrorCode::InvalidAmount,
)]
```

### Closing Accounts

```rust
#[account(
    mut,
    close = destination,               // Close and send rent to destination
)]
pub account: Account<'info, MyAccount>,

#[account(mut)]
pub destination: SystemAccount<'info>,
```

---

## Account Types in Anchor

### Account\<T\>

```rust
// Deserializes and validates account data
pub my_account: Account<'info, MyAccount>,

// Checks:
// - Account is owned by your program
// - Data deserializes correctly
// - Discriminator matches
```

### UncheckedAccount

```rust
// No validation - use carefully!
/// CHECK: This account is validated manually
pub unchecked: UncheckedAccount<'info>,

// Always add CHECK comment explaining why it's safe
```

### Signer

```rust
// Must sign the transaction
pub authority: Signer<'info>,

// Checks:
// - is_signer == true
```

### SystemAccount

```rust
// Owned by System Program (a wallet)
pub user: SystemAccount<'info>,

// Checks:
// - owner == System Program
```

### Program

```rust
// A program account
pub token_program: Program<'info, Token>,

// Checks:
// - Is executable
// - Matches expected program ID
```

---

## Advanced PDA Patterns

### Cross-Program Account Validation

```rust
#[derive(Accounts)]
pub struct ValidateCrossProgram<'info> {
    // Validate a token account owned by Token Program
    #[account(
        token::mint = mint,
        token::authority = authority,
    )]
    pub token_account: Account<'info, TokenAccount>,

    pub mint: Account<'info, Mint>,
    pub authority: Signer<'info>,
}
```

### PDA Authority Pattern

```rust
// PDA acts as authority over a token account
#[derive(Accounts)]
pub struct PdaAuthority<'info> {
    #[account(
        seeds = [b"vault-authority"],
        bump
    )]
    /// CHECK: PDA used as authority
    pub vault_authority: UncheckedAccount<'info>,

    #[account(
        mut,
        token::mint = mint,
        token::authority = vault_authority,  // PDA is the authority!
    )]
    pub vault: Account<'info, TokenAccount>,

    pub mint: Account<'info, Mint>,
}

// Transfer from vault (signed by PDA)
pub fn withdraw(ctx: Context<PdaAuthority>, amount: u64) -> Result<()> {
    let seeds = &[
        b"vault-authority",
        &[ctx.bumps.vault_authority],
    ];
    let signer_seeds = &[&seeds[..]];

    token::transfer(
        CpiContext::new_with_signer(
            ctx.accounts.token_program.to_account_info(),
            Transfer {
                from: ctx.accounts.vault.to_account_info(),
                to: ctx.accounts.destination.to_account_info(),
                authority: ctx.accounts.vault_authority.to_account_info(),
            },
            signer_seeds,
        ),
        amount,
    )?;

    Ok(())
}
```

### Multi-Level PDAs

```rust
// PDA derived from another PDA
#[derive(Accounts)]
pub struct NestedPda<'info> {
    // First level: User account
    #[account(
        seeds = [b"user", user.key().as_ref()],
        bump
    )]
    pub user_account: Account<'info, UserAccount>,

    // Second level: User's item
    #[account(
        seeds = [b"item", user_account.key().as_ref(), &item_id.to_le_bytes()],
        bump
    )]
    pub item_account: Account<'info, ItemAccount>,

    pub user: Signer<'info>,
}
```

---

## Common Pitfalls

### Pitfall 1: Reinitialization Attack

```rust
// VULNERABLE: No check if already initialized
#[account(init, ...)]
pub account: Account<'info, MyAccount>,

// SAFE: Use init_if_needed with caution, or check manually
#[account(
    init,
    constraint = !account.is_initialized @ ErrorCode::AlreadyInitialized,
)]
```

### Pitfall 2: Missing Signer Check

```rust
// VULNERABLE: Anyone can call
#[derive(Accounts)]
pub struct Withdraw<'info> {
    #[account(mut)]
    pub vault: Account<'info, Vault>,
}

// SAFE: Require authority signature
#[derive(Accounts)]
pub struct Withdraw<'info> {
    #[account(mut, has_one = authority)]
    pub vault: Account<'info, Vault>,
    pub authority: Signer<'info>,
}
```

### Pitfall 3: Account Confusion

```rust
// VULNERABLE: No check that accounts are for the right program
pub fn process(ctx: Context<Process>) -> Result<()> {
    // Attacker could pass fake accounts!
}

// SAFE: Anchor validates automatically via Account<'info, T>
// T includes discriminator that proves it's the right type
```

### Pitfall 4: Bump Seed Mismatch

```rust
// VULNERABLE: Using wrong bump allows PDA spoofing
#[account(
    seeds = [b"config"],
    bump,  // Recalculates bump each time - wasteful
)]

// SAFE: Store and use canonical bump
#[account(
    seeds = [b"config"],
    bump = config.bump,  // Uses stored bump
)]
```

---

## Exercises

### Exercise 1: Create a User Profile System

Create a program where each user can have a profile with:
- Name (max 50 chars)
- Bio (max 200 chars)
- Created timestamp

<details>
<summary>Solution</summary>

```rust
#[program]
pub mod profiles {
    use super::*;

    pub fn create_profile(
        ctx: Context<CreateProfile>,
        name: String,
        bio: String,
    ) -> Result<()> {
        require!(name.len() <= 50, ErrorCode::NameTooLong);
        require!(bio.len() <= 200, ErrorCode::BioTooLong);

        let profile = &mut ctx.accounts.profile;
        let clock = Clock::get()?;

        profile.owner = ctx.accounts.user.key();
        profile.name = name;
        profile.bio = bio;
        profile.created_at = clock.unix_timestamp;
        profile.bump = ctx.bumps.profile;

        Ok(())
    }
}

#[account]
#[derive(InitSpace)]
pub struct Profile {
    pub owner: Pubkey,
    #[max_len(50)]
    pub name: String,
    #[max_len(200)]
    pub bio: String,
    pub created_at: i64,
    pub bump: u8,
}

#[derive(Accounts)]
pub struct CreateProfile<'info> {
    #[account(
        init,
        payer = user,
        space = 8 + Profile::INIT_SPACE,
        seeds = [b"profile", user.key().as_ref()],
        bump
    )]
    pub profile: Account<'info, Profile>,

    #[account(mut)]
    pub user: Signer<'info>,

    pub system_program: Program<'info, System>,
}

#[error_code]
pub enum ErrorCode {
    #[msg("Name exceeds 50 characters")]
    NameTooLong,
    #[msg("Bio exceeds 200 characters")]
    BioTooLong,
}
```
</details>

---

## Key Takeaways

1. **Accounts are owned by programs** â€” only owners can modify data
2. **PDAs are deterministic** â€” same seeds always give same address
3. **Store the bump** â€” saves computation on subsequent calls
4. **Use Anchor constraints** â€” they prevent common vulnerabilities
5. **Check ownership and signatures** â€” critical for security
6. **Rent exemption is standard** â€” always pay for permanent accounts

---

## Next

Learn how programs can call other programs.

â†’ [4.4 Cross-Program Invocations (CPIs)](./4.4-cross-program-invocations.md)
