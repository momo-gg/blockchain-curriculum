# 4.6 NFTs & Metaplex

---

## Why This Matters

Non-Fungible Tokens (NFTs) have become a major use case for blockchains. Solanaâ€™s low fees and fast confirmations can make NFT applications practical (varies; as of [Solana Beach](https://solanabeach.io)). Understanding how NFTs work on Solana, particularly through Metaplex, is essential for building NFT-related products.

---

## ğŸŸ¢ General Understanding

### What Makes an NFT?

```
FUNGIBLE TOKEN (Example):
  - Supply: Many
  - Decimals: Varies
  - Every token is identical
  - 1 USDC = 1 USDC always

NON-FUNGIBLE TOKEN:
  - Supply: 1
  - Decimals: 0
  - Each token is unique
  - Metadata describes what it represents
```

### NFT Anatomy on Solana

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         NFT Structure                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                      â”‚
â”‚   MINT ACCOUNT                METADATA ACCOUNT                      â”‚
â”‚   (SPL Token)                 (Metaplex)                            â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚
â”‚   â”‚ Supply: 1   â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚ Name: "Example NFT" â”‚               â”‚
â”‚   â”‚ Decimals: 0 â”‚             â”‚ Symbol: "CAPE"      â”‚               â”‚
â”‚   â”‚ Authority:  â”‚             â”‚ URI: "https://..."  â”‚               â”‚
â”‚   â”‚   (frozen)  â”‚             â”‚ Creators: [...]     â”‚               â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚ Collection: Pubkey  â”‚               â”‚
â”‚         â”‚                     â”‚ Uses: (optional)    â”‚               â”‚
â”‚         â”‚                     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚
â”‚         â–¼                                                           â”‚
â”‚   TOKEN ACCOUNT               MASTER EDITION                        â”‚
â”‚   (Who owns it)               (Proof of uniqueness)                 â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚
â”‚   â”‚ Owner: Aliceâ”‚             â”‚ MaxSupply: 0        â”‚               â”‚
â”‚   â”‚ Amount: 1   â”‚             â”‚ (No prints allowed) â”‚               â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚
â”‚                                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Metaplex: The NFT Standard

Metaplex provides the standard for NFT metadata on Solana:

| Component | Purpose |
|-----------|---------|
| Token Metadata Program | Stores on-chain metadata (name, symbol, URI) |
| Candy Machine | Minting infrastructure for collections |
| Auction House | Trading and marketplace protocols |
| Bubblegum | Compressed NFTs (cheaper at scale) |

---

## ğŸŸ¡ PM/EM Depth

### Metadata Structure

```json
{
  "name": "Cool Ape #42",
  "symbol": "CAPE",
  "description": "A unique digital collectible",
  "image": "https://arweave.net/abc123",
  "attributes": [
    { "trait_type": "Background", "value": "Blue" },
    { "trait_type": "Fur", "value": "Golden" },
    { "trait_type": "Eyes", "value": "Laser" }
  ],
  "properties": {
    "files": [
      { "uri": "https://arweave.net/abc123", "type": "image/png" }
    ],
    "category": "image",
    "creators": [
      { "address": "...", "share": 100 }
    ]
  }
}
```

### On-Chain vs Off-Chain

```
ON-CHAIN (Metaplex Metadata Account):
  - Name (max 32 chars)
  - Symbol (max 10 chars)
  - URI pointing to off-chain data
  - Creators array with royalty shares
  - Collection verification
  - Seller fee basis points (royalties)

OFF-CHAIN (Arweave/IPFS):
  - Full description
  - Image file
  - Attributes/traits
  - Animation files
  - Additional properties
```

### Collection Verification

```
VERIFIED COLLECTION:
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ Collection NFT      â”‚ â† Master NFT representing the collection
  â”‚ Name: "Cool Apes"   â”‚
  â”‚ Verified: true      â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚
          â”‚ (on-chain link)
          â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ Item NFT #42        â”‚
  â”‚ Collection: âœ“       â”‚ â† Verified as belonging to collection
  â”‚ Parent: Cool Apes   â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Benefits:
  - Prevents counterfeits
  - Marketplaces can filter
  - Proves authenticity
```

### Royalties

```
Creator royalties on secondary sales:

Primary Sale:
  Buyer pays SOL
  Creator receives proceeds (subject to market rules)

Secondary Sale:
  Seller lists for SOL
  Buyer pays SOL
  â”œâ”€â”€ Creator receives royalty (if enforced by marketplace)
  â””â”€â”€ Seller receives the remainder

Note: Royalties are increasingly opt-in on many marketplaces
```

---

## ğŸ”µ Engineer Depth

### Creating an NFT with Metaplex

```rust
use anchor_lang::prelude::*;
use anchor_spl::{
    associated_token::AssociatedToken,
    token::{Mint, Token, TokenAccount},
};
use mpl_token_metadata::{
    instruction::{create_master_edition_v3, create_metadata_accounts_v3},
    state::{Creator, DataV2},
    ID as METADATA_PROGRAM_ID,
};

#[derive(Accounts)]
pub struct CreateNft<'info> {
    #[account(
        init,
        payer = payer,
        mint::decimals = 0,
        mint::authority = payer,
        mint::freeze_authority = payer,
    )]
    pub mint: Account<'info, Mint>,

    #[account(
        init,
        payer = payer,
        associated_token::mint = mint,
        associated_token::authority = payer,
    )]
    pub token_account: Account<'info, TokenAccount>,

    /// CHECK: Metaplex metadata account (PDA)
    #[account(mut)]
    pub metadata: UncheckedAccount<'info>,

    /// CHECK: Metaplex master edition account (PDA)
    #[account(mut)]
    pub master_edition: UncheckedAccount<'info>,

    #[account(mut)]
    pub payer: Signer<'info>,

    pub system_program: Program<'info, System>,
    pub token_program: Program<'info, Token>,
    pub associated_token_program: Program<'info, AssociatedToken>,
    pub rent: Sysvar<'info, Rent>,

    /// CHECK: Metaplex Token Metadata Program
    #[account(address = METADATA_PROGRAM_ID)]
    pub token_metadata_program: UncheckedAccount<'info>,
}

pub fn create_nft(
    ctx: Context<CreateNft>,
    name: String,
    symbol: String,
    uri: String,
) -> Result<()> {
    // 1. Mint one token
    anchor_spl::token::mint_to(
        CpiContext::new(
            ctx.accounts.token_program.to_account_info(),
            anchor_spl::token::MintTo {
                mint: ctx.accounts.mint.to_account_info(),
                to: ctx.accounts.token_account.to_account_info(),
                authority: ctx.accounts.payer.to_account_info(),
            },
        ),
        1, // Exactly 1 for NFT
    )?;

    // 2. Create metadata account
    let creators = vec![Creator {
        address: ctx.accounts.payer.key(),
        verified: true,
        share: 100,
    }];

    let data = DataV2 {
        name,
        symbol,
        uri,
        seller_fee_basis_points: 500, // 5% royalty
        creators: Some(creators),
        collection: None,
        uses: None,
    };

    let accounts = vec![
        ctx.accounts.metadata.to_account_info(),
        ctx.accounts.mint.to_account_info(),
        ctx.accounts.payer.to_account_info(), // mint authority
        ctx.accounts.payer.to_account_info(), // payer
        ctx.accounts.payer.to_account_info(), // update authority
        ctx.accounts.system_program.to_account_info(),
        ctx.accounts.rent.to_account_info(),
    ];

    let ix = create_metadata_accounts_v3(
        METADATA_PROGRAM_ID,
        ctx.accounts.metadata.key(),
        ctx.accounts.mint.key(),
        ctx.accounts.payer.key(),
        ctx.accounts.payer.key(),
        ctx.accounts.payer.key(),
        data.name,
        data.symbol,
        data.uri,
        data.creators,
        data.seller_fee_basis_points,
        true,  // update authority is signer
        true,  // is mutable
        None,  // collection
        None,  // uses
        None,  // collection details
    );

    anchor_lang::solana_program::program::invoke(&ix, &accounts)?;

    // 3. Create master edition (proves uniqueness)
    let edition_accounts = vec![
        ctx.accounts.master_edition.to_account_info(),
        ctx.accounts.mint.to_account_info(),
        ctx.accounts.payer.to_account_info(), // update authority
        ctx.accounts.payer.to_account_info(), // mint authority
        ctx.accounts.payer.to_account_info(), // payer
        ctx.accounts.metadata.to_account_info(),
        ctx.accounts.token_program.to_account_info(),
        ctx.accounts.system_program.to_account_info(),
        ctx.accounts.rent.to_account_info(),
    ];

    let edition_ix = create_master_edition_v3(
        METADATA_PROGRAM_ID,
        ctx.accounts.master_edition.key(),
        ctx.accounts.mint.key(),
        ctx.accounts.payer.key(),
        ctx.accounts.payer.key(),
        ctx.accounts.metadata.key(),
        ctx.accounts.payer.key(),
        Some(0), // max_supply = 0 means no prints allowed
    );

    anchor_lang::solana_program::program::invoke(&edition_ix, &edition_accounts)?;

    msg!("NFT created: {}", ctx.accounts.mint.key());
    Ok(())
}
```

### Using Metaplex Umi SDK (Recommended)

> âš ï¸ **Note**: The older `@metaplex-foundation/js` SDK is deprecated. Use `@metaplex-foundation/umi` for new projects.

```typescript
import { createUmi } from "@metaplex-foundation/umi-bundle-defaults";
import {
  createNft,
  mplTokenMetadata
} from "@metaplex-foundation/mpl-token-metadata";
import {
  generateSigner,
  percentAmount,
  keypairIdentity
} from "@metaplex-foundation/umi";
import { irysUploader } from "@metaplex-foundation/umi-uploader-irys";

async function createNftWithUmi() {
  // Initialize Umi
  const umi = createUmi("https://api.devnet.solana.com")
    .use(mplTokenMetadata())
    .use(irysUploader());

  // Add your keypair identity
  const keypair = umi.eddsa.createKeypairFromSecretKey(secretKey);
  umi.use(keypairIdentity(keypair));

  // Upload metadata to Irys (formerly Bundlr)
  const uri = await umi.uploader.uploadJson({
    name: "My NFT",
    description: "An awesome NFT",
    image: "https://example.com/image.png",
    attributes: [
      { trait_type: "Background", value: "Blue" },
      { trait_type: "Rarity", value: "Legendary" },
    ],
  });

  // Create the NFT
  const mint = generateSigner(umi);
  await createNft(umi, {
    mint,
    name: "My NFT",
    symbol: "MNFT",
    uri,
    sellerFeeBasisPoints: percentAmount(5), // 5% royalty
    creators: [{ address: umi.identity.publicKey, verified: true, share: 100 }],
  }).sendAndConfirm(umi);

  console.log("NFT created:", mint.publicKey);
  console.log("Metadata URI:", uri);
}
```

### Candy Machine for Collections (Umi)

```typescript
import { createUmi } from "@metaplex-foundation/umi-bundle-defaults";
import {
  create,
  addConfigLines,
  mintV2,
  mplCandyMachine,
} from "@metaplex-foundation/mpl-candy-machine";
import {
  generateSigner,
  some,
  sol,
  dateTime
} from "@metaplex-foundation/umi";

async function createCandyMachineWithUmi() {
  const umi = createUmi("https://api.devnet.solana.com")
    .use(mplCandyMachine());

  const candyMachine = generateSigner(umi);
  const collection = generateSigner(umi);

  // Create Candy Machine
  await create(umi, {
    candyMachine,
    collection: collection.publicKey,
    collectionUpdateAuthority: umi.identity,
    itemsAvailable: 10000,
    sellerFeeBasisPoints: percentAmount(5),
    symbol: "COLL",
    maxEditionSupply: 0,
    isMutable: true,
    creators: [
      { address: umi.identity.publicKey, verified: true, share: 100 }
    ],
    guards: {
      botTax: some({ lamports: sol(0.01), lastInstruction: true }),
      solPayment: some({ lamports: sol(1), destination: treasury }),
      startDate: some({ date: dateTime("2024-01-01T00:00:00Z") }),
      mintLimit: some({ id: 1, limit: 3 }),
    },
  }).sendAndConfirm(umi);

  // Add items to Candy Machine
  await addConfigLines(umi, {
    candyMachine: candyMachine.publicKey,
    index: 0,
    configLines: [
      { name: "NFT #1", uri: "https://..." },
      { name: "NFT #2", uri: "https://..." },
    ],
  }).sendAndConfirm(umi);

  console.log("Candy Machine:", candyMachine.publicKey);
}

// Minting from Candy Machine
async function mintFromCandyMachine(candyMachinePublicKey: PublicKey) {
  const nftMint = generateSigner(umi);

  await mintV2(umi, {
    candyMachine: candyMachinePublicKey,
    nftMint,
    collectionMint: collectionPublicKey,
    collectionUpdateAuthority: umi.identity.publicKey,
  }).sendAndConfirm(umi);

  console.log("Minted NFT:", nftMint.publicKey);
}
```

### Compressed NFTs (cNFTs)

For large collections, compressed NFTs are much cheaper:

```
REGULAR NFT:
  Cost depends on account rent parameters and current network fees

COMPRESSED NFT:
  Cost depends on compression configuration and current network fees

How it works:
  - Uses Merkle trees for storage
  - Only tree root is on-chain
  - Individual NFTs proven via proofs
  - Same functionality, 99% cheaper
```

```typescript
import { createTree, mintV1, mplBubblegum } from "@metaplex-foundation/mpl-bubblegum";

async function createCompressedNftCollection() {
  // Create Merkle tree
  const merkleTree = generateSigner(umi);
  await createTree(umi, {
    merkleTree,
    maxDepth: 14,      // 2^14 = 16,384 max NFTs
    maxBufferSize: 64,
  }).sendAndConfirm(umi);

  // Mint compressed NFT
  await mintV1(umi, {
    leafOwner: owner.publicKey,
    merkleTree: merkleTree.publicKey,
    metadata: {
      name: "Compressed NFT #1",
      uri: "https://example.com/metadata.json",
      sellerFeeBasisPoints: 500,
      collection: { key: collectionMint, verified: false },
      creators: [{ address: creator.publicKey, verified: true, share: 100 }],
    },
  }).sendAndConfirm(umi);
}
```

---

## NFT Transfer and Burning

### Transfer NFT

```rust
use anchor_spl::token::{self, Transfer};

pub fn transfer_nft(ctx: Context<TransferNft>) -> Result<()> {
    // NFT transfer is just a token transfer of amount 1
    token::transfer(
        CpiContext::new(
            ctx.accounts.token_program.to_account_info(),
            Transfer {
                from: ctx.accounts.from_ata.to_account_info(),
                to: ctx.accounts.to_ata.to_account_info(),
                authority: ctx.accounts.owner.to_account_info(),
            },
        ),
        1, // Always 1 for NFT
    )?;

    Ok(())
}
```

### Burn NFT

```rust
use anchor_spl::token::{self, Burn, CloseAccount};

pub fn burn_nft(ctx: Context<BurnNft>) -> Result<()> {
    // 1. Burn the token
    token::burn(
        CpiContext::new(
            ctx.accounts.token_program.to_account_info(),
            Burn {
                mint: ctx.accounts.mint.to_account_info(),
                from: ctx.accounts.token_account.to_account_info(),
                authority: ctx.accounts.owner.to_account_info(),
            },
        ),
        1,
    )?;

    // 2. Close the token account (get rent back)
    token::close_account(
        CpiContext::new(
            ctx.accounts.token_program.to_account_info(),
            CloseAccount {
                account: ctx.accounts.token_account.to_account_info(),
                destination: ctx.accounts.owner.to_account_info(),
                authority: ctx.accounts.owner.to_account_info(),
            },
        ),
    )?;

    msg!("NFT burned");
    Ok(())
}
```

---

## Common NFT Patterns

### Pattern 1: Membership/Access NFT

```rust
pub fn verify_membership(ctx: Context<VerifyMembership>) -> Result<()> {
    let token_account = &ctx.accounts.membership_token;

    // Check user owns exactly 1 membership NFT
    require!(
        token_account.amount == 1,
        ErrorCode::NotAMember
    );

    // Check it's the right collection
    require!(
        token_account.mint == MEMBERSHIP_COLLECTION_MINT,
        ErrorCode::WrongCollection
    );

    // User has access!
    msg!("Membership verified");
    Ok(())
}
```

### Pattern 2: NFT Staking

```rust
pub fn stake_nft(ctx: Context<StakeNft>) -> Result<()> {
    // Transfer NFT to staking vault
    token::transfer(
        CpiContext::new(
            ctx.accounts.token_program.to_account_info(),
            Transfer {
                from: ctx.accounts.user_nft.to_account_info(),
                to: ctx.accounts.vault_nft.to_account_info(),
                authority: ctx.accounts.user.to_account_info(),
            },
        ),
        1,
    )?;

    // Record stake info
    let stake = &mut ctx.accounts.stake_account;
    stake.owner = ctx.accounts.user.key();
    stake.nft_mint = ctx.accounts.nft_mint.key();
    stake.staked_at = Clock::get()?.unix_timestamp;

    Ok(())
}

pub fn unstake_nft(ctx: Context<UnstakeNft>) -> Result<()> {
    // Calculate rewards
    let stake = &ctx.accounts.stake_account;
    let now = Clock::get()?.unix_timestamp;
    let duration = now - stake.staked_at;
    let rewards = calculate_rewards(duration);

    // Return NFT to user (PDA signs)
    let seeds = &[b"vault", &[ctx.bumps.vault_authority]];
    token::transfer(
        CpiContext::new_with_signer(
            ctx.accounts.token_program.to_account_info(),
            Transfer {
                from: ctx.accounts.vault_nft.to_account_info(),
                to: ctx.accounts.user_nft.to_account_info(),
                authority: ctx.accounts.vault_authority.to_account_info(),
            },
            &[seeds],
        ),
        1,
    )?;

    // Pay rewards...

    Ok(())
}
```

---

## Key Takeaways

1. **NFT = SPL Token** with supply 1 and 0 decimals
2. **Metaplex adds metadata** â€” name, image, attributes
3. **Master Edition** proves uniqueness and controls prints
4. **Collection verification** prevents counterfeits
5. **Royalties are optional** â€” increasingly opt-in on marketplaces
6. **Compressed NFTs** are 99% cheaper for large collections
7. **Same token operations** â€” transfer, burn work identically

---

## Next

Learn about Token Extensions (Token-2022) â€” the next generation of tokens on Solana.

â†’ [4.7 Token Extensions (Token-2022)](./4.7-token-extensions.md)
