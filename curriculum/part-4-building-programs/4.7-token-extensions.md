# 4.7 Token Extensions (Token-2022)

> *"Token-2022 adds features the original token program couldn't have â€” transfer fees, confidential transfers, and more."*

---

## Why This Matters

The original SPL Token program is immutable â€” once deployed, it can't be changed. As the ecosystem evolved, new requirements emerged: on-chain royalties, transfer hooks, confidential amounts. Token-2022 (also called Token Extensions) was built to address these needs while remaining compatible with the original.

---

## ğŸŸ¢ General Understanding

### What Is Token-2022?

Token-2022 is a new token program with optional extensions:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              SPL Token vs Token-2022                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                      â”‚
â”‚   ORIGINAL SPL TOKEN              TOKEN-2022                        â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚ Basic features  â”‚             â”‚ Basic features              â”‚   â”‚
â”‚   â”‚ - Mint          â”‚             â”‚ - Mint                      â”‚   â”‚
â”‚   â”‚ - Transfer      â”‚             â”‚ - Transfer                  â”‚   â”‚
â”‚   â”‚ - Burn          â”‚             â”‚ - Burn                      â”‚   â”‚
â”‚   â”‚ - Delegate      â”‚             â”‚ - Delegate                  â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚                             â”‚   â”‚
â”‚                                   â”‚ PLUS EXTENSIONS:            â”‚   â”‚
â”‚                                   â”‚ - Transfer fees             â”‚   â”‚
â”‚                                   â”‚ - Permanent delegate        â”‚   â”‚
â”‚                                   â”‚ - Non-transferable          â”‚   â”‚
â”‚                                   â”‚ - Confidential transfers    â”‚   â”‚
â”‚                                   â”‚ - Transfer hooks            â”‚   â”‚
â”‚                                   â”‚ - Metadata on-chain         â”‚   â”‚
â”‚                                   â”‚ - Interest-bearing          â”‚   â”‚
â”‚                                   â”‚ - And more...               â”‚   â”‚
â”‚                                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Key Extensions

| Extension | Purpose | Use Case |
|-----------|---------|----------|
| **Transfer Fee** | Charge fee on each transfer | On-chain royalties, protocol fees |
| **Permanent Delegate** | Authority that can always transfer | Stablecoins (freeze/seize), subscriptions |
| **Non-Transferable** | Tokens that can't be moved | Soulbound tokens, achievements |
| **Confidential Transfer** | Hide amounts (ZK proofs) | Privacy for payments |
| **Transfer Hook** | Run custom code on transfer | KYC checks, custom logic |
| **Metadata** | Store metadata on-chain | No need for Metaplex for basic use |
| **Interest-Bearing** | Display interest accrual | Savings accounts, yield tokens |
| **Default Account State** | New accounts start frozen | Compliance, KYC first |
| **Immutable Owner** | Owner can never change | Permanence for certain accounts |

---

## ğŸŸ¡ PM/EM Depth

### Extension Compatibility

```
MINT-LEVEL EXTENSIONS:
  Applied when mint is created
  Affect all token accounts
  Examples:
    - Transfer Fee
    - Interest-Bearing
    - Close Authority
    - Permanent Delegate
    - Transfer Hook

ACCOUNT-LEVEL EXTENSIONS:
  Applied to individual token accounts
  Examples:
    - Confidential Transfer
    - Immutable Owner
    - Memo Required
```

### When to Use Token-2022

| Use Case | Extension | Why |
|----------|-----------|-----|
| NFT royalties | Transfer Fee | Enforce royalties on-chain |
| Stablecoin compliance | Permanent Delegate + Default Frozen | KYC/AML requirements |
| Privacy tokens | Confidential Transfer | Hide transaction amounts |
| Achievement badges | Non-Transferable | Soulbound credentials |
| Custom trading rules | Transfer Hook | Validate each transfer |
| RWA tokens | Transfer Hook + Metadata | Real-world asset compliance |

### Adoption Considerations

```
ADVANTAGES:
  âœ… Native features (no custom programs)
  âœ… Audited, maintained by the Solana ecosystem
  âœ… Ecosystem support growing
  âœ… Lower complexity for common patterns

CONSIDERATIONS:
  âš ï¸ Not all wallets/dApps support yet
  âš ï¸ Larger account sizes (more rent)
  âš ï¸ Some extensions increase compute cost
  âš ï¸ Need to check compatibility
```

---

## ğŸ”µ Engineer Depth

### Creating Token-2022 Mint with Extensions

```rust
use anchor_lang::prelude::*;
use anchor_spl::token_2022::{
    Token2022,
    spl_token_2022::{
        extension::{
            transfer_fee::TransferFeeConfig,
            ExtensionType,
        },
        instruction::initialize_mint2,
        state::Mint,
    },
};

pub fn create_token_with_transfer_fee(
    ctx: Context<CreateToken>,
    decimals: u8,
    transfer_fee_basis_points: u16,  // e.g., 100 = 1%
    max_fee: u64,
) -> Result<()> {
    let mint = &ctx.accounts.mint;

    // Calculate space needed for extensions
    let extension_types = &[ExtensionType::TransferFeeConfig];
    let space = ExtensionType::try_calculate_account_len::<Mint>(extension_types)?;

    // Create account with extra space for extension
    let rent = Rent::get()?;
    let lamports = rent.minimum_balance(space);

    anchor_lang::solana_program::program::invoke(
        &anchor_lang::solana_program::system_instruction::create_account(
            ctx.accounts.payer.key,
            mint.key,
            lamports,
            space as u64,
            &anchor_spl::token_2022::ID,
        ),
        &[
            ctx.accounts.payer.to_account_info(),
            mint.to_account_info(),
        ],
    )?;

    // Initialize transfer fee extension
    let ix = spl_token_2022::extension::transfer_fee::instruction::initialize_transfer_fee_config(
        &anchor_spl::token_2022::ID,
        mint.key,
        Some(&ctx.accounts.fee_authority.key()),  // Can update fee
        Some(&ctx.accounts.fee_authority.key()),  // Can withdraw fees
        transfer_fee_basis_points,
        max_fee,
    )?;

    anchor_lang::solana_program::program::invoke(
        &ix,
        &[mint.to_account_info()],
    )?;

    // Initialize mint
    let init_ix = initialize_mint2(
        &anchor_spl::token_2022::ID,
        mint.key,
        ctx.accounts.mint_authority.key,
        Some(ctx.accounts.freeze_authority.key),
        decimals,
    )?;

    anchor_lang::solana_program::program::invoke(
        &init_ix,
        &[mint.to_account_info()],
    )?;

    msg!("Token-2022 mint created with {}% transfer fee",
         transfer_fee_basis_points as f64 / 100.0);
    Ok(())
}
```

### Transfer Fee in Action

```rust
// When transferring, fees are automatically withheld
pub fn transfer_with_fee(ctx: Context<TransferWithFee>, amount: u64) -> Result<()> {
    // User sends 1000 tokens
    // If fee is 1%, recipient gets 990, 10 withheld

    anchor_spl::token_2022::transfer_checked(
        CpiContext::new(
            ctx.accounts.token_program.to_account_info(),
            anchor_spl::token_2022::TransferChecked {
                from: ctx.accounts.from.to_account_info(),
                mint: ctx.accounts.mint.to_account_info(),
                to: ctx.accounts.to.to_account_info(),
                authority: ctx.accounts.authority.to_account_info(),
            },
        ),
        amount,
        ctx.accounts.mint.decimals,
    )?;

    // Fees accumulate in recipient account's "withheld" field
    // Authority can later harvest these fees

    Ok(())
}

// Harvesting fees
pub fn harvest_fees(ctx: Context<HarvestFees>) -> Result<()> {
    spl_token_2022::extension::transfer_fee::instruction::harvest_withheld_tokens_to_mint(
        &anchor_spl::token_2022::ID,
        ctx.accounts.mint.key,
        &[ctx.accounts.token_account.key],
    );

    // Later, withdraw from mint to fee collector
    spl_token_2022::extension::transfer_fee::instruction::withdraw_withheld_tokens_from_mint(
        &anchor_spl::token_2022::ID,
        ctx.accounts.mint.key,
        ctx.accounts.fee_collector.key,
        ctx.accounts.withdraw_authority.key,
        &[],
    );

    Ok(())
}
```

### Transfer Hook Extension

Transfer hooks let you run custom logic on every transfer:

```rust
// Your Transfer Hook Program
use anchor_lang::prelude::*;
use spl_transfer_hook_interface::instruction::ExecuteInstruction;

declare_id!("Hook11111111111111111111111111111111111111");

#[program]
pub mod transfer_hook {
    use super::*;

    // This is called automatically on every transfer
    pub fn execute(
        ctx: Context<Execute>,
        amount: u64,
    ) -> Result<()> {
        // Custom validation logic
        let from = &ctx.accounts.source;
        let to = &ctx.accounts.destination;

        // Example: Check KYC status
        require!(
            is_kyc_verified(from.owner),
            ErrorCode::SenderNotKycVerified
        );
        require!(
            is_kyc_verified(to.owner),
            ErrorCode::RecipientNotKycVerified
        );

        // Example: Check transfer limits
        require!(
            amount <= MAX_TRANSFER_AMOUNT,
            ErrorCode::TransferTooLarge
        );

        // Example: Log for compliance
        msg!("Transfer {} from {} to {}",
             amount, from.owner, to.owner);

        Ok(())
    }
}

#[derive(Accounts)]
pub struct Execute<'info> {
    #[account()]
    pub source: InterfaceAccount<'info, TokenAccount>,
    #[account()]
    pub mint: InterfaceAccount<'info, Mint>,
    #[account()]
    pub destination: InterfaceAccount<'info, TokenAccount>,
    pub owner: Signer<'info>,
    /// CHECK: Extra account for hook logic
    pub extra_account: UncheckedAccount<'info>,
}
```

### Creating Token with Transfer Hook

```rust
use spl_token_2022::extension::transfer_hook;

pub fn create_token_with_hook(ctx: Context<CreateHookToken>) -> Result<()> {
    let mint = &ctx.accounts.mint;
    let hook_program = ctx.accounts.hook_program.key();

    // Calculate space
    let extension_types = &[ExtensionType::TransferHook];
    let space = ExtensionType::try_calculate_account_len::<Mint>(extension_types)?;

    // Create and initialize (similar to above)...

    // Initialize transfer hook extension
    let ix = transfer_hook::instruction::initialize(
        &anchor_spl::token_2022::ID,
        mint.key,
        Some(ctx.accounts.hook_authority.key()),
        Some(hook_program),  // Your hook program
    )?;

    anchor_lang::solana_program::program::invoke(
        &ix,
        &[mint.to_account_info()],
    )?;

    Ok(())
}
```

### Non-Transferable (Soulbound) Tokens

```rust
use spl_token_2022::extension::non_transferable;

pub fn create_soulbound_token(ctx: Context<CreateSoulbound>) -> Result<()> {
    let extension_types = &[ExtensionType::NonTransferable];
    let space = ExtensionType::try_calculate_account_len::<Mint>(extension_types)?;

    // Create account...

    // Initialize non-transferable extension
    let ix = non_transferable::instruction::initialize(
        &anchor_spl::token_2022::ID,
        ctx.accounts.mint.key,
    )?;

    anchor_lang::solana_program::program::invoke(
        &ix,
        &[ctx.accounts.mint.to_account_info()],
    )?;

    // This token can never be transferred
    // Only minted directly to holder, burned, or closed

    Ok(())
}
```

### Metadata Extension

```rust
use spl_token_2022::extension::metadata_pointer;
use spl_token_metadata_interface::state::TokenMetadata;

pub fn create_token_with_metadata(
    ctx: Context<CreateWithMetadata>,
    name: String,
    symbol: String,
    uri: String,
) -> Result<()> {
    let extension_types = &[
        ExtensionType::MetadataPointer,
    ];
    let space = ExtensionType::try_calculate_account_len::<Mint>(extension_types)?;

    // Create account...

    // Initialize metadata pointer
    let ix = metadata_pointer::instruction::initialize(
        &anchor_spl::token_2022::ID,
        ctx.accounts.mint.key,
        Some(ctx.accounts.update_authority.key()),
        Some(ctx.accounts.mint.key()),  // Metadata stored on mint itself
    )?;

    anchor_lang::solana_program::program::invoke(
        &ix,
        &[ctx.accounts.mint.to_account_info()],
    )?;

    // Initialize metadata
    let metadata_ix = spl_token_metadata_interface::instruction::initialize(
        &anchor_spl::token_2022::ID,
        ctx.accounts.mint.key,
        ctx.accounts.update_authority.key,
        ctx.accounts.mint.key,
        ctx.accounts.update_authority.key,
        name,
        symbol,
        uri,
    );

    anchor_lang::solana_program::program::invoke(
        &metadata_ix,
        &[
            ctx.accounts.mint.to_account_info(),
            ctx.accounts.update_authority.to_account_info(),
        ],
    )?;

    Ok(())
}
```

### Interest-Bearing Tokens

```rust
use spl_token_2022::extension::interest_bearing_mint;

pub fn create_interest_bearing_token(
    ctx: Context<CreateInterestBearing>,
    rate_basis_points: i16,  // e.g., 500 = 5% APY
) -> Result<()> {
    let extension_types = &[ExtensionType::InterestBearingConfig];
    let space = ExtensionType::try_calculate_account_len::<Mint>(extension_types)?;

    // Create account...

    // Initialize interest-bearing extension
    let ix = interest_bearing_mint::instruction::initialize(
        &anchor_spl::token_2022::ID,
        ctx.accounts.mint.key,
        Some(ctx.accounts.rate_authority.key()),
        rate_basis_points,
    )?;

    anchor_lang::solana_program::program::invoke(
        &ix,
        &[ctx.accounts.mint.to_account_info()],
    )?;

    // Note: This doesn't actually mint new tokens
    // It displays balances with accrued interest
    // Actual interest comes from external source

    Ok(())
}
```

---

## TypeScript Examples

### Creating Token-2022 with @solana/spl-token

```typescript
import {
  createMint,
  getMint,
  getAccount,
  transfer,
  ExtensionType,
  createInitializeTransferFeeConfigInstruction,
  createInitializeMintInstruction,
  TOKEN_2022_PROGRAM_ID,
  getMintLen,
  harvestWithheldTokensToMint,
  withdrawWithheldTokensFromMint,
} from "@solana/spl-token";
import { Connection, Keypair, SystemProgram, Transaction } from "@solana/web3.js";

async function createTokenWithTransferFee() {
  const connection = new Connection("https://api.devnet.solana.com");
  const payer = Keypair.generate();
  const mintAuthority = Keypair.generate();
  const transferFeeConfigAuthority = Keypair.generate();
  const withdrawWithheldAuthority = Keypair.generate();

  const decimals = 9;
  const feeBasisPoints = 100; // 1%
  const maxFee = BigInt(1_000_000_000); // 1 token max

  // Calculate space needed
  const extensions = [ExtensionType.TransferFeeConfig];
  const mintLen = getMintLen(extensions);

  const mintKeypair = Keypair.generate();

  // Create transaction
  const transaction = new Transaction().add(
    // Create account
    SystemProgram.createAccount({
      fromPubkey: payer.publicKey,
      newAccountPubkey: mintKeypair.publicKey,
      space: mintLen,
      lamports: await connection.getMinimumBalanceForRentExemption(mintLen),
      programId: TOKEN_2022_PROGRAM_ID,
    }),
    // Initialize transfer fee config
    createInitializeTransferFeeConfigInstruction(
      mintKeypair.publicKey,
      transferFeeConfigAuthority.publicKey,
      withdrawWithheldAuthority.publicKey,
      feeBasisPoints,
      maxFee,
      TOKEN_2022_PROGRAM_ID
    ),
    // Initialize mint
    createInitializeMintInstruction(
      mintKeypair.publicKey,
      decimals,
      mintAuthority.publicKey,
      null,
      TOKEN_2022_PROGRAM_ID
    )
  );

  await connection.sendTransaction(transaction, [payer, mintKeypair]);

  console.log("Token-2022 mint with transfer fee:", mintKeypair.publicKey.toBase58());
}
```

---

## Common Patterns

### Pattern: Compliant Stablecoin

```rust
// Stablecoin with:
// - Default frozen accounts (KYC required)
// - Permanent delegate (can freeze/seize)
// - Transfer hook (compliance checks)

pub fn create_compliant_stablecoin(ctx: Context<CreateStable>) -> Result<()> {
    let extensions = &[
        ExtensionType::DefaultAccountState,
        ExtensionType::PermanentDelegate,
        ExtensionType::TransferHook,
    ];

    // Initialize default account state (frozen)
    // Initialize permanent delegate (compliance officer)
    // Initialize transfer hook (KYC check program)

    // All new accounts start frozen
    // Must be unfrozen after KYC
    // All transfers pass through compliance hook

    Ok(())
}
```

### Pattern: Gaming Item with Royalties

```rust
// In-game item with:
// - Transfer fee (creator royalty)
// - Metadata on-chain

pub fn create_game_item(ctx: Context<CreateItem>) -> Result<()> {
    let extensions = &[
        ExtensionType::TransferFeeConfig,
        ExtensionType::MetadataPointer,
    ];

    // 5% royalty on all trades
    // Full item metadata stored on-chain
    // No external dependencies

    Ok(())
}
```

---

## Key Takeaways

1. **Token-2022 extends SPL Token** â€” same base, new features
2. **Extensions are opt-in** â€” choose what you need
3. **Transfer Fee** enables on-chain royalties
4. **Transfer Hook** allows custom transfer logic
5. **Non-Transferable** creates soulbound tokens
6. **Confidential Transfer** provides privacy with ZK proofs
7. **Check ecosystem support** before using â€” not universal yet

---

## Next

Learn about testing strategies for Solana programs.

â†’ [4.8 Testing Strategies](./4.8-testing-strategies.md)
