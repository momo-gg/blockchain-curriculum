# 4.9 Security & Common Vulnerabilities

> *"In blockchain security, there are no second chances. The code is the contract."*

---

## Why This Matters

Solana programs handle real assets. Security vulnerabilities have led to hundreds of millions of dollars in losses across the blockchain ecosystem. Understanding common attack vectors and prevention techniques is essential for any program developer.

---

## ğŸŸ¢ General Understanding

### The Security Mindset

```
TRADITIONAL SOFTWARE:
  Bug found â†’ Patch deployed â†’ Users update
  Recovery possible, data can be restored

BLOCKCHAIN PROGRAMS:
  Bug found â†’ Funds already stolen
  No patches possible (immutable)
  No recovery, no rollback

CONSEQUENCE:
  Security must be perfect BEFORE deployment
  Assume attackers will find every weakness
  Defense in depth is mandatory
```

### Top Vulnerability Categories

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  Common Solana Vulnerabilities                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                      â”‚
â”‚   1. MISSING OWNER CHECKS                                           â”‚
â”‚      "Is this account owned by the right program?"                  â”‚
â”‚                                                                      â”‚
â”‚   2. MISSING SIGNER CHECKS                                          â”‚
â”‚      "Did the right person authorize this?"                         â”‚
â”‚                                                                      â”‚
â”‚   3. ARITHMETIC OVERFLOW/UNDERFLOW                                  â”‚
â”‚      "Will this math break with large numbers?"                     â”‚
â”‚                                                                      â”‚
â”‚   4. TYPE CONFUSION                                                 â”‚
â”‚      "Is this account the type I expect?"                           â”‚
â”‚                                                                      â”‚
â”‚   5. PDA SUBSTITUTION                                               â”‚
â”‚      "Can someone pass a fake PDA?"                                 â”‚
â”‚                                                                      â”‚
â”‚   6. REINITIALIZATION                                               â”‚
â”‚      "Can an account be set up twice?"                              â”‚
â”‚                                                                      â”‚
â”‚   7. CLOSING ACCOUNT VULNERABILITIES                                â”‚
â”‚      "Can rent extraction be exploited?"                            â”‚
â”‚                                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Example: Missing Owner Check

```
Program expects a "vault" account
  â†’ Attacker supplies a fake account
  â†’ Program transfers funds to attacker
```

One missing check can turn a valid instruction into a drain. This is why
ownership and signer validation are always first-line defenses.

---

## ğŸŸ¡ PM/EM Depth

### Security Checklist for Review

| Category | Question | Risk Level |
|----------|----------|------------|
| **Ownership** | Are all account owners validated? | Critical |
| **Signatures** | Are all required signers checked? | Critical |
| **Authorization** | Can only authorized users perform actions? | Critical |
| **Math** | Is all arithmetic using checked operations? | High |
| **Types** | Are account types verified (discriminators)? | High |
| **PDAs** | Are PDA seeds properly validated? | High |
| **Initialization** | Can accounts be reinitialized? | Medium |
| **Closing** | Is closing handled correctly? | Medium |
| **External Calls** | Are CPI targets validated? | High |

### Audit Requirements

```
WHEN TO AUDIT:

Before mainnet:     Always
After major changes: Always
Periodically:        Annually minimum

AUDIT SCOPE:

âœ“ All program code
âœ“ Client code that builds transactions
âœ“ Integration with external programs
âœ“ Upgrade mechanisms
âœ“ Admin key management
âœ“ Economic attack vectors
```

### Security Tools

| Tool | Purpose |
|------|---------|
| `anchor verify` | Verify deployed code matches source |
| `sec3` | Automated vulnerability scanner |
| `soteria` | Security analysis tool |
| `trident` | Fuzzing framework for Solana |
| External audits | Human expert review |

---

## ğŸ”µ Engineer Depth

### 1. Missing Owner Checks

**Vulnerability:**
```rust
// VULNERABLE: No owner check
pub fn withdraw(ctx: Context<Withdraw>, amount: u64) -> Result<()> {
    let vault = &ctx.accounts.vault;

    // Attacker could pass an account they created that looks like a vault
    // but is owned by a different program they control

    transfer_from_vault(vault, amount)?;
    Ok(())
}
```

**Fix:**
```rust
// SAFE: Anchor validates owner automatically with Account<'info, T>
#[derive(Accounts)]
pub struct Withdraw<'info> {
    // Account<'info, Vault> ensures:
    // 1. Owner is this program
    // 2. Discriminator matches Vault type
    #[account(mut)]
    pub vault: Account<'info, Vault>,

    pub authority: Signer<'info>,
}

// For UncheckedAccount, validate manually:
#[derive(Accounts)]
pub struct ManualCheck<'info> {
    /// CHECK: Validated in instruction
    pub account: UncheckedAccount<'info>,
}

pub fn manual_check(ctx: Context<ManualCheck>) -> Result<()> {
    let account = &ctx.accounts.account;

    // Explicit owner check
    require!(
        account.owner == &crate::ID,
        ErrorCode::InvalidOwner
    );

    Ok(())
}
```

### 2. Missing Signer Checks

**Vulnerability:**
```rust
// VULNERABLE: Anyone can call this
#[derive(Accounts)]
pub struct TransferFunds<'info> {
    #[account(mut)]
    pub from: Account<'info, TokenAccount>,
    #[account(mut)]
    pub to: Account<'info, TokenAccount>,
    // No signer required!
}
```

**Fix:**
```rust
// SAFE: Authority must sign
#[derive(Accounts)]
pub struct TransferFunds<'info> {
    #[account(
        mut,
        constraint = from.owner == authority.key() @ ErrorCode::Unauthorized
    )]
    pub from: Account<'info, TokenAccount>,

    #[account(mut)]
    pub to: Account<'info, TokenAccount>,

    pub authority: Signer<'info>,  // Must sign transaction
}
```

### 3. Arithmetic Overflow/Underflow

**Vulnerability:**
```rust
// VULNERABLE: Can overflow
pub fn add_points(ctx: Context<AddPoints>, points: u64) -> Result<()> {
    let user = &mut ctx.accounts.user;
    user.points = user.points + points;  // Can wrap around!
    Ok(())
}

// VULNERABLE: Can underflow
pub fn spend_points(ctx: Context<SpendPoints>, points: u64) -> Result<()> {
    let user = &mut ctx.accounts.user;
    user.points = user.points - points;  // Can underflow to huge number!
    Ok(())
}
```

**Fix:**
```rust
// SAFE: Using checked arithmetic
pub fn add_points(ctx: Context<AddPoints>, points: u64) -> Result<()> {
    let user = &mut ctx.accounts.user;
    user.points = user.points
        .checked_add(points)
        .ok_or(ErrorCode::Overflow)?;
    Ok(())
}

pub fn spend_points(ctx: Context<SpendPoints>, points: u64) -> Result<()> {
    let user = &mut ctx.accounts.user;
    user.points = user.points
        .checked_sub(points)
        .ok_or(ErrorCode::InsufficientPoints)?;
    Ok(())
}

// Also safe: require! macro
pub fn safe_divide(ctx: Context<Divide>, a: u64, b: u64) -> Result<()> {
    require!(b != 0, ErrorCode::DivisionByZero);
    let result = a / b;
    Ok(())
}
```

### 4. Type Confusion

**Vulnerability:**
```rust
// VULNERABLE: No type verification
#[derive(Accounts)]
pub struct Process<'info> {
    /// CHECK: We trust this is correct
    pub data_account: UncheckedAccount<'info>,
}

pub fn process(ctx: Context<Process>) -> Result<()> {
    // Attacker passes a different account type with similar structure
    let data = DataAccount::try_from_slice(&ctx.accounts.data_account.data.borrow())?;
    // Data could be maliciously crafted!
    Ok(())
}
```

**Fix:**
```rust
// SAFE: Anchor checks discriminator
#[derive(Accounts)]
pub struct Process<'info> {
    // Account<T> verifies:
    // - 8-byte discriminator matches T
    // - Owner is this program
    pub data_account: Account<'info, DataAccount>,
}

// If you must use UncheckedAccount:
pub fn process(ctx: Context<Process>) -> Result<()> {
    let account = &ctx.accounts.data_account;

    // Check discriminator manually
    let data = account.data.borrow();
    let discriminator = &data[..8];
    require!(
        discriminator == DataAccount::discriminator(),
        ErrorCode::InvalidAccountType
    );

    Ok(())
}
```

### 5. PDA Substitution

**Vulnerability:**
```rust
// VULNERABLE: No seed verification
#[derive(Accounts)]
pub struct UseVault<'info> {
    #[account(mut)]
    pub vault: Account<'info, Vault>,  // Which vault? Any vault!
}

pub fn withdraw_all(ctx: Context<UseVault>) -> Result<()> {
    // Attacker could pass ANY vault account
    let vault = &mut ctx.accounts.vault;
    transfer_all(vault)?;
    Ok(())
}
```

**Fix:**
```rust
// SAFE: PDA seeds verified
#[derive(Accounts)]
pub struct UseVault<'info> {
    #[account(
        mut,
        seeds = [b"vault", user.key().as_ref()],
        bump = vault.bump,
        has_one = user,  // Double-check ownership
    )]
    pub vault: Account<'info, Vault>,

    pub user: Signer<'info>,
}

// Now only the vault for THIS user can be used
```

### 6. Reinitialization Attack

**Vulnerability:**
```rust
// VULNERABLE: Can be called multiple times
pub fn initialize(ctx: Context<Initialize>) -> Result<()> {
    let account = &mut ctx.accounts.my_account;
    account.owner = ctx.accounts.user.key();
    account.balance = 0;
    // Attacker can call again with different owner!
    Ok(())
}
```

**Fix:**
```rust
// SAFE: Using Anchor's init
#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(
        init,  // Anchor prevents reinitialization
        payer = user,
        space = 8 + MyAccount::INIT_SPACE,
        seeds = [b"account", user.key().as_ref()],
        bump
    )]
    pub my_account: Account<'info, MyAccount>,

    #[account(mut)]
    pub user: Signer<'info>,

    pub system_program: Program<'info, System>,
}

// Or manual check:
pub fn initialize(ctx: Context<Initialize>) -> Result<()> {
    let account = &mut ctx.accounts.my_account;

    require!(!account.is_initialized, ErrorCode::AlreadyInitialized);

    account.is_initialized = true;
    account.owner = ctx.accounts.user.key();
    Ok(())
}
```

### 7. Closing Account Vulnerabilities

**Vulnerability:**
```rust
// VULNERABLE: Doesn't clear data
pub fn close(ctx: Context<Close>) -> Result<()> {
    let account = &mut ctx.accounts.my_account;
    let destination = &ctx.accounts.destination;

    // Transfer lamports but don't zero data
    **destination.lamports.borrow_mut() += **account.to_account_info().lamports.borrow();
    **account.to_account_info().lamports.borrow_mut() = 0;

    // Account data still exists! Can be "resurrected"
    Ok(())
}
```

**Fix:**
```rust
// SAFE: Use Anchor's close
#[derive(Accounts)]
pub struct Close<'info> {
    #[account(
        mut,
        close = destination,  // Anchor zeros data and transfers rent
        has_one = owner,
    )]
    pub my_account: Account<'info, MyAccount>,

    #[account(mut)]
    pub destination: SystemAccount<'info>,

    pub owner: Signer<'info>,
}

// Anchor automatically:
// 1. Zeros account data
// 2. Transfers lamports to destination
// 3. Sets owner to System Program
```

### 8. CPI Target Validation

**Vulnerability:**
```rust
// VULNERABLE: Trusts any program
pub fn call_external(ctx: Context<CallExternal>) -> Result<()> {
    let program = &ctx.accounts.external_program;

    // Attacker passes their own malicious program!
    invoke(
        &some_instruction,
        &[program.to_account_info()],
    )?;

    Ok(())
}
```

**Fix:**
```rust
// SAFE: Validate program address
#[derive(Accounts)]
pub struct CallExternal<'info> {
    // Use Program<'info, T> to validate
    pub token_program: Program<'info, Token>,  // Must be Token program

    // Or check manually
    /// CHECK: Validated below
    #[account(address = KNOWN_PROGRAM_ID @ ErrorCode::InvalidProgram)]
    pub other_program: UncheckedAccount<'info>,
}
```

### 9. Incorrect Lamport Balance Changes

**Vulnerability:**
```rust
// VULNERABLE: Doesn't balance lamports
pub fn transfer(ctx: Context<Transfer>, amount: u64) -> Result<()> {
    let from = &mut ctx.accounts.from;
    let to = &mut ctx.accounts.to;

    // Only credits, doesn't debit!
    **to.lamports.borrow_mut() += amount;

    Ok(())
    // Lamports created from nothing!
}
```

**Fix:**
```rust
// SAFE: Balanced lamport changes
pub fn transfer(ctx: Context<Transfer>, amount: u64) -> Result<()> {
    let from = &mut ctx.accounts.from;
    let to = &mut ctx.accounts.to;

    // Debit and credit must balance
    **from.lamports.borrow_mut() = from.lamports()
        .checked_sub(amount)
        .ok_or(ErrorCode::InsufficientFunds)?;

    **to.lamports.borrow_mut() = to.lamports()
        .checked_add(amount)
        .ok_or(ErrorCode::Overflow)?;

    Ok(())
}
```

### 10. Missing Rent Exemption Check

**Vulnerability:**
```rust
// VULNERABLE: Account could be garbage collected
pub fn create_account(ctx: Context<Create>) -> Result<()> {
    // Creates account with insufficient lamports
    let min_rent = 100;  // Too low!

    invoke(
        &system_instruction::create_account(
            ctx.accounts.payer.key,
            ctx.accounts.new_account.key,
            min_rent,  // Not rent-exempt
            100,
            ctx.program_id,
        ),
        &[...],
    )?;

    // Account will be deleted by runtime!
    Ok(())
}
```

**Fix:**
```rust
// SAFE: Calculate rent exemption
pub fn create_account(ctx: Context<Create>) -> Result<()> {
    let rent = Rent::get()?;
    let space = 100;
    let lamports = rent.minimum_balance(space);

    invoke(
        &system_instruction::create_account(
            ctx.accounts.payer.key,
            ctx.accounts.new_account.key,
            lamports,  // Rent-exempt amount
            space as u64,
            ctx.program_id,
        ),
        &[...],
    )?;

    Ok(())
}

// Anchor does this automatically with `init`
```

---

## Security Best Practices

### 1. Defense in Depth

```rust
#[derive(Accounts)]
pub struct SecureOperation<'info> {
    #[account(
        mut,
        // Layer 1: PDA validation
        seeds = [b"vault", authority.key().as_ref()],
        bump = vault.bump,
        // Layer 2: Ownership check
        has_one = authority,
        // Layer 3: State check
        constraint = vault.is_active @ ErrorCode::VaultInactive,
        // Layer 4: Amount check
        constraint = vault.balance >= amount @ ErrorCode::InsufficientBalance,
    )]
    pub vault: Account<'info, Vault>,

    // Layer 5: Signature requirement
    pub authority: Signer<'info>,
}
```

### 2. Fail-Safe Defaults

```rust
// Default to restrictive
#[account]
pub struct Config {
    pub admin: Pubkey,
    pub paused: bool,  // Default false, but check
    pub max_amount: u64,
}

pub fn transfer(ctx: Context<Transfer>, amount: u64) -> Result<()> {
    let config = &ctx.accounts.config;

    // Check pause state
    require!(!config.paused, ErrorCode::Paused);

    // Enforce limits
    require!(amount <= config.max_amount, ErrorCode::AmountTooLarge);

    // Proceed only if all checks pass
    Ok(())
}
```

### 3. Input Validation

```rust
pub fn process_input(
    ctx: Context<Process>,
    name: String,
    amount: u64,
    target: Pubkey,
) -> Result<()> {
    // String length
    require!(name.len() <= 32, ErrorCode::NameTooLong);
    require!(!name.is_empty(), ErrorCode::NameEmpty);

    // Amount bounds
    require!(amount > 0, ErrorCode::InvalidAmount);
    require!(amount <= MAX_AMOUNT, ErrorCode::AmountTooLarge);

    // Address validation
    require!(target != Pubkey::default(), ErrorCode::InvalidTarget);
    require!(target != ctx.accounts.source.key(), ErrorCode::SelfTransfer);

    Ok(())
}
```

---

## Security Audit Preparation

### Pre-Audit Checklist

```
â–¡ All code compiles without warnings
â–¡ All tests pass
â–¡ 100% test coverage on critical paths
â–¡ Documentation complete
â–¡ Access control documented
â–¡ State machine documented
â–¡ Known limitations documented
â–¡ Upgrade mechanism documented
â–¡ Admin key management documented
```

### Common Audit Findings

| Finding | Severity | Fix |
|---------|----------|-----|
| Missing owner check | Critical | Add Account<T> or manual check |
| Missing signer | Critical | Add Signer<'info> |
| Unchecked arithmetic | High | Use checked_* functions |
| PDA not validated | High | Add seeds constraint |
| Reinitialization possible | Medium | Use init constraint |
| Missing close discriminator zero | Medium | Use Anchor close |

---

## Key Takeaways

1. **Assume adversarial inputs** â€” validate everything
2. **Owner checks are critical** â€” use Account<T> or verify manually
3. **Signer checks are critical** â€” require signatures for actions
4. **Use checked math** â€” overflow/underflow are real attacks
5. **Validate PDAs** â€” always verify seeds
6. **Prevent reinitialization** â€” use init or check flag
7. **Close accounts properly** â€” zero data, transfer rent
8. **Verify CPI targets** â€” don't trust any program
9. **Defense in depth** â€” multiple validation layers
10. **Get audited** â€” human review is essential

---

## Next

Learn about optimizing your programs for performance and compute efficiency.

â†’ [4.10 Program Optimization](./4.10-program-optimization.md)
