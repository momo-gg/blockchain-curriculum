# 5.1 Client Architectures

> *"The best blockchain UX is one where users don't know they're using a blockchain."*

---

## Why This Matters

A beautiful, well-tested Solana program is useless without clients to interact with it. Understanding client architecture patterns helps you build applications that are performant, reliable, and provide great user experiences.

---

## ğŸŸ¢ General Understanding

### The Client Landscape

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Solana Client Ecosystem                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                      â”‚
â”‚   WEB CLIENTS                     MOBILE CLIENTS                    â”‚
â”‚   â”œâ”€â”€ React / Next.js             â”œâ”€â”€ React Native                  â”‚
â”‚   â”œâ”€â”€ Vue / Nuxt                  â”œâ”€â”€ Flutter                       â”‚
â”‚   â””â”€â”€ Plain JavaScript            â””â”€â”€ Native iOS/Android            â”‚
â”‚                                                                      â”‚
â”‚   BACKEND CLIENTS                 CLI / SCRIPTS                     â”‚
â”‚   â”œâ”€â”€ Node.js                     â”œâ”€â”€ TypeScript                    â”‚
â”‚   â”œâ”€â”€ Python                      â”œâ”€â”€ Rust                          â”‚
â”‚   â””â”€â”€ Rust                        â””â”€â”€ Shell + solana-cli            â”‚
â”‚                                                                      â”‚
â”‚                      SDK OPTIONS                                    â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚ @solana/web3.js    - Official JavaScript SDK                â”‚   â”‚
â”‚   â”‚ @coral-xyz/anchor  - Anchor client (wraps web3.js)          â”‚   â”‚
â”‚   â”‚ @solana/spl-token  - Token operations                       â”‚   â”‚
â”‚   â”‚ solana-py          - Python SDK                              â”‚   â”‚
â”‚   â”‚ solana-sdk (Rust)  - Native Rust client                     â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Client Responsibilities

| Responsibility | Description |
|----------------|-------------|
| **Transaction Building** | Construct valid transactions with proper accounts |
| **Signing** | Obtain signatures from wallet or keypair |
| **Submission** | Send transactions to RPC |
| **Confirmation** | Wait for and verify transaction success |
| **Account Reading** | Fetch and deserialize account data |
| **Error Handling** | Parse and display meaningful errors |
| **UX** | Provide feedback during async operations |

### Read vs Write Paths (Mental Model)

```
READ PATH: UI â†’ RPC â†’ Account Data â†’ UI
WRITE PATH: UI â†’ Wallet â†’ RPC â†’ Leader â†’ Program â†’ Confirmation â†’ UI
```

Most reliability issues show up on the write path, so invest extra UX
and error handling there.

---

## ğŸŸ¡ PM/EM Depth

### Architecture Patterns

#### Pattern 1: Direct RPC

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      Direct RPC Pattern                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                      â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚   â”‚   Client   â”‚â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚    RPC     â”‚â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚  Solana    â”‚       â”‚
â”‚   â”‚ (Browser)  â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”‚   Node     â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”‚  Network   â”‚       â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â”‚                                                                      â”‚
â”‚   Pros:                                                             â”‚
â”‚   âœ“ Simple architecture                                             â”‚
â”‚   âœ“ Direct blockchain access                                        â”‚
â”‚   âœ“ Real-time data                                                  â”‚
â”‚                                                                      â”‚
â”‚   Cons:                                                             â”‚
â”‚   âœ— Rate limits on public RPCs                                     â”‚
â”‚   âœ— No caching layer                                               â”‚
â”‚   âœ— Wallet required in browser                                     â”‚
â”‚                                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### Pattern 2: Backend Proxy

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     Backend Proxy Pattern                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                      â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚   â”‚   Client   â”‚â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚  Backend   â”‚â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚    RPC     â”‚       â”‚
â”‚   â”‚ (Browser)  â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”‚   Server   â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”‚   Node     â”‚       â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â”‚         â”‚                      â”‚                                    â”‚
â”‚         â”‚                      â–¼                                    â”‚
â”‚         â”‚               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                             â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚   Cache    â”‚ (Redis, etc.)               â”‚
â”‚                         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                             â”‚
â”‚                                                                      â”‚
â”‚   Pros:                                                             â”‚
â”‚   âœ“ Caching for reads                                               â”‚
â”‚   âœ“ Rate limit management                                           â”‚
â”‚   âœ“ Can use private RPC                                            â”‚
â”‚   âœ“ Server-side signing possible                                   â”‚
â”‚                                                                      â”‚
â”‚   Cons:                                                             â”‚
â”‚   âœ— Additional infrastructure                                      â”‚
â”‚   âœ— Potential single point of failure                              â”‚
â”‚   âœ— Added latency                                                  â”‚
â”‚                                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### Pattern 3: Hybrid

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                       Hybrid Pattern                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                      â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚   â”‚   Client   â”‚â”€â”€â”€â”€â”€â”€â”€ Writes (signed) â”€â”€â”€â”€â”€â–ºâ”‚    RPC     â”‚       â”‚
â”‚   â”‚ (Browser)  â”‚                              â”‚   Node     â”‚       â”‚
â”‚   â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜                              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â”‚         â”‚                                                           â”‚
â”‚         â”‚ Reads                                                     â”‚
â”‚         â–¼                                                           â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                             â”‚
â”‚   â”‚  Backend   â”‚â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚   Cache    â”‚                             â”‚
â”‚   â”‚  (Reads)   â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”‚  + Index   â”‚                             â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                             â”‚
â”‚                                                                      â”‚
â”‚   Best of both:                                                     â”‚
â”‚   âœ“ Direct signing (no trust required)                             â”‚
â”‚   âœ“ Cached/indexed reads (fast)                                    â”‚
â”‚   âœ“ Can build custom indexes                                       â”‚
â”‚                                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### RPC Provider Selection

| Provider | Free Tier | Best For |
|----------|-----------|----------|
| **Helius** | Varies | DeFi, low-latency |
| **Quicknode** | Varies | Enterprise, reliability |
| **Triton One** | Varies | High-volume |
| **Alchemy** | Varies | Multi-chain apps |
| **Public RPC** | Rate limited | Development only |

### Indexing Solutions

For complex queries beyond RPC capabilities:

| Solution | Use Case |
|----------|----------|
| **Helius DAS** | NFT metadata, compressed NFTs |
| **The Graph** | Custom subgraphs |
| **Shyft** | Real-time indexing |
| **Custom Geyser** | Full control, high volume |
| **PostgreSQL + listener** | Moderate volume, custom needs |

---

## ğŸ”µ Engineer Depth

### Project Structure

```
my-solana-app/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ lib/
â”‚   â”‚   â”œâ”€â”€ solana/
â”‚   â”‚   â”‚   â”œâ”€â”€ connection.ts      # RPC connection setup
â”‚   â”‚   â”‚   â”œâ”€â”€ transactions.ts    # Transaction builders
â”‚   â”‚   â”‚   â”œâ”€â”€ accounts.ts        # Account fetchers
â”‚   â”‚   â”‚   â””â”€â”€ program.ts         # Program client (Anchor)
â”‚   â”‚   â”œâ”€â”€ hooks/
â”‚   â”‚   â”‚   â”œâ”€â”€ useProgram.ts      # React hook for program
â”‚   â”‚   â”‚   â”œâ”€â”€ useAccount.ts      # Account subscription
â”‚   â”‚   â”‚   â””â”€â”€ useTransaction.ts  # Transaction state
â”‚   â”‚   â””â”€â”€ utils/
â”‚   â”‚       â”œâ”€â”€ errors.ts          # Error parsing
â”‚   â”‚       â””â”€â”€ formatting.ts      # Display helpers
â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â””â”€â”€ ...
â”‚   â””â”€â”€ pages/
â”‚       â””â”€â”€ ...
â”œâ”€â”€ idl/
â”‚   â””â”€â”€ my_program.json            # Program IDL
â””â”€â”€ types/
    â””â”€â”€ my_program.ts              # Generated types
```

### Connection Management

```typescript
// src/lib/solana/connection.ts
import { Connection, Commitment } from "@solana/web3.js";

// Singleton connection with fallback
class ConnectionManager {
  private connection: Connection | null = null;
  private endpoints: string[];
  private currentIndex = 0;

  constructor(endpoints: string[]) {
    this.endpoints = endpoints;
  }

  getConnection(commitment: Commitment = "confirmed"): Connection {
    if (!this.connection) {
      this.connection = new Connection(
        this.endpoints[this.currentIndex],
        {
          commitment,
          wsEndpoint: this.endpoints[this.currentIndex].replace("https", "wss"),
          confirmTransactionInitialTimeout: 60000,
        }
      );
    }
    return this.connection;
  }

  async rotateEndpoint(): Promise<void> {
    this.currentIndex = (this.currentIndex + 1) % this.endpoints.length;
    this.connection = null;
    console.log(`Rotated to endpoint: ${this.endpoints[this.currentIndex]}`);
  }
}

export const connectionManager = new ConnectionManager([
  process.env.NEXT_PUBLIC_RPC_URL!,
  process.env.NEXT_PUBLIC_RPC_FALLBACK!,
]);

export const getConnection = () => connectionManager.getConnection();
```

### Program Client Pattern

```typescript
// src/lib/solana/program.ts
import { Program, AnchorProvider, Idl } from "@coral-xyz/anchor";
import { Connection, PublicKey } from "@solana/web3.js";
import { MyProgram } from "../../types/my_program";
import IDL from "../../idl/my_program.json";

const PROGRAM_ID = new PublicKey("Your11111111111111111111111111111111111111");

export function getProgram(
  connection: Connection,
  wallet: AnchorProvider["wallet"]
): Program<MyProgram> {
  const provider = new AnchorProvider(
    connection,
    wallet,
    { commitment: "confirmed" }
  );

  return new Program(
    IDL as Idl,
    PROGRAM_ID,
    provider
  ) as Program<MyProgram>;
}

// For read-only operations (no wallet needed)
export function getReadOnlyProgram(connection: Connection): Program<MyProgram> {
  const provider = new AnchorProvider(
    connection,
    {
      publicKey: PublicKey.default,
      signTransaction: async (tx) => tx,
      signAllTransactions: async (txs) => txs,
    },
    { commitment: "confirmed" }
  );

  return new Program(
    IDL as Idl,
    PROGRAM_ID,
    provider
  ) as Program<MyProgram>;
}
```

### React Hook Pattern

```typescript
// src/lib/hooks/useProgram.ts
import { useConnection, useWallet } from "@solana/wallet-adapter-react";
import { useMemo } from "react";
import { getProgram, getReadOnlyProgram } from "../solana/program";

export function useProgram() {
  const { connection } = useConnection();
  const wallet = useWallet();

  const program = useMemo(() => {
    if (wallet.publicKey && wallet.signTransaction) {
      return getProgram(connection, wallet);
    }
    return getReadOnlyProgram(connection);
  }, [connection, wallet.publicKey, wallet.signTransaction]);

  return program;
}

// Usage in component:
function MyComponent() {
  const program = useProgram();

  const fetchData = async () => {
    const account = await program.account.myAccount.fetch(address);
    // ...
  };
}
```

### Error Handling Pattern

```typescript
// src/lib/utils/errors.ts
import { AnchorError } from "@coral-xyz/anchor";

export interface ParsedError {
  code: string;
  message: string;
  isUserFriendly: boolean;
}

export function parseError(error: unknown): ParsedError {
  // Anchor program error
  if (error instanceof AnchorError) {
    return {
      code: error.error.errorCode.code,
      message: error.error.errorMessage,
      isUserFriendly: true,
    };
  }

  // Transaction error
  if (error instanceof Error) {
    // Insufficient funds
    if (error.message.includes("insufficient funds")) {
      return {
        code: "INSUFFICIENT_FUNDS",
        message: "You don't have enough SOL for this transaction",
        isUserFriendly: true,
      };
    }

    // User rejected
    if (error.message.includes("User rejected")) {
      return {
        code: "USER_REJECTED",
        message: "Transaction was cancelled",
        isUserFriendly: true,
      };
    }

    // Timeout
    if (error.message.includes("timeout") || error.message.includes("Timeout")) {
      return {
        code: "TIMEOUT",
        message: "Transaction timed out. Please try again.",
        isUserFriendly: true,
      };
    }
  }

  // Unknown error
  return {
    code: "UNKNOWN",
    message: "An unexpected error occurred",
    isUserFriendly: false,
  };
}
```

### State Management Pattern

```typescript
// Using React Query for caching and refetching
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { PublicKey } from "@solana/web3.js";
import { useProgram } from "./useProgram";

export function useAccount(address: PublicKey) {
  const program = useProgram();

  return useQuery({
    queryKey: ["account", address.toString()],
    queryFn: async () => {
      return program.account.myAccount.fetch(address);
    },
    staleTime: 10_000, // Consider fresh for 10s
    refetchInterval: 30_000, // Auto-refetch every 30s
  });
}

export function useUpdateAccount() {
  const program = useProgram();
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({ address, data }: { address: PublicKey; data: any }) => {
      const tx = await program.methods
        .updateAccount(data)
        .accounts({ myAccount: address })
        .rpc();

      return tx;
    },
    onSuccess: (_, variables) => {
      // Invalidate and refetch
      queryClient.invalidateQueries({
        queryKey: ["account", variables.address.toString()],
      });
    },
  });
}
```

---

## Common Patterns

### Loading States

```typescript
// Transaction with proper loading states
function TransactionButton() {
  const [status, setStatus] = useState<
    "idle" | "signing" | "confirming" | "success" | "error"
  >("idle");

  const handleTransaction = async () => {
    try {
      setStatus("signing");
      const tx = await program.methods.doSomething().rpc();

      setStatus("confirming");
      await connection.confirmTransaction(tx, "confirmed");

      setStatus("success");
    } catch (error) {
      setStatus("error");
      // Handle error
    }
  };

  return (
    <button onClick={handleTransaction} disabled={status !== "idle"}>
      {status === "idle" && "Submit"}
      {status === "signing" && "Sign in wallet..."}
      {status === "confirming" && "Confirming..."}
      {status === "success" && "Success!"}
      {status === "error" && "Error - Try again"}
    </button>
  );
}
```

### Optimistic Updates

```typescript
// Show immediate feedback before confirmation
const updateMutation = useMutation({
  mutationFn: updateOnChain,
  onMutate: async (newData) => {
    // Cancel outgoing refetches
    await queryClient.cancelQueries({ queryKey: ["account"] });

    // Snapshot previous value
    const previous = queryClient.getQueryData(["account"]);

    // Optimistically update
    queryClient.setQueryData(["account"], newData);

    return { previous };
  },
  onError: (err, newData, context) => {
    // Rollback on error
    queryClient.setQueryData(["account"], context?.previous);
  },
  onSettled: () => {
    // Refetch to sync
    queryClient.invalidateQueries({ queryKey: ["account"] });
  },
});
```

---

## Key Takeaways

1. **Choose architecture based on needs** â€” direct, proxy, or hybrid
2. **Use proper RPC providers** â€” public RPCs are for dev only
3. **Structure code for maintainability** â€” separate concerns
4. **Handle errors gracefully** â€” parse and display user-friendly messages
5. **Manage state effectively** â€” use React Query or similar
6. **Show loading states** â€” users need feedback
7. **Consider indexing** â€” for complex queries

---

## Next

Deep dive into the core JavaScript SDK for Solana.

â†’ [5.2 @solana/web3.js Deep Dive](./5.2-web3js-deep-dive.md)
