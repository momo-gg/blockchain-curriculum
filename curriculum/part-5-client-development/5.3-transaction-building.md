# 5.3 Transaction Building

> *"A well-constructed transaction is like a well-written sentence â€” every part serves a purpose."*

---

## Why This Matters

Building transactions correctly is fundamental to Solana development. Understanding transaction structure, instruction composition, and common patterns helps you create efficient, reliable client applications.

---

## ðŸŸ¢ General Understanding

### Transaction Anatomy

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      Transaction Structure                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                      â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚ HEADER                                                      â”‚   â”‚
â”‚   â”‚ â”œâ”€â”€ Signature count                                         â”‚   â”‚
â”‚   â”‚ â”œâ”€â”€ Readonly signed count                                   â”‚   â”‚
â”‚   â”‚ â””â”€â”€ Readonly unsigned count                                 â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                      â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚ SIGNATURES (64 bytes each)                                  â”‚   â”‚
â”‚   â”‚ â””â”€â”€ [sig1, sig2, ...]                                       â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                      â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚ ACCOUNT KEYS (32 bytes each)                                â”‚   â”‚
â”‚   â”‚ â””â”€â”€ [key1, key2, key3, ...]                                 â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                      â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚ RECENT BLOCKHASH (32 bytes)                                 â”‚   â”‚
â”‚   â”‚ â””â”€â”€ Prevents replay attacks                                 â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                      â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚ INSTRUCTIONS                                                â”‚   â”‚
â”‚   â”‚ â”œâ”€â”€ Instruction 1                                           â”‚   â”‚
â”‚   â”‚ â”‚   â”œâ”€â”€ Program ID index                                    â”‚   â”‚
â”‚   â”‚ â”‚   â”œâ”€â”€ Account indices                                     â”‚   â”‚
â”‚   â”‚ â”‚   â””â”€â”€ Instruction data                                    â”‚   â”‚
â”‚   â”‚ â”œâ”€â”€ Instruction 2                                           â”‚   â”‚
â”‚   â”‚ â””â”€â”€ ...                                                     â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                      â”‚
â”‚   Max size: ~1,232 bytes (legacy; v0 differs with ALTs)              â”‚
â”‚                                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Transaction Lifecycle

```
Build â†’ Sign â†’ Submit â†’ Confirm

1. BUILD
   - Create instructions
   - Add accounts
   - Set blockhash and fee payer

2. SIGN
   - Collect all required signatures
   - Sign with keypairs or wallet

3. SUBMIT
   - Send to RPC node
   - Node forwards to leader

4. CONFIRM
   - Wait for inclusion in block
   - Verify success/failure
```

---

## ðŸŸ¡ PM/EM Depth

### Instruction Types

| Type | Description | Example |
|------|-------------|---------|
| **System** | Native operations | Transfer SOL, create accounts |
| **SPL Token** | Token operations | Transfer tokens, mint, burn |
| **Custom Program** | Your programs | Any Anchor instruction |
| **Compute Budget** | Resource management | Set CU limit, priority fee |

### Transaction Limits

| Limit | Value | Impact |
|-------|-------|--------|
| Max size | ~1,232 bytes (legacy) | Limits accounts and data |
| Max accounts | 64 (legacy; higher with ALT) | Limits instruction complexity |
| Max CU default | 200,000 | May need to increase |
| Max CU allowed | 1,400,000 | With priority fee |
| Blockhash validity | ~2 minutes | Must send quickly |

> âš ï¸ **Trading Risk Vocabulary (Applied to Transactions)**
> - **Slippage**: tight tolerances cause swaps to fail during fast moves.
> - **Price impact**: large orders can move the pool against the user.
> - **Liquidity**: thin pools produce worse fills and higher failure rates.
> - **Stop loss**: triggers help, but fills can still slip in volatile markets.

### Transaction Lifecycle (Mental Model)

```
Built â†’ Signed â†’ Submitted â†’ Processed â†’ Confirmed â†’ Finalized
```

User-facing status should map to these states to avoid confusion.

### Transaction UI Patterns

Good transaction UX reduces support tickets and failed actions:

**Recommended States**
1. **Review**: Show intent (action, amount, destination, fees).
2. **Wallet Approval**: Prompt to sign; show wallet name and expected popup.
3. **Submitted**: Show signature with a block explorer link.
4. **Confirmed**: Show finalized state (balance change, success message).
5. **Failed**: Surface the on-chain error and a retry path.

**Practical Tips**
- Simulate before sending to catch errors early (`simulateTransaction`).
- Show fee estimates and compute unit price when using priority fees.
- Avoid blocking the UI; confirmations can take seconds under load.
- Cache the signature so users can resume after a refresh.

---

## ðŸ”µ Engineer Depth

### Basic Transaction Building

```typescript
import {
  Connection,
  Transaction,
  SystemProgram,
  Keypair,
  LAMPORTS_PER_SOL,
  sendAndConfirmTransaction,
} from "@solana/web3.js";

async function simpleTransfer(
  connection: Connection,
  sender: Keypair,
  recipient: PublicKey,
  amount: number
): Promise<string> {
  // Create transaction
  const transaction = new Transaction();

  // Add transfer instruction
  transaction.add(
    SystemProgram.transfer({
      fromPubkey: sender.publicKey,
      toPubkey: recipient,
      lamports: amount * LAMPORTS_PER_SOL,
    })
  );

  // Send and confirm
  const signature = await sendAndConfirmTransaction(
    connection,
    transaction,
    [sender]
  );

  return signature;
}
```

### Multi-Instruction Transaction

```typescript
import { TOKEN_PROGRAM_ID } from "@solana/spl-token";

async function complexTransaction(
  connection: Connection,
  payer: Keypair
): Promise<string> {
  const transaction = new Transaction();

  // Instruction 1: Set compute budget
  transaction.add(
    ComputeBudgetProgram.setComputeUnitLimit({ units: 300_000 })
  );

  // Instruction 2: Set priority fee
  transaction.add(
    ComputeBudgetProgram.setComputeUnitPrice({ microLamports: 1_000 })
  );

  // Instruction 3: Transfer SOL
  transaction.add(
    SystemProgram.transfer({
      fromPubkey: payer.publicKey,
      toPubkey: recipient,
      lamports: 0.01 * LAMPORTS_PER_SOL,
    })
  );

  // Instruction 4: Custom program instruction
  transaction.add(
    new TransactionInstruction({
      keys: [
        { pubkey: payer.publicKey, isSigner: true, isWritable: true },
        { pubkey: dataAccount, isSigner: false, isWritable: true },
      ],
      programId: myProgramId,
      data: Buffer.from([1, 2, 3, 4]), // Instruction data
    })
  );

  // Set metadata
  const { blockhash, lastValidBlockHeight } = await connection.getLatestBlockhash();
  transaction.recentBlockhash = blockhash;
  transaction.feePayer = payer.publicKey;

  // Sign and send
  transaction.sign(payer);
  const signature = await connection.sendRawTransaction(transaction.serialize());

  // Wait for confirmation with timeout
  await connection.confirmTransaction({
    signature,
    blockhash,
    lastValidBlockHeight,
  });

  return signature;
}
```

### Anchor Transaction Building

```typescript
import { Program, BN } from "@coral-xyz/anchor";
import { MyProgram } from "../types/my_program";

async function anchorTransaction(
  program: Program<MyProgram>,
  user: Keypair,
  amount: number
): Promise<string> {
  // Method 1: Direct execution
  const tx = await program.methods
    .deposit(new BN(amount))
    .accounts({
      user: user.publicKey,
      vault: vaultPda,
      systemProgram: SystemProgram.programId,
    })
    .signers([user])
    .rpc();

  return tx;
}

// Method 2: Get instruction for custom transaction
async function anchorWithCustomTx(
  program: Program<MyProgram>,
  user: Keypair
): Promise<string> {
  // Get instruction without executing
  const ix = await program.methods
    .deposit(new BN(1000))
    .accounts({
      user: user.publicKey,
      vault: vaultPda,
      systemProgram: SystemProgram.programId,
    })
    .instruction();

  // Build custom transaction
  const transaction = new Transaction();
  transaction.add(ComputeBudgetProgram.setComputeUnitLimit({ units: 200_000 }));
  transaction.add(ix);

  // Send with program's provider
  const signature = await program.provider.sendAndConfirm(transaction, [user]);

  return signature;
}
```

### Versioned Transactions

```typescript
import {
  VersionedTransaction,
  TransactionMessage,
  AddressLookupTableProgram,
} from "@solana/web3.js";

// Create lookup table
async function createLookupTable(
  connection: Connection,
  payer: Keypair,
  addresses: PublicKey[]
): Promise<PublicKey> {
  const slot = await connection.getSlot();

  const [createIx, lookupTableAddress] = AddressLookupTableProgram.createLookupTable({
    authority: payer.publicKey,
    payer: payer.publicKey,
    recentSlot: slot,
  });

  const extendIx = AddressLookupTableProgram.extendLookupTable({
    lookupTable: lookupTableAddress,
    authority: payer.publicKey,
    payer: payer.publicKey,
    addresses,
  });

  const transaction = new Transaction().add(createIx, extendIx);
  await sendAndConfirmTransaction(connection, transaction, [payer]);

  // Wait for table to be active
  await sleep(1000);

  return lookupTableAddress;
}

// Use lookup table
async function versionedTransaction(
  connection: Connection,
  payer: Keypair,
  lookupTableAddress: PublicKey,
  instructions: TransactionInstruction[]
): Promise<string> {
  // Fetch lookup table
  const lookupTableAccount = await connection.getAddressLookupTable(lookupTableAddress);

  if (!lookupTableAccount.value) {
    throw new Error("Lookup table not found");
  }

  // Build message
  const { blockhash, lastValidBlockHeight } = await connection.getLatestBlockhash();

  const message = new TransactionMessage({
    payerKey: payer.publicKey,
    recentBlockhash: blockhash,
    instructions,
  }).compileToV0Message([lookupTableAccount.value]);

  // Create versioned transaction
  const transaction = new VersionedTransaction(message);
  transaction.sign([payer]);

  // Send
  const signature = await connection.sendTransaction(transaction);

  await connection.confirmTransaction({
    signature,
    blockhash,
    lastValidBlockHeight,
  });

  return signature;
}
```

### Transaction Simulation

```typescript
async function simulateBeforeSend(
  connection: Connection,
  transaction: Transaction,
  signers: Keypair[]
): Promise<{ success: boolean; logs: string[]; unitsConsumed: number }> {
  // Sign for simulation
  const { blockhash } = await connection.getLatestBlockhash();
  transaction.recentBlockhash = blockhash;
  transaction.feePayer = signers[0].publicKey;
  transaction.sign(...signers);

  // Simulate
  const simulation = await connection.simulateTransaction(transaction);

  if (simulation.value.err) {
    return {
      success: false,
      logs: simulation.value.logs || [],
      unitsConsumed: simulation.value.unitsConsumed || 0,
    };
  }

  return {
    success: true,
    logs: simulation.value.logs || [],
    unitsConsumed: simulation.value.unitsConsumed || 0,
  };
}

// Usage
const result = await simulateBeforeSend(connection, transaction, [payer]);
if (!result.success) {
  console.log("Simulation failed:", result.logs);
  // Decide whether to proceed
} else {
  console.log(`Will consume ${result.unitsConsumed} CUs`);
  // Safe to send
}
```

### Partial Signing

```typescript
// Multi-sig transaction
async function multiSigTransaction(
  connection: Connection,
  payer: Keypair,
  signer1: Keypair,
  signer2: Keypair
): Promise<string> {
  const transaction = new Transaction();

  transaction.add(
    new TransactionInstruction({
      keys: [
        { pubkey: payer.publicKey, isSigner: true, isWritable: true },
        { pubkey: signer1.publicKey, isSigner: true, isWritable: false },
        { pubkey: signer2.publicKey, isSigner: true, isWritable: false },
      ],
      programId: multiSigProgram,
      data: Buffer.alloc(0),
    })
  );

  const { blockhash } = await connection.getLatestBlockhash();
  transaction.recentBlockhash = blockhash;
  transaction.feePayer = payer.publicKey;

  // Partial signing - each signer signs independently
  transaction.partialSign(payer);
  transaction.partialSign(signer1);
  transaction.partialSign(signer2);

  // Now fully signed
  const signature = await connection.sendRawTransaction(transaction.serialize());

  return signature;
}
```

### Durable Nonces

```typescript
import { NONCE_ACCOUNT_LENGTH } from "@solana/web3.js";

// Create nonce account
async function createNonceAccount(
  connection: Connection,
  payer: Keypair
): Promise<PublicKey> {
  const nonceAccount = Keypair.generate();

  const transaction = new Transaction().add(
    SystemProgram.createAccount({
      fromPubkey: payer.publicKey,
      newAccountPubkey: nonceAccount.publicKey,
      lamports: await connection.getMinimumBalanceForRentExemption(NONCE_ACCOUNT_LENGTH),
      space: NONCE_ACCOUNT_LENGTH,
      programId: SystemProgram.programId,
    }),
    SystemProgram.nonceInitialize({
      noncePubkey: nonceAccount.publicKey,
      authorizedPubkey: payer.publicKey,
    })
  );

  await sendAndConfirmTransaction(connection, transaction, [payer, nonceAccount]);

  return nonceAccount.publicKey;
}

// Use nonce in transaction (survives blockhash expiration)
async function durableTransaction(
  connection: Connection,
  payer: Keypair,
  nonceAccount: PublicKey,
  instruction: TransactionInstruction
): Promise<Transaction> {
  const nonceInfo = await connection.getAccountInfo(nonceAccount);
  const nonce = /* parse nonce from account data */;

  const transaction = new Transaction();

  // Nonce advance MUST be first instruction
  transaction.add(
    SystemProgram.nonceAdvance({
      noncePubkey: nonceAccount,
      authorizedPubkey: payer.publicKey,
    })
  );

  transaction.add(instruction);

  // Use nonce instead of blockhash
  transaction.recentBlockhash = nonce;
  transaction.feePayer = payer.publicKey;

  return transaction;
}
```

### Transaction Batching

```typescript
// Send multiple independent transactions in parallel
async function batchTransactions(
  connection: Connection,
  transactions: { tx: Transaction; signers: Keypair[] }[]
): Promise<string[]> {
  // Prepare all transactions
  const { blockhash } = await connection.getLatestBlockhash();

  for (const { tx, signers } of transactions) {
    tx.recentBlockhash = blockhash;
    tx.feePayer = signers[0].publicKey;
    tx.sign(...signers);
  }

  // Send all in parallel
  const signatures = await Promise.all(
    transactions.map(({ tx }) =>
      connection.sendRawTransaction(tx.serialize())
    )
  );

  // Confirm all in parallel
  await Promise.all(
    signatures.map(sig => connection.confirmTransaction(sig))
  );

  return signatures;
}
```

---

## Common Patterns

### Retry with Backoff

```typescript
async function sendWithRetry(
  connection: Connection,
  transaction: Transaction,
  signers: Keypair[],
  options: {
    maxRetries?: number;
    initialBackoff?: number;
    maxBackoff?: number;
  } = {}
): Promise<string> {
  const { maxRetries = 3, initialBackoff = 500, maxBackoff = 5000 } = options;

  let lastError: Error | null = null;

  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      // Refresh blockhash on each attempt
      const { blockhash, lastValidBlockHeight } =
        await connection.getLatestBlockhash("finalized");

      transaction.recentBlockhash = blockhash;
      transaction.feePayer = signers[0].publicKey;
      transaction.sign(...signers);

      const signature = await connection.sendRawTransaction(
        transaction.serialize(),
        { skipPreflight: false, preflightCommitment: "confirmed" }
      );

      await connection.confirmTransaction({
        signature,
        blockhash,
        lastValidBlockHeight,
      });

      return signature;
    } catch (error) {
      lastError = error as Error;

      const backoff = Math.min(initialBackoff * Math.pow(2, attempt), maxBackoff);
      console.log(`Attempt ${attempt + 1} failed, retrying in ${backoff}ms`);
      await sleep(backoff);
    }
  }

  throw lastError;
}
```

### Transaction Size Check

```typescript
function checkTransactionSize(transaction: Transaction): {
  isValid: boolean;
  size: number;
  remaining: number;
} {
  const serialized = transaction.serialize({ requireAllSignatures: false });
  const size = serialized.length;
  const maxSize = 1232;

  return {
    isValid: size <= maxSize,
    size,
    remaining: maxSize - size,
  };
}
```

---

## Key Takeaways

1. **Structure matters** â€” header, signatures, keys, instructions
2. **Order instructions correctly** â€” compute budget first
3. **Use versioned transactions** â€” for more accounts via ALTs
4. **Simulate first** â€” catch errors before sending
5. **Handle blockhash expiration** â€” retry with fresh hash
6. **Partial signing** â€” for multi-sig scenarios
7. **Durable nonces** â€” for offline signing
8. **Batch when possible** â€” parallel independent transactions

---

## Next

Learn how to integrate wallets into your applications.

â†’ [5.4 Wallet Integration](./5.4-wallet-integration.md)
