# 5.4 Wallet Integration

> *"The wallet is the user's gateway to Web3 â€” make it seamless."*

---

## Why This Matters

Wallets are how users interact with your application. A smooth wallet integration can make or break user experience. Understanding wallet standards, adapter patterns, and common flows is essential for building user-friendly dApps.

---

## ğŸŸ¢ General Understanding

### Wallet Ecosystem

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Solana Wallet Ecosystem                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                      â”‚
â”‚   BROWSER EXTENSIONS                MOBILE WALLETS                  â”‚
â”‚   â”œâ”€â”€ Phantom                       â”œâ”€â”€ Phantom                     â”‚
â”‚   â”œâ”€â”€ Solflare                      â”œâ”€â”€ Solflare                    â”‚
â”‚   â”œâ”€â”€ Backpack                      â”œâ”€â”€ Glow                        â”‚
â”‚   â””â”€â”€ Brave Wallet                  â””â”€â”€ Phantom (in-app browser)   â”‚
â”‚                                                                      â”‚
â”‚   HARDWARE WALLETS                  EMBEDDED WALLETS                â”‚
â”‚   â”œâ”€â”€ Ledger                        â”œâ”€â”€ Magic Link                  â”‚
â”‚   â””â”€â”€ Trezor (limited)              â”œâ”€â”€ Web3Auth                   â”‚
â”‚                                      â””â”€â”€ Privy                      â”‚
â”‚                                                                      â”‚
â”‚   STANDARD: Solana Wallet Standard (SWS)                           â”‚
â”‚   ADAPTER: @solana/wallet-adapter                                   â”‚
â”‚                                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Wallet Capabilities

| Capability | Description |
|------------|-------------|
| **Connect** | Establish connection, get public key |
| **Sign Transaction** | Sign for execution |
| **Sign Message** | Sign arbitrary data (authentication) |
| **Sign All Transactions** | Batch signing |
| **Disconnect** | End session |

### Wallets Don't Hold Crypto

Wallets store **keys**, not coins. The blockchain is the ledger of balances.
Your wallet proves ownership by signing with a private key.

**Mental model:**
```
Blockchain = ledger
Wallet = keychain
Balance = entry on the ledger
```

If you lose the keys, you lose access. There is no password reset.

### Seed Phrases and Key Derivation

Most wallets generate a **seed phrase** (12-24 words) that can recreate all
of your accounts. One seed can derive many addresses using standard paths.

**Rules to teach users:**
- Never share the seed phrase or private key
- Store it offline and securely
- Treat it as full account access

---

## ğŸŸ¡ PM/EM Depth

### Wallet Security & Architecture

**Custody Models**

| Model | What It Means | Trade-offs |
|-------|---------------|------------|
| Self-custody (extension/mobile) | User controls the private key | Strong user control, higher user responsibility |
| Hardware wallet | Keys live on a dedicated device | Best isolation, slower UX |
| Embedded wallet (MPC/seedless) | Keys split or derived via provider | Easier onboarding, added trust in provider |

### Custody Decision Factors

| Question | Self-Custody | Embedded / Custodial |
|----------|--------------|----------------------|
| Recovery | User manages seed phrase | Provider handles recovery |
| Compliance | Minimal identity collection | KYC or account recovery flows |
| Support load | Higher (user errors) | Lower (provider tools) |
| UX speed | Slower onboarding | Faster onboarding |

Pick the model that matches your product's risk, support capacity, and user base.

**Security Expectations**
- Always show a clear transaction summary before signing.
- Prefer `signMessage` for authentication and bind it to your domain/app name.
- Avoid â€œblind signingâ€ flows unless the wallet explicitly supports it and the user understands.
- Provide a safe fallback if a wallet does not support a capability (e.g., `signMessage`).

Wallet capability standards are evolving; keep adapter dependencies current (as of [solana-labs/wallet-standard](https://github.com/solana-labs/wallet-standard)).

### Auth Flow (Mental Model)

```
Connect wallet â†’ Sign message â†’ Verify signature â†’ Create session
```

This avoids unnecessary transactions for login while still proving ownership.

### Wallet Adapter Setup

```bash
npm install @solana/wallet-adapter-react \
            @solana/wallet-adapter-react-ui \
            @solana/wallet-adapter-wallets \
            @solana/wallet-adapter-base
```

### Basic Integration

```tsx
// providers/WalletProvider.tsx
import { FC, ReactNode, useMemo } from "react";
import { ConnectionProvider, WalletProvider } from "@solana/wallet-adapter-react";
import { WalletModalProvider } from "@solana/wallet-adapter-react-ui";
import {
  PhantomWalletAdapter,
  SolflareWalletAdapter,
  BackpackWalletAdapter,
} from "@solana/wallet-adapter-wallets";

// Import wallet adapter styles
import "@solana/wallet-adapter-react-ui/styles.css";

interface Props {
  children: ReactNode;
}

export const WalletContextProvider: FC<Props> = ({ children }) => {
  const endpoint = process.env.NEXT_PUBLIC_RPC_URL!;

  const wallets = useMemo(() => [
    new PhantomWalletAdapter(),
    new SolflareWalletAdapter(),
    new BackpackWalletAdapter(),
  ], []);

  return (
    <ConnectionProvider endpoint={endpoint}>
      <WalletProvider wallets={wallets} autoConnect>
        <WalletModalProvider>
          {children}
        </WalletModalProvider>
      </WalletProvider>
    </ConnectionProvider>
  );
};
```

### Wrap Your App

```tsx
// pages/_app.tsx or app/layout.tsx
import { WalletContextProvider } from "../providers/WalletProvider";

function MyApp({ Component, pageProps }) {
  return (
    <WalletContextProvider>
      <Component {...pageProps} />
    </WalletContextProvider>
  );
}
```

---

## ğŸ”µ Engineer Depth

### Using Wallet Hooks

```tsx
import {
  useConnection,
  useWallet,
} from "@solana/wallet-adapter-react";
import { WalletMultiButton } from "@solana/wallet-adapter-react-ui";

function WalletStatus() {
  const { connection } = useConnection();
  const {
    publicKey,
    connected,
    connecting,
    disconnect,
    signTransaction,
    signAllTransactions,
    signMessage,
  } = useWallet();

  if (connecting) {
    return <div>Connecting...</div>;
  }

  if (!connected || !publicKey) {
    return <WalletMultiButton />;
  }

  return (
    <div>
      <p>Connected: {publicKey.toString()}</p>
      <button onClick={() => disconnect()}>Disconnect</button>
    </div>
  );
}
```

### Sign and Send Transaction

```tsx
import { useConnection, useWallet } from "@solana/wallet-adapter-react";
import { Transaction, SystemProgram, LAMPORTS_PER_SOL } from "@solana/web3.js";

function SendSolButton({ recipient }: { recipient: PublicKey }) {
  const { connection } = useConnection();
  const { publicKey, sendTransaction } = useWallet();

  const handleSend = async () => {
    if (!publicKey) {
      alert("Connect wallet first");
      return;
    }

    try {
      const transaction = new Transaction().add(
        SystemProgram.transfer({
          fromPubkey: publicKey,
          toPubkey: recipient,
          lamports: 0.1 * LAMPORTS_PER_SOL,
        })
      );

      const { blockhash, lastValidBlockHeight } =
        await connection.getLatestBlockhash();

      transaction.recentBlockhash = blockhash;
      transaction.feePayer = publicKey;

      // Wallet signs and sends
      const signature = await sendTransaction(transaction, connection);

      // Confirm
      await connection.confirmTransaction({
        signature,
        blockhash,
        lastValidBlockHeight,
      });

      console.log("Success:", signature);
    } catch (error) {
      console.error("Error:", error);
    }
  };

  return (
    <button onClick={handleSend} disabled={!publicKey}>
      Send 0.1 SOL
    </button>
  );
}
```

### Security Checklist for Wallet Flows

```
1. Confirm wallet supports required capabilities (signMessage, signTransaction).
2. Display readable transaction summaries (recipient, amount, program IDs).
3. Simulate transactions before sending when possible.
4. Use allowlists for known program IDs in critical flows.
5. Log signature + RPC endpoint for support/debugging.
```

### Sign Message (Authentication)

```tsx
function SignInButton() {
  const { publicKey, signMessage } = useWallet();

  const handleSignIn = async () => {
    if (!publicKey || !signMessage) {
      return;
    }

    try {
      // Create message
      const message = new TextEncoder().encode(
        `Sign in to MyApp\n\nWallet: ${publicKey.toString()}\nNonce: ${Date.now()}`
      );

      // Request signature
      const signature = await signMessage(message);

      // Send to backend for verification
      const response = await fetch("/api/auth/verify", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          publicKey: publicKey.toString(),
          message: Array.from(message),
          signature: Array.from(signature),
        }),
      });

      if (response.ok) {
        console.log("Authenticated!");
      }
    } catch (error) {
      console.error("Sign in failed:", error);
    }
  };

  return (
    <button onClick={handleSignIn} disabled={!publicKey}>
      Sign In
    </button>
  );
}
```

### Verify Signature (Backend)

```typescript
// api/auth/verify.ts
import { PublicKey } from "@solana/web3.js";
import nacl from "tweetnacl";

export async function POST(request: Request) {
  const { publicKey, message, signature } = await request.json();

  try {
    const pubkey = new PublicKey(publicKey);
    const messageBytes = new Uint8Array(message);
    const signatureBytes = new Uint8Array(signature);

    const isValid = nacl.sign.detached.verify(
      messageBytes,
      signatureBytes,
      pubkey.toBytes()
    );

    if (isValid) {
      // Create session, JWT, etc.
      return Response.json({ success: true });
    }

    return Response.json({ error: "Invalid signature" }, { status: 401 });
  } catch (error) {
    return Response.json({ error: "Verification failed" }, { status: 400 });
  }
}
```

### With Anchor Program

```tsx
import { useAnchorWallet, useConnection } from "@solana/wallet-adapter-react";
import { AnchorProvider, Program } from "@coral-xyz/anchor";

function useAnchorProgram() {
  const { connection } = useConnection();
  const wallet = useAnchorWallet();

  const program = useMemo(() => {
    if (!wallet) return null;

    const provider = new AnchorProvider(
      connection,
      wallet,
      { commitment: "confirmed" }
    );

    return new Program(IDL, PROGRAM_ID, provider);
  }, [connection, wallet]);

  return program;
}

function DepositButton() {
  const program = useAnchorProgram();
  const wallet = useWallet();

  const handleDeposit = async () => {
    if (!program || !wallet.publicKey) return;

    try {
      const tx = await program.methods
        .deposit(new BN(1000))
        .accounts({
          user: wallet.publicKey,
          vault: vaultPda,
          systemProgram: SystemProgram.programId,
        })
        .rpc();

      console.log("Deposited:", tx);
    } catch (error) {
      console.error("Deposit failed:", error);
    }
  };

  return <button onClick={handleDeposit}>Deposit</button>;
}
```

### Custom Wallet Button

```tsx
import { useWallet } from "@solana/wallet-adapter-react";
import { useWalletModal } from "@solana/wallet-adapter-react-ui";

function CustomWalletButton() {
  const { publicKey, disconnect, connecting, connected } = useWallet();
  const { setVisible } = useWalletModal();

  if (connecting) {
    return <button disabled>Connecting...</button>;
  }

  if (!connected) {
    return (
      <button onClick={() => setVisible(true)}>
        Connect Wallet
      </button>
    );
  }

  return (
    <div className="flex gap-2">
      <span className="truncate max-w-[100px]">
        {publicKey?.toString()}
      </span>
      <button onClick={() => disconnect()}>
        Disconnect
      </button>
    </div>
  );
}
```

### Handle Wallet Events

```tsx
import { useWallet } from "@solana/wallet-adapter-react";
import { useEffect } from "react";

function WalletEventHandler() {
  const { publicKey, connected, wallet } = useWallet();

  useEffect(() => {
    if (connected && publicKey) {
      console.log("Wallet connected:", publicKey.toString());

      // Track analytics
      analytics.track("wallet_connected", {
        wallet: wallet?.adapter.name,
        address: publicKey.toString(),
      });
    }
  }, [connected, publicKey, wallet]);

  useEffect(() => {
    const handleAccountChange = () => {
      console.log("Account changed!");
      // Refresh user data
    };

    wallet?.adapter.on("connect", handleAccountChange);
    wallet?.adapter.on("disconnect", () => console.log("Disconnected"));

    return () => {
      wallet?.adapter.off("connect", handleAccountChange);
    };
  }, [wallet]);

  return null;
}
```

### Mobile Wallet Adapter

```tsx
// For mobile dApps
import { transact } from "@solana-mobile/mobile-wallet-adapter-protocol";

async function mobileSign(transaction: Transaction) {
  const result = await transact(async (wallet) => {
    // Authorize
    const auth = await wallet.authorize({
      cluster: "devnet",
      identity: {
        name: "My App",
        uri: "https://myapp.com",
        icon: "icon.png",
      },
    });

    // Sign
    const signedTx = await wallet.signTransactions({
      transactions: [transaction],
    });

    return signedTx;
  });

  return result;
}
```

---

## Common Patterns

### Auto-Connect with Persistence

```tsx
// The adapter handles this with autoConnect prop
<WalletProvider wallets={wallets} autoConnect>

// For custom logic:
function useAutoConnect() {
  const { wallet, connect, connected } = useWallet();

  useEffect(() => {
    const lastWallet = localStorage.getItem("lastWallet");

    if (lastWallet && wallet?.adapter.name === lastWallet && !connected) {
      connect().catch(() => {
        localStorage.removeItem("lastWallet");
      });
    }
  }, [wallet, connect, connected]);

  useEffect(() => {
    if (connected && wallet) {
      localStorage.setItem("lastWallet", wallet.adapter.name);
    }
  }, [connected, wallet]);
}
```

### Network Switching

```tsx
function NetworkSwitcher() {
  const { connection } = useConnection();
  const [network, setNetwork] = useState("mainnet-beta");

  // Note: This requires custom implementation
  // The ConnectionProvider endpoint must be dynamic

  return (
    <select value={network} onChange={(e) => setNetwork(e.target.value)}>
      <option value="mainnet-beta">Mainnet</option>
      <option value="devnet">Devnet</option>
      <option value="testnet">Testnet</option>
    </select>
  );
}
```

### Wallet Balance Display

```tsx
function WalletBalance() {
  const { connection } = useConnection();
  const { publicKey } = useWallet();
  const [balance, setBalance] = useState<number | null>(null);

  useEffect(() => {
    if (!publicKey) {
      setBalance(null);
      return;
    }

    const fetchBalance = async () => {
      const lamports = await connection.getBalance(publicKey);
      setBalance(lamports / LAMPORTS_PER_SOL);
    };

    fetchBalance();

    // Subscribe to changes
    const subscriptionId = connection.onAccountChange(
      publicKey,
      (accountInfo) => {
        setBalance(accountInfo.lamports / LAMPORTS_PER_SOL);
      }
    );

    return () => {
      connection.removeAccountChangeListener(subscriptionId);
    };
  }, [connection, publicKey]);

  if (balance === null) return null;

  return <span>{balance.toFixed(4)} SOL</span>;
}
```

---

## Key Takeaways

1. **Use wallet-adapter** â€” standard integration library
2. **Multiple wallet support** â€” don't lock users in
3. **Auto-connect** â€” improve returning user experience
4. **Sign messages for auth** â€” don't require transactions
5. **Handle errors gracefully** â€” user rejections, timeouts
6. **Show transaction status** â€” feedback during async operations
7. **Mobile support** â€” use mobile wallet adapter
8. **Test with multiple wallets** â€” behavior varies

---

## Next

Learn about frontend frameworks and patterns for Solana dApps.

â†’ [5.5 Frontend Frameworks](./5.5-frontend-frameworks.md)
