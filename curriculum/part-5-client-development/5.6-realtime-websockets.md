# 5.6 Real-time Data & WebSockets

> *"In DeFi, stale data means lost money. Real-time updates are not optional."*

---

## Why This Matters

Blockchain state changes constantly â€” prices move, balances update, transactions confirm. Users expect real-time updates without refreshing. Understanding WebSocket subscriptions and efficient polling strategies is essential for building responsive dApps.

---

## ğŸŸ¢ General Understanding

### Real-time Data Sources

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Real-time Data Options                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                      â”‚
â”‚   WEBSOCKET SUBSCRIPTIONS                                           â”‚
â”‚   â”œâ”€â”€ Account changes                                               â”‚
â”‚   â”œâ”€â”€ Program account changes                                       â”‚
â”‚   â”œâ”€â”€ Transaction logs                                              â”‚
â”‚   â”œâ”€â”€ Slot updates                                                  â”‚
â”‚   â””â”€â”€ Signature status                                              â”‚
â”‚                                                                      â”‚
â”‚   POLLING                                                           â”‚
â”‚   â”œâ”€â”€ getAccountInfo                                                â”‚
â”‚   â”œâ”€â”€ getBalance                                                    â”‚
â”‚   â””â”€â”€ Custom intervals                                              â”‚
â”‚                                                                      â”‚
â”‚   THIRD-PARTY                                                       â”‚
â”‚   â”œâ”€â”€ Helius Webhooks                                               â”‚
â”‚   â”œâ”€â”€ Triton Streams                                                â”‚
â”‚   â””â”€â”€ Geyser Plugins                                                â”‚
â”‚                                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### When to Use What

| Method | Best For | Latency |
|--------|----------|---------|
| WebSocket | User's own account, live prices | ~400ms |
| Polling | Non-critical data, fallback | 1-30s |
| Webhooks | Server-side, many accounts | Varies |
| Geyser | High-volume indexing | Near-instant |

---

## ğŸŸ¡ PM/EM Depth

### WebSocket Subscriptions

```typescript
// Available subscription types
connection.onAccountChange(publicKey, callback);      // Single account
connection.onProgramAccountChange(programId, callback); // All program accounts
connection.onLogs(address, callback);                 // Transaction logs
connection.onSlotChange(callback);                    // New slots
connection.onSignature(signature, callback);          // Tx confirmation
connection.onRootChange(callback);                    // Finalized slots
```

### Connection Configuration

```typescript
const connection = new Connection(
  "https://api.mainnet-beta.solana.com",
  {
    commitment: "confirmed",
    wsEndpoint: "wss://api.mainnet-beta.solana.com",
    confirmTransactionInitialTimeout: 60000,
  }
);
```

---

## ğŸ”µ Engineer Depth

### Account Subscription Hook

```tsx
// lib/hooks/useAccountSubscription.ts
import { useEffect, useState, useCallback } from "react";
import { useConnection } from "@solana/wallet-adapter-react";
import { PublicKey, AccountInfo } from "@solana/web3.js";

interface UseAccountSubscriptionOptions {
  commitment?: "processed" | "confirmed" | "finalized";
  enabled?: boolean;
}

export function useAccountSubscription<T>(
  address: PublicKey | null,
  deserialize: (data: Buffer) => T,
  options: UseAccountSubscriptionOptions = {}
) {
  const { connection } = useConnection();
  const [data, setData] = useState<T | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  const { commitment = "confirmed", enabled = true } = options;

  // Initial fetch
  const fetchData = useCallback(async () => {
    if (!address || !enabled) return;

    try {
      setLoading(true);
      const accountInfo = await connection.getAccountInfo(address, commitment);

      if (accountInfo) {
        setData(deserialize(accountInfo.data));
      } else {
        setData(null);
      }
      setError(null);
    } catch (err) {
      setError(err as Error);
    } finally {
      setLoading(false);
    }
  }, [connection, address, deserialize, commitment, enabled]);

  useEffect(() => {
    fetchData();
  }, [fetchData]);

  // Subscribe to changes
  useEffect(() => {
    if (!address || !enabled) return;

    const subscriptionId = connection.onAccountChange(
      address,
      (accountInfo: AccountInfo<Buffer>) => {
        try {
          setData(deserialize(accountInfo.data));
          setError(null);
        } catch (err) {
          setError(err as Error);
        }
      },
      commitment
    );

    return () => {
      connection.removeAccountChangeListener(subscriptionId);
    };
  }, [connection, address, deserialize, commitment, enabled]);

  return { data, loading, error, refetch: fetchData };
}

// Usage
function BalanceDisplay({ address }: { address: PublicKey }) {
  const { data: balance } = useAccountSubscription(
    address,
    (buffer) => {
      // Parse lamports from account data
      return buffer.readBigUInt64LE(0);
    }
  );

  return <span>{balance ? formatSol(Number(balance)) : "..."}</span>;
}
```

### Program Account Subscription

```tsx
// lib/hooks/useProgramAccounts.ts
import { useEffect, useState } from "react";
import { useConnection } from "@solana/wallet-adapter-react";
import { PublicKey, GetProgramAccountsFilter } from "@solana/web3.js";

interface AccountWithPubkey<T> {
  pubkey: PublicKey;
  data: T;
}

export function useProgramAccountsSubscription<T>(
  programId: PublicKey,
  deserialize: (data: Buffer) => T,
  filters?: GetProgramAccountsFilter[]
) {
  const { connection } = useConnection();
  const [accounts, setAccounts] = useState<AccountWithPubkey<T>[]>([]);
  const [loading, setLoading] = useState(true);

  // Initial fetch
  useEffect(() => {
    const fetchAccounts = async () => {
      setLoading(true);
      try {
        const programAccounts = await connection.getProgramAccounts(programId, {
          filters,
          commitment: "confirmed",
        });

        setAccounts(
          programAccounts.map((acc) => ({
            pubkey: acc.pubkey,
            data: deserialize(acc.account.data),
          }))
        );
      } catch (error) {
        console.error("Error fetching program accounts:", error);
      } finally {
        setLoading(false);
      }
    };

    fetchAccounts();
  }, [connection, programId, filters, deserialize]);

  // Subscribe to changes
  useEffect(() => {
    const subscriptionId = connection.onProgramAccountChange(
      programId,
      (keyedAccountInfo) => {
        const { accountId, accountInfo } = keyedAccountInfo;

        setAccounts((prev) => {
          const index = prev.findIndex((acc) =>
            acc.pubkey.equals(accountId)
          );

          const newAccount = {
            pubkey: accountId,
            data: deserialize(accountInfo.data),
          };

          if (index >= 0) {
            // Update existing
            const updated = [...prev];
            updated[index] = newAccount;
            return updated;
          } else {
            // Add new
            return [...prev, newAccount];
          }
        });
      },
      "confirmed",
      filters
    );

    return () => {
      connection.removeProgramAccountChangeListener(subscriptionId);
    };
  }, [connection, programId, filters, deserialize]);

  return { accounts, loading };
}
```

### Transaction Logs Subscription

```tsx
// lib/hooks/useTransactionLogs.ts
import { useEffect, useState } from "react";
import { useConnection } from "@solana/wallet-adapter-react";
import { PublicKey, Logs } from "@solana/web3.js";

interface TransactionLog {
  signature: string;
  logs: string[];
  timestamp: number;
}

export function useTransactionLogs(address: PublicKey | null) {
  const { connection } = useConnection();
  const [logs, setLogs] = useState<TransactionLog[]>([]);

  useEffect(() => {
    if (!address) return;

    const subscriptionId = connection.onLogs(
      address,
      (logsInfo: Logs) => {
        if (logsInfo.err) return; // Skip failed transactions

        setLogs((prev) => [
          {
            signature: logsInfo.signature,
            logs: logsInfo.logs,
            timestamp: Date.now(),
          },
          ...prev.slice(0, 99), // Keep last 100
        ]);
      },
      "confirmed"
    );

    return () => {
      connection.removeOnLogsListener(subscriptionId);
    };
  }, [connection, address]);

  return logs;
}

// Usage: Activity feed
function ActivityFeed() {
  const { publicKey } = useWallet();
  const logs = useTransactionLogs(publicKey);

  return (
    <div className="space-y-2">
      <h3>Recent Activity</h3>
      {logs.map((log) => (
        <div key={log.signature} className="p-2 bg-gray-800 rounded">
          <p className="font-mono text-sm truncate">{log.signature}</p>
          <p className="text-xs text-gray-400">
            {new Date(log.timestamp).toLocaleTimeString()}
          </p>
        </div>
      ))}
    </div>
  );
}
```

### Slot/Block Subscription

```tsx
// lib/hooks/useSlotInfo.ts
import { useEffect, useState } from "react";
import { useConnection } from "@solana/wallet-adapter-react";

interface SlotInfo {
  slot: number;
  parent: number;
  root: number;
}

export function useSlotInfo() {
  const { connection } = useConnection();
  const [slotInfo, setSlotInfo] = useState<SlotInfo | null>(null);

  useEffect(() => {
    const subscriptionId = connection.onSlotChange((slot) => {
      setSlotInfo({
        slot: slot.slot,
        parent: slot.parent,
        root: slot.root,
      });
    });

    return () => {
      connection.removeSlotChangeListener(subscriptionId);
    };
  }, [connection]);

  return slotInfo;
}

// Display live slot
function SlotDisplay() {
  const slotInfo = useSlotInfo();

  return (
    <div className="flex items-center gap-2">
      <div className="w-2 h-2 bg-green-500 rounded-full animate-pulse" />
      <span>Slot: {slotInfo?.slot ?? "..."}</span>
    </div>
  );
}
```

### Transaction Confirmation Subscription

```tsx
// lib/hooks/useTransactionConfirmation.ts
import { useEffect, useState } from "react";
import { useConnection } from "@solana/wallet-adapter-react";
import { TransactionSignature } from "@solana/web3.js";

type ConfirmationStatus = "pending" | "confirmed" | "finalized" | "error";

export function useTransactionConfirmation(signature: TransactionSignature | null) {
  const { connection } = useConnection();
  const [status, setStatus] = useState<ConfirmationStatus>("pending");
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (!signature) return;

    setStatus("pending");
    setError(null);

    const subscriptionId = connection.onSignature(
      signature,
      (result, context) => {
        if (result.err) {
          setStatus("error");
          setError(JSON.stringify(result.err));
        } else {
          setStatus("confirmed");
        }
      },
      "confirmed"
    );

    // Also subscribe for finalization
    const finalizedSubId = connection.onSignature(
      signature,
      (result) => {
        if (!result.err) {
          setStatus("finalized");
        }
      },
      "finalized"
    );

    return () => {
      connection.removeSignatureListener(subscriptionId);
      connection.removeSignatureListener(finalizedSubId);
    };
  }, [connection, signature]);

  return { status, error };
}
```

### Polling Fallback

```tsx
// lib/hooks/usePolling.ts
import { useEffect, useCallback, useRef } from "react";

interface UsePollingOptions {
  interval: number;
  enabled?: boolean;
  immediate?: boolean;
}

export function usePolling(
  callback: () => Promise<void>,
  options: UsePollingOptions
) {
  const { interval, enabled = true, immediate = true } = options;
  const savedCallback = useRef(callback);

  useEffect(() => {
    savedCallback.current = callback;
  }, [callback]);

  useEffect(() => {
    if (!enabled) return;

    const tick = async () => {
      try {
        await savedCallback.current();
      } catch (error) {
        console.error("Polling error:", error);
      }
    };

    if (immediate) {
      tick();
    }

    const id = setInterval(tick, interval);
    return () => clearInterval(id);
  }, [interval, enabled, immediate]);
}

// Usage with hybrid approach
function HybridPriceDisplay() {
  const [price, setPrice] = useState<number>(0);
  const [wsConnected, setWsConnected] = useState(true);

  // WebSocket subscription (primary)
  useEffect(() => {
    const ws = new WebSocket("wss://price-feed.example.com");

    ws.onmessage = (event) => {
      setPrice(JSON.parse(event.data).price);
    };

    ws.onclose = () => setWsConnected(false);
    ws.onopen = () => setWsConnected(true);

    return () => ws.close();
  }, []);

  // Polling fallback (when WS disconnected)
  usePolling(
    async () => {
      const response = await fetch("/api/price");
      const data = await response.json();
      setPrice(data.price);
    },
    {
      interval: 5000,
      enabled: !wsConnected, // Only poll when WS is down
    }
  );

  return (
    <div className="flex items-center gap-2">
      <span>${price.toFixed(2)}</span>
      {!wsConnected && <span className="text-yellow-500 text-xs">Polling</span>}
    </div>
  );
}
```

### Helius Webhooks

```typescript
// Server-side webhook handler
// app/api/webhooks/helius/route.ts
import { NextRequest, NextResponse } from "next/server";

interface HeliusWebhookPayload {
  accountData: {
    account: string;
    nativeBalanceChange: number;
    tokenBalanceChanges: any[];
  }[];
  signature: string;
  type: string;
}

export async function POST(request: NextRequest) {
  // Verify webhook signature (recommended)
  const authHeader = request.headers.get("authorization");
  if (authHeader !== `Bearer ${process.env.HELIUS_WEBHOOK_SECRET}`) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  const payload: HeliusWebhookPayload = await request.json();

  // Process the webhook
  for (const account of payload.accountData) {
    console.log(`Account ${account.account} changed`);

    // Update your database, send notifications, etc.
    await updateAccountCache(account);
    await notifyUserIfNeeded(account);
  }

  return NextResponse.json({ received: true });
}
```

### EventEmitter Pattern

```tsx
// lib/events.ts
import { EventEmitter } from "events";

export const solanaEvents = new EventEmitter();

// In your subscription hook
connection.onAccountChange(address, (accountInfo) => {
  solanaEvents.emit("accountChange", { address, accountInfo });
});

// Subscribe anywhere in app
solanaEvents.on("accountChange", ({ address, accountInfo }) => {
  console.log(`Account ${address} updated`);
});
```

---

## Common Patterns

### Reconnection Logic

```typescript
class WebSocketManager {
  private ws: WebSocket | null = null;
  private reconnectAttempts = 0;
  private maxReconnectAttempts = 5;
  private reconnectDelay = 1000;

  connect(url: string, onMessage: (data: any) => void) {
    this.ws = new WebSocket(url);

    this.ws.onopen = () => {
      console.log("WebSocket connected");
      this.reconnectAttempts = 0;
    };

    this.ws.onmessage = (event) => {
      onMessage(JSON.parse(event.data));
    };

    this.ws.onclose = () => {
      this.handleReconnect(url, onMessage);
    };

    this.ws.onerror = (error) => {
      console.error("WebSocket error:", error);
    };
  }

  private handleReconnect(url: string, onMessage: (data: any) => void) {
    if (this.reconnectAttempts >= this.maxReconnectAttempts) {
      console.error("Max reconnection attempts reached");
      return;
    }

    this.reconnectAttempts++;
    const delay = this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1);

    console.log(`Reconnecting in ${delay}ms (attempt ${this.reconnectAttempts})`);

    setTimeout(() => {
      this.connect(url, onMessage);
    }, delay);
  }

  disconnect() {
    this.ws?.close();
  }
}
```

### Rate Limiting

```typescript
function throttle<T extends (...args: any[]) => void>(
  func: T,
  limit: number
): T {
  let inThrottle: boolean;

  return ((...args: any[]) => {
    if (!inThrottle) {
      func.apply(this, args);
      inThrottle = true;
      setTimeout(() => (inThrottle = false), limit);
    }
  }) as T;
}

// Usage: Throttle account updates to max 2 per second
const handleAccountChange = throttle((accountInfo) => {
  updateUI(accountInfo);
}, 500);
```

---

## Key Takeaways

1. **WebSockets for user accounts** â€” real-time balance, activity
2. **Polling as fallback** â€” when WS fails or for non-critical data
3. **Unsubscribe on cleanup** â€” prevent memory leaks
4. **Handle reconnection** â€” networks are unreliable
5. **Throttle UI updates** â€” don't overwhelm React
6. **Use webhooks server-side** â€” scale to many accounts
7. **Commitment levels matter** â€” processed vs confirmed vs finalized
8. **Hybrid approach** â€” best reliability

---

## End of Part 5 (Almost)

You now know how to:
- Structure Solana client applications
- Use @solana/web3.js effectively
- Build transactions for various scenarios
- Integrate wallets seamlessly
- Build production frontends
- Handle real-time data

**Next: User Experience & Transaction Friction**

â†’ [5.7 User Experience & Transaction Friction](./5.7-user-experience-friction.md)
