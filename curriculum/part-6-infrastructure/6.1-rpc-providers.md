# 6.1 RPC Providers

> *"Your RPC provider is your gateway to Solana â€” choose wisely."*

---

## Why This Matters

RPC (Remote Procedure Call) providers are how your applications communicate with the Solana network. The choice of provider, configuration, and architecture directly impacts your application's performance, reliability, and cost.

---

## ğŸŸ¢ General Understanding

### What is an RPC Provider?

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      RPC Communication Flow                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                      â”‚
â”‚   Your App                  RPC Provider              Solana Network â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚   â”‚      â”‚  â”€â”€JSON-RPCâ”€â”€â–¶   â”‚          â”‚  â”€â”€gossipâ”€â”€â–¶ â”‚          â”‚  â”‚
â”‚   â”‚ dApp â”‚                  â”‚  Node    â”‚              â”‚  Cluster â”‚  â”‚
â”‚   â”‚      â”‚  â—€â”€â”€responseâ”€â”€   â”‚          â”‚  â—€â”€â”€votesâ”€â”€  â”‚          â”‚  â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”˜                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                      â”‚
â”‚   WHAT IT DOES:                                                     â”‚
â”‚   â€¢ Submits transactions to the network                             â”‚
â”‚   â€¢ Queries account data and balances                               â”‚
â”‚   â€¢ Subscribes to real-time updates                                 â”‚
â”‚   â€¢ Fetches historical transaction data                             â”‚
â”‚                                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Provider Landscape

| Provider | Type | Best For |
|----------|------|----------|
| **Public RPCs** | Free, rate-limited | Development, testing |
| **Helius** | Premium | Production, webhooks, enhanced APIs |
| **QuickNode** | Premium | Multi-chain, enterprise |
| **Alchemy** | Premium | Developer tools, reliability |
| **Triton** | Premium | High performance, DeFi |
| **Self-hosted** | Own infrastructure | Maximum control, privacy |

---

## ğŸŸ¡ PM/EM Depth

### Provider Selection Criteria

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    RPC Provider Evaluation Matrix                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                      â”‚
â”‚   PERFORMANCE                      RELIABILITY                       â”‚
â”‚   â”œâ”€â”€ Latency (p50, p99)           â”œâ”€â”€ Uptime SLA                   â”‚
â”‚   â”œâ”€â”€ Throughput (req/sec)         â”œâ”€â”€ Geographic redundancy        â”‚
â”‚   â”œâ”€â”€ WebSocket stability          â””â”€â”€ Failover capabilities        â”‚
â”‚   â””â”€â”€ Response time                                                  â”‚
â”‚                                                                      â”‚
â”‚   FEATURES                         COST                              â”‚
â”‚   â”œâ”€â”€ Enhanced APIs                â”œâ”€â”€ Requests included            â”‚
â”‚   â”œâ”€â”€ Webhooks                     â”œâ”€â”€ Overage pricing              â”‚
â”‚   â”œâ”€â”€ Historical data              â”œâ”€â”€ WebSocket connections        â”‚
â”‚   â””â”€â”€ Priority transactions        â””â”€â”€ Support tier                 â”‚
â”‚                                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Cost Considerations

| Usage Pattern | Monthly Volume | Recommended Tier |
|--------------|----------------|------------------|
| Development | < 100K requests | Free tier |
| Early startup | 100K - 10M | Starter ($50-200/mo) |
| Growing app | 10M - 100M | Growth ($200-1000/mo) |
| High scale | 100M+ | Enterprise (custom) |

### Public vs Private RPCs

| Aspect | Public (Free) | Private (Paid) |
|--------|---------------|----------------|
| Rate limits | Strict (10-40 req/s) | High/custom |
| Reliability | Best effort | SLA guaranteed |
| Support | None | 24/7 available |
| Features | Basic RPC | Enhanced APIs |
| Latency | Variable | Optimized |

---

## ğŸ”µ Engineer Depth

### Basic Connection Setup

```typescript
import { Connection, clusterApiUrl } from "@solana/web3.js";

// Public endpoint (development only)
const publicConnection = new Connection(clusterApiUrl("devnet"));

// Private RPC provider
const privateConnection = new Connection(
  "https://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY",
  {
    commitment: "confirmed",
    wsEndpoint: "wss://mainnet.helius-rpc.com/?api-key=YOUR_API_KEY",
  }
);

// With full configuration
const connection = new Connection(
  process.env.RPC_URL!,
  {
    commitment: "confirmed",
    confirmTransactionInitialTimeout: 60000,
    httpHeaders: {
      "Authorization": `Bearer ${process.env.RPC_AUTH_TOKEN}`,
    },
    fetch: customFetchWithRetry, // Custom fetch implementation
  }
);
```

### Multi-Provider Failover

```typescript
interface RPCProvider {
  url: string;
  wsUrl?: string;
  weight: number;
  maxRetries: number;
}

class RobustConnection {
  private providers: RPCProvider[];
  private currentIndex = 0;
  private connections: Map<string, Connection> = new Map();

  constructor(providers: RPCProvider[]) {
    this.providers = providers;

    // Pre-create connections
    for (const provider of providers) {
      this.connections.set(
        provider.url,
        new Connection(provider.url, "confirmed")
      );
    }
  }

  async execute<T>(
    operation: (connection: Connection) => Promise<T>
  ): Promise<T> {
    let lastError: Error | null = null;

    for (let i = 0; i < this.providers.length; i++) {
      const provider = this.providers[(this.currentIndex + i) % this.providers.length];
      const connection = this.connections.get(provider.url)!;

      for (let retry = 0; retry < provider.maxRetries; retry++) {
        try {
          const result = await operation(connection);
          return result;
        } catch (error) {
          lastError = error as Error;

          // Check if error is retryable
          if (this.isRetryable(error)) {
            await this.delay(Math.pow(2, retry) * 100);
            continue;
          }
          break;
        }
      }

      // Move to next provider
      this.currentIndex = (this.currentIndex + 1) % this.providers.length;
    }

    throw lastError || new Error("All providers failed");
  }

  private isRetryable(error: any): boolean {
    const retryableCodes = [429, 502, 503, 504];
    return retryableCodes.includes(error?.status) ||
           error?.message?.includes("rate limit") ||
           error?.message?.includes("timeout");
  }

  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

// Usage
const robustRpc = new RobustConnection([
  { url: "https://primary.helius-rpc.com", weight: 1, maxRetries: 3 },
  { url: "https://backup.quicknode.com", weight: 0.5, maxRetries: 2 },
  { url: "https://fallback.alchemy.com", weight: 0.3, maxRetries: 1 },
]);

const balance = await robustRpc.execute(
  (conn) => conn.getBalance(publicKey)
);
```

### Request Batching

```typescript
class BatchedRPC {
  private connection: Connection;
  private batchQueue: Array<{
    method: string;
    params: any[];
    resolve: (value: any) => void;
    reject: (error: any) => void;
  }> = [];
  private batchTimeout: NodeJS.Timeout | null = null;
  private batchSize = 100;
  private batchDelay = 50; // ms

  constructor(connection: Connection) {
    this.connection = connection;
  }

  async request(method: string, params: any[]): Promise<any> {
    return new Promise((resolve, reject) => {
      this.batchQueue.push({ method, params, resolve, reject });

      if (this.batchQueue.length >= this.batchSize) {
        this.flush();
      } else if (!this.batchTimeout) {
        this.batchTimeout = setTimeout(() => this.flush(), this.batchDelay);
      }
    });
  }

  private async flush(): Promise<void> {
    if (this.batchTimeout) {
      clearTimeout(this.batchTimeout);
      this.batchTimeout = null;
    }

    const batch = this.batchQueue.splice(0, this.batchSize);
    if (batch.length === 0) return;

    try {
      // Build JSON-RPC batch request
      const requests = batch.map((req, index) => ({
        jsonrpc: "2.0",
        id: index,
        method: req.method,
        params: req.params,
      }));

      const response = await fetch(this.connection.rpcEndpoint, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(requests),
      });

      const results = await response.json();

      // Resolve individual promises
      for (const result of results) {
        const request = batch[result.id];
        if (result.error) {
          request.reject(new Error(result.error.message));
        } else {
          request.resolve(result.result);
        }
      }
    } catch (error) {
      // Reject all pending requests
      for (const request of batch) {
        request.reject(error);
      }
    }
  }
}

// Usage
const batchedRpc = new BatchedRPC(connection);

// These will be batched together
const [balance1, balance2, balance3] = await Promise.all([
  batchedRpc.request("getBalance", [pubkey1.toString()]),
  batchedRpc.request("getBalance", [pubkey2.toString()]),
  batchedRpc.request("getBalance", [pubkey3.toString()]),
]);
```

### Rate Limiting

```typescript
class RateLimitedConnection {
  private connection: Connection;
  private requestsPerSecond: number;
  private queue: Array<() => Promise<void>> = [];
  private processing = false;
  private lastRequestTime = 0;

  constructor(connection: Connection, requestsPerSecond = 40) {
    this.connection = connection;
    this.requestsPerSecond = requestsPerSecond;
  }

  async throttled<T>(operation: () => Promise<T>): Promise<T> {
    return new Promise((resolve, reject) => {
      this.queue.push(async () => {
        try {
          const result = await operation();
          resolve(result);
        } catch (error) {
          reject(error);
        }
      });

      this.processQueue();
    });
  }

  private async processQueue(): Promise<void> {
    if (this.processing || this.queue.length === 0) return;

    this.processing = true;

    while (this.queue.length > 0) {
      const now = Date.now();
      const minInterval = 1000 / this.requestsPerSecond;
      const elapsed = now - this.lastRequestTime;

      if (elapsed < minInterval) {
        await new Promise(r => setTimeout(r, minInterval - elapsed));
      }

      const operation = this.queue.shift();
      if (operation) {
        this.lastRequestTime = Date.now();
        await operation();
      }
    }

    this.processing = false;
  }

  // Wrapped methods
  async getBalance(pubkey: PublicKey): Promise<number> {
    return this.throttled(() => this.connection.getBalance(pubkey));
  }

  async getAccountInfo(pubkey: PublicKey): Promise<AccountInfo<Buffer> | null> {
    return this.throttled(() => this.connection.getAccountInfo(pubkey));
  }
}
```

### Enhanced APIs (Helius Example)

```typescript
// Helius Enhanced APIs
const HELIUS_API_KEY = process.env.HELIUS_API_KEY;

// Get parsed transaction history
async function getTransactionHistory(address: string) {
  const response = await fetch(
    `https://api.helius.xyz/v0/addresses/${address}/transactions?api-key=${HELIUS_API_KEY}`
  );
  return response.json();
}

// Get token balances with metadata
async function getTokenBalances(address: string) {
  const response = await fetch(
    `https://api.helius.xyz/v0/addresses/${address}/balances?api-key=${HELIUS_API_KEY}`
  );
  return response.json();
}

// DAS API for compressed NFTs
async function getAssetsByOwner(owner: string) {
  const response = await fetch(
    `https://mainnet.helius-rpc.com/?api-key=${HELIUS_API_KEY}`,
    {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        jsonrpc: "2.0",
        id: "my-id",
        method: "getAssetsByOwner",
        params: {
          ownerAddress: owner,
          page: 1,
          limit: 1000,
        },
      }),
    }
  );
  return response.json();
}

// Priority fee estimation
async function getPriorityFeeEstimate(accounts: string[]) {
  const response = await fetch(
    `https://mainnet.helius-rpc.com/?api-key=${HELIUS_API_KEY}`,
    {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        jsonrpc: "2.0",
        id: "1",
        method: "getPriorityFeeEstimate",
        params: [{
          accountKeys: accounts,
          options: {
            recommended: true,
          },
        }],
      }),
    }
  );
  return response.json();
}
```

### Connection Health Monitoring

```typescript
interface HealthMetrics {
  latency: number;
  isHealthy: boolean;
  lastCheck: Date;
  errorRate: number;
}

class MonitoredConnection {
  private connection: Connection;
  private metrics: HealthMetrics = {
    latency: 0,
    isHealthy: true,
    lastCheck: new Date(),
    errorRate: 0,
  };
  private recentErrors: number[] = [];
  private healthCheckInterval: NodeJS.Timeout;

  constructor(connection: Connection) {
    this.connection = connection;
    this.healthCheckInterval = setInterval(
      () => this.checkHealth(),
      30000
    );
  }

  async checkHealth(): Promise<HealthMetrics> {
    const start = Date.now();

    try {
      await this.connection.getSlot();

      this.metrics = {
        latency: Date.now() - start,
        isHealthy: true,
        lastCheck: new Date(),
        errorRate: this.calculateErrorRate(),
      };
    } catch (error) {
      this.recentErrors.push(Date.now());

      this.metrics = {
        latency: -1,
        isHealthy: false,
        lastCheck: new Date(),
        errorRate: this.calculateErrorRate(),
      };
    }

    return this.metrics;
  }

  private calculateErrorRate(): number {
    const oneMinuteAgo = Date.now() - 60000;
    this.recentErrors = this.recentErrors.filter(t => t > oneMinuteAgo);
    return this.recentErrors.length;
  }

  getMetrics(): HealthMetrics {
    return { ...this.metrics };
  }

  destroy(): void {
    clearInterval(this.healthCheckInterval);
  }
}
```

---

## Common Patterns

### Environment-Based Configuration

```typescript
// config/rpc.ts
interface RPCConfig {
  primary: string;
  fallback: string[];
  wsEndpoint: string;
  commitment: "processed" | "confirmed" | "finalized";
}

function getRPCConfig(): RPCConfig {
  const env = process.env.NODE_ENV;

  if (env === "production") {
    return {
      primary: process.env.MAINNET_RPC_URL!,
      fallback: [
        process.env.MAINNET_RPC_FALLBACK_1!,
        process.env.MAINNET_RPC_FALLBACK_2!,
      ],
      wsEndpoint: process.env.MAINNET_WS_URL!,
      commitment: "confirmed",
    };
  }

  if (env === "staging") {
    return {
      primary: process.env.DEVNET_RPC_URL!,
      fallback: [],
      wsEndpoint: process.env.DEVNET_WS_URL!,
      commitment: "confirmed",
    };
  }

  // Development
  return {
    primary: "https://api.devnet.solana.com",
    fallback: [],
    wsEndpoint: "wss://api.devnet.solana.com",
    commitment: "confirmed",
  };
}
```

---

## Key Takeaways

1. **Never use public RPCs in production** â€” rate limits will break your app
2. **Multi-provider failover** â€” don't depend on single provider
3. **Batch requests** â€” reduce API calls and improve performance
4. **Rate limit proactively** â€” don't wait for 429 errors
5. **Monitor health** â€” track latency and error rates
6. **Use enhanced APIs** â€” providers offer more than just RPC
7. **Environment separation** â€” different configs for dev/staging/prod
8. **Consider costs** â€” monitor usage and optimize requests

---

## Next

Learn about indexing solutions for querying historical data.

â†’ [6.2 Indexing Solutions](./6.2-indexing-solutions.md)
