# 6.3 Deployment Strategies

> *"Deploy once, verify twice â€” Solana programs are immutable by default."*

---

## Why This Matters

Deploying Solana programs requires careful planning. Unlike traditional web deployments, on-chain programs are immutable by default, deployment costs real money, and mistakes can be costly. Understanding deployment strategies, upgrade patterns, and environment management is essential.

---

## ðŸŸ¢ General Understanding

### Deployment Environments

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Solana Deployment Environments                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                      â”‚
â”‚   LOCALNET                 DEVNET                  MAINNET-BETA     â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚   â”‚ Development  â”‚         â”‚ Testing      â”‚        â”‚ Production   â”‚ â”‚
â”‚   â”‚              â”‚         â”‚              â”‚        â”‚              â”‚ â”‚
â”‚   â”‚ â€¢ Free       â”‚   â†’     â”‚ â€¢ Free SOL   â”‚   â†’    â”‚ â€¢ Real SOL   â”‚ â”‚
â”‚   â”‚ â€¢ Fast       â”‚         â”‚ â€¢ Public     â”‚        â”‚ â€¢ Real users â”‚ â”‚
â”‚   â”‚ â€¢ Reset any  â”‚         â”‚ â€¢ May reset  â”‚        â”‚ â€¢ Permanent  â”‚ â”‚
â”‚   â”‚   time       â”‚         â”‚ â€¢ Rate limit â”‚        â”‚              â”‚ â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                      â”‚
â”‚   TESTNET (Limited use - mostly for validator testing)              â”‚
â”‚                                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Program Lifecycle

```
Build â†’ Deploy â†’ Verify â†’ Upgrade (optional)
  â”‚        â”‚        â”‚         â”‚
  â–¼        â–¼        â–¼         â–¼
.so    Program ID  Explorer  Authority
file   assigned    check     required
```

---

## ðŸŸ¡ PM/EM Depth

### Deployment Checklist

| Phase | Task | Owner |
|-------|------|-------|
| **Pre-deployment** | Security audit complete | Security |
| | Test coverage > 80% | Engineering |
| | Devnet testing passed | QA |
| | Deployment script tested | DevOps |
| **Deployment** | Deploy to mainnet | DevOps |
| | Verify program on explorer | Engineering |
| | Update frontend configs | Frontend |
| **Post-deployment** | Monitor transactions | DevOps |
| | Verify functionality | QA |
| | Document program ID | Engineering |

### Cost Estimation

| Program Size | Rent Cost (approx) |
|--------------|-------------------|
| 100 KB | Varies by rent parameters |
| 500 KB | Varies by rent parameters |
| 1 MB | Varies by rent parameters |
| 10 MB (max) | Varies by rent parameters |

*Note: Solana program max size is 10MB. Buffer accounts for upgrades may cost additional rent.*

### Upgrade Authority Options

| Option | Security | Flexibility | Use Case |
|--------|----------|-------------|----------|
| Single EOA | Low | High | Early development |
| Multisig | Medium | Medium | Small teams |
| Governance | High | Low | Decentralized protocols |
| Revoked | Maximum | None | Immutable contracts |

---

## ðŸ”µ Engineer Depth

### Basic Deployment Commands

```bash
# Build the program
anchor build

# Check program size
ls -la target/deploy/*.so

# Deploy to devnet
solana config set --url devnet
anchor deploy

# Deploy to mainnet
solana config set --url mainnet-beta
anchor deploy --provider.cluster mainnet

# Deploy with specific keypair
anchor deploy --provider.wallet ~/.config/solana/deployer.json
```

### Deployment Script

```typescript
// scripts/deploy.ts
import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { Keypair, Connection, LAMPORTS_PER_SOL } from "@solana/web3.js";
import * as fs from "fs";

interface DeployConfig {
  cluster: "devnet" | "mainnet-beta" | "localnet";
  programKeypairPath: string;
  deployerKeypairPath: string;
  rpcUrl: string;
}

async function deploy(config: DeployConfig) {
  console.log(`Deploying to ${config.cluster}...`);

  // Load keypairs
  const deployer = Keypair.fromSecretKey(
    Uint8Array.from(
      JSON.parse(fs.readFileSync(config.deployerKeypairPath, "utf-8"))
    )
  );

  const programKeypair = Keypair.fromSecretKey(
    Uint8Array.from(
      JSON.parse(fs.readFileSync(config.programKeypairPath, "utf-8"))
    )
  );

  console.log(`Deployer: ${deployer.publicKey.toString()}`);
  console.log(`Program ID: ${programKeypair.publicKey.toString()}`);

  // Check balance
  const connection = new Connection(config.rpcUrl, "confirmed");
  const balance = await connection.getBalance(deployer.publicKey);
  console.log(`Deployer balance: ${balance / LAMPORTS_PER_SOL} SOL`);

  if (balance < 5 * LAMPORTS_PER_SOL) {
    throw new Error("Insufficient balance for deployment");
  }

  // Set up provider
  const provider = new anchor.AnchorProvider(
    connection,
    new anchor.Wallet(deployer),
    { commitment: "confirmed" }
  );
  anchor.setProvider(provider);

  // Deploy using Anchor CLI
  const { execSync } = require("child_process");

  try {
    execSync(
      `anchor deploy --provider.cluster ${config.cluster} --provider.wallet ${config.deployerKeypairPath}`,
      { stdio: "inherit" }
    );

    console.log("Deployment successful!");
    console.log(`Program ID: ${programKeypair.publicKey.toString()}`);

    // Save deployment info
    saveDeploymentInfo(config.cluster, programKeypair.publicKey.toString());
  } catch (error) {
    console.error("Deployment failed:", error);
    throw error;
  }
}

function saveDeploymentInfo(cluster: string, programId: string) {
  const deployments = JSON.parse(
    fs.readFileSync("./deployments.json", "utf-8") || "{}"
  );

  deployments[cluster] = {
    programId,
    deployedAt: new Date().toISOString(),
    version: require("../package.json").version,
  };

  fs.writeFileSync("./deployments.json", JSON.stringify(deployments, null, 2));
}

// Usage
const config: DeployConfig = {
  cluster: process.argv[2] as "devnet" | "mainnet-beta" || "devnet",
  programKeypairPath: "./target/deploy/my_program-keypair.json",
  deployerKeypairPath: process.env.DEPLOYER_KEYPAIR!,
  rpcUrl: process.env.RPC_URL!,
};

deploy(config).catch(console.error);
```

### Program Upgrade

```typescript
// scripts/upgrade.ts
import * as anchor from "@coral-xyz/anchor";
import { BPF_LOADER_UPGRADEABLE_PROGRAM_ID } from "@solana/web3.js";

async function upgradeProgram(
  connection: Connection,
  programId: PublicKey,
  bufferAddress: PublicKey,
  upgradeAuthority: Keypair
) {
  // 1. First, deploy new program to a buffer account
  // anchor build
  // solana program write-buffer target/deploy/my_program.so

  // 2. Upgrade the program
  const transaction = new Transaction().add(
    BpfLoaderUpgradeable.upgrade({
      programId,
      buffer: bufferAddress,
      authority: upgradeAuthority.publicKey,
      spill: upgradeAuthority.publicKey,
    })
  );

  const signature = await sendAndConfirmTransaction(
    connection,
    transaction,
    [upgradeAuthority]
  );

  console.log("Program upgraded:", signature);
  return signature;
}

// Using Anchor CLI
async function upgradeWithAnchor(cluster: string) {
  const { execSync } = require("child_process");

  // Write new program to buffer
  const bufferOutput = execSync(
    `solana program write-buffer target/deploy/my_program.so --url ${cluster}`,
    { encoding: "utf-8" }
  );

  const bufferAddress = bufferOutput.match(/Buffer: (\w+)/)?.[1];
  console.log("Buffer address:", bufferAddress);

  // Upgrade the program
  execSync(
    `solana program deploy --buffer ${bufferAddress} --program-id <PROGRAM_ID> --upgrade-authority <AUTHORITY_KEYPAIR> --url ${cluster}`,
    { stdio: "inherit" }
  );
}
```

### Multisig Deployment

```typescript
// Using Squads multisig for deployments
import Squads from "@sqds/sdk";

async function deployWithMultisig(
  squads: Squads,
  multisigAddress: PublicKey,
  programBuffer: PublicKey,
  programId: PublicKey
) {
  // Create upgrade proposal
  const [txBuilder] = await squads.createTransaction(
    multisigAddress,
    1 // authority index
  );

  // Add upgrade instruction
  await squads.addInstruction(
    txBuilder.publicKey,
    BpfLoaderUpgradeable.upgrade({
      programId,
      buffer: programBuffer,
      authority: squads.getAuthorityPDA(multisigAddress, 1),
      spill: multisigAddress,
    })
  );

  // Activate the transaction
  await squads.activateTransaction(txBuilder.publicKey);

  console.log("Upgrade proposal created:", txBuilder.publicKey.toString());
  console.log("Awaiting multisig approval...");

  // Each signer approves
  // await squads.approveTransaction(txBuilder.publicKey);

  // After threshold reached, execute
  // await squads.executeTransaction(txBuilder.publicKey);
}
```

### CI/CD Pipeline

```yaml
# .github/workflows/deploy.yml
name: Deploy Solana Program

on:
  push:
    branches: [main]
    paths:
      - 'programs/**'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'devnet'
        type: choice
        options:
          - devnet
          - mainnet-beta

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Setup Rust
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable

      - name: Setup Solana
        uses: metaplex-foundation/actions/install-solana@v1
        with:
          version: '1.17.0'

      - name: Setup Anchor
        run: |
          npm install -g @coral-xyz/anchor-cli
          anchor --version

      - name: Build program
        run: anchor build

      - name: Run tests
        run: anchor test

      - name: Upload artifact
        uses: actions/upload-artifact@v3
        with:
          name: program
          path: target/deploy/

  deploy-devnet:
    needs: build
    if: github.event.inputs.environment == 'devnet' || github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    environment: devnet
    steps:
      - uses: actions/checkout@v3

      - name: Download artifact
        uses: actions/download-artifact@v3
        with:
          name: program
          path: target/deploy/

      - name: Setup Solana
        uses: metaplex-foundation/actions/install-solana@v1

      - name: Configure Solana
        run: |
          solana config set --url devnet
          echo "${{ secrets.DEPLOYER_KEYPAIR }}" > deployer.json
          solana config set --keypair deployer.json

      - name: Deploy
        run: |
          solana program deploy target/deploy/my_program.so \
            --program-id ${{ vars.PROGRAM_ID }}

      - name: Verify deployment
        run: |
          solana program show ${{ vars.PROGRAM_ID }}

  deploy-mainnet:
    needs: build
    if: github.event.inputs.environment == 'mainnet-beta'
    runs-on: ubuntu-latest
    environment: mainnet
    steps:
      - uses: actions/checkout@v3

      - name: Download artifact
        uses: actions/download-artifact@v3

      - name: Setup Solana
        uses: metaplex-foundation/actions/install-solana@v1

      - name: Configure Solana
        run: |
          solana config set --url mainnet-beta
          echo "${{ secrets.MAINNET_DEPLOYER_KEYPAIR }}" > deployer.json

      - name: Deploy to buffer
        id: buffer
        run: |
          OUTPUT=$(solana program write-buffer target/deploy/my_program.so)
          BUFFER=$(echo $OUTPUT | grep -oP 'Buffer: \K\w+')
          echo "buffer=$BUFFER" >> $GITHUB_OUTPUT

      - name: Create upgrade proposal
        run: |
          # Trigger multisig proposal creation
          npm run create-upgrade-proposal -- \
            --buffer ${{ steps.buffer.outputs.buffer }} \
            --program ${{ vars.MAINNET_PROGRAM_ID }}

      - name: Notify team
        uses: slackapi/slack-github-action@v1
        with:
          payload: |
            {
              "text": "Mainnet upgrade proposal created for buffer ${{ steps.buffer.outputs.buffer }}"
            }
```

### Environment Configuration

```typescript
// config/environments.ts
interface EnvironmentConfig {
  cluster: "localnet" | "devnet" | "mainnet-beta";
  rpcUrl: string;
  wsUrl: string;
  programId: string;
  commitment: "processed" | "confirmed" | "finalized";
  priorityFee: number; // microLamports
}

const environments: Record<string, EnvironmentConfig> = {
  development: {
    cluster: "localnet",
    rpcUrl: "http://localhost:8899",
    wsUrl: "ws://localhost:8900",
    programId: "Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS",
    commitment: "confirmed",
    priorityFee: 0,
  },
  staging: {
    cluster: "devnet",
    rpcUrl: process.env.DEVNET_RPC_URL || "https://api.devnet.solana.com",
    wsUrl: process.env.DEVNET_WS_URL || "wss://api.devnet.solana.com",
    programId: process.env.DEVNET_PROGRAM_ID!,
    commitment: "confirmed",
    priorityFee: 1000,
  },
  production: {
    cluster: "mainnet-beta",
    rpcUrl: process.env.MAINNET_RPC_URL!,
    wsUrl: process.env.MAINNET_WS_URL!,
    programId: process.env.MAINNET_PROGRAM_ID!,
    commitment: "confirmed",
    priorityFee: 5000,
  },
};

export function getConfig(): EnvironmentConfig {
  const env = process.env.NODE_ENV || "development";
  return environments[env];
}
```

### Deployment Verification

```typescript
// scripts/verify-deployment.ts
import { Connection, PublicKey } from "@solana/web3.js";
import * as fs from "fs";
import * as crypto from "crypto";

async function verifyDeployment(
  rpcUrl: string,
  programId: string,
  expectedBinaryPath: string
) {
  const connection = new Connection(rpcUrl, "confirmed");
  const programPubkey = new PublicKey(programId);

  // 1. Check program exists
  const programInfo = await connection.getAccountInfo(programPubkey);
  if (!programInfo) {
    throw new Error("Program not found");
  }

  console.log("âœ“ Program exists");
  console.log(`  Owner: ${programInfo.owner.toString()}`);
  console.log(`  Executable: ${programInfo.executable}`);
  console.log(`  Data length: ${programInfo.data.length}`);

  // 2. Get program data account
  const [programDataAddress] = PublicKey.findProgramAddressSync(
    [programPubkey.toBuffer()],
    new PublicKey("BPFLoaderUpgradeab1e11111111111111111111111")
  );

  const programData = await connection.getAccountInfo(programDataAddress);
  if (!programData) {
    throw new Error("Program data not found");
  }

  console.log("âœ“ Program data account found");

  // 3. Verify binary hash (skip first 45 bytes of metadata)
  const deployedBinary = programData.data.slice(45);
  const expectedBinary = fs.readFileSync(expectedBinaryPath);

  const deployedHash = crypto
    .createHash("sha256")
    .update(deployedBinary)
    .digest("hex");

  const expectedHash = crypto
    .createHash("sha256")
    .update(expectedBinary)
    .digest("hex");

  if (deployedHash === expectedHash) {
    console.log("âœ“ Binary hash matches");
  } else {
    console.log("âœ— Binary hash mismatch");
    console.log(`  Deployed: ${deployedHash}`);
    console.log(`  Expected: ${expectedHash}`);
    throw new Error("Binary verification failed");
  }

  // 4. Check upgrade authority
  const upgradeAuthority = new PublicKey(programData.data.slice(13, 45));
  console.log(`  Upgrade authority: ${upgradeAuthority.toString()}`);

  return {
    programId: programPubkey.toString(),
    programDataAddress: programDataAddress.toString(),
    upgradeAuthority: upgradeAuthority.toString(),
    binaryHash: deployedHash,
  };
}
```

---

## Common Patterns

### Feature Flags for Rollouts

```rust
// In your program
#[account]
pub struct ProgramConfig {
    pub authority: Pubkey,
    pub feature_new_logic: bool,
    pub feature_v2_enabled: bool,
    pub max_users: u64,
}

pub fn process_action(ctx: Context<Action>) -> Result<()> {
    let config = &ctx.accounts.config;

    if config.feature_new_logic {
        // New logic path
        process_v2(ctx)
    } else {
        // Old logic path
        process_v1(ctx)
    }
}
```

### Gradual Rollout

```typescript
// Client-side feature gating
async function shouldUseNewProgram(userId: string): Promise<boolean> {
  // Percentage rollout
  const rolloutPercentage = 10; // 10% of users

  const hash = crypto
    .createHash("sha256")
    .update(userId)
    .digest("hex");

  const userBucket = parseInt(hash.slice(0, 8), 16) % 100;

  return userBucket < rolloutPercentage;
}

// Usage
const programId = await shouldUseNewProgram(wallet.publicKey.toString())
  ? NEW_PROGRAM_ID
  : OLD_PROGRAM_ID;
```

---

## Key Takeaways

1. **Test extensively on devnet** â€” simulate mainnet conditions
2. **Use multisig for mainnet** â€” never single-key authority
3. **Verify deployments** â€” check binary hashes match
4. **Automate with CI/CD** â€” reduce human error
5. **Plan for upgrades** â€” use upgradeable programs initially
6. **Document everything** â€” program IDs, authorities, versions
7. **Have rollback plans** â€” buffer previous versions
8. **Monitor after deploy** â€” catch issues early

---

## Next

Learn about monitoring and observability for Solana applications.

â†’ [6.4 Monitoring & Observability](./6.4-monitoring-observability.md)
