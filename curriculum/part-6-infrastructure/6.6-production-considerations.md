# 6.6 Production Considerations

> *"The difference between a demo and production is everything that can go wrong."*

---

## Why This Matters

Moving from development to production on Solana requires addressing challenges unique to blockchain: immutable deployments, real financial stakes, network congestion, and user expectations for reliability. This module covers the practical considerations for running production-grade Solana applications.

---

## ğŸŸ¢ General Understanding

### Production Readiness Checklist

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Production Readiness Levels                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                      â”‚
â”‚   LEVEL 1: BASIC                                                    â”‚
â”‚   â˜ Program deployed to mainnet                                     â”‚
â”‚   â˜ Private RPC endpoint configured                                 â”‚
â”‚   â˜ Basic error handling                                            â”‚
â”‚   â˜ Environment separation                                          â”‚
â”‚                                                                      â”‚
â”‚   LEVEL 2: RELIABLE                                                 â”‚
â”‚   â˜ Multi-provider RPC failover                                     â”‚
â”‚   â˜ Transaction retry logic                                         â”‚
â”‚   â˜ Monitoring and alerting                                         â”‚
â”‚   â˜ Structured logging                                              â”‚
â”‚                                                                      â”‚
â”‚   LEVEL 3: RESILIENT                                                â”‚
â”‚   â˜ Priority fee optimization                                       â”‚
â”‚   â˜ Congestion handling                                             â”‚
â”‚   â˜ Graceful degradation                                            â”‚
â”‚   â˜ Circuit breakers                                                â”‚
â”‚                                                                      â”‚
â”‚   LEVEL 4: ENTERPRISE                                               â”‚
â”‚   â˜ Multi-region deployment                                         â”‚
â”‚   â˜ Automated scaling                                               â”‚
â”‚   â˜ Disaster recovery                                               â”‚
â”‚   â˜ SLA guarantees                                                  â”‚
â”‚                                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Common Production Issues

| Issue | Symptom | Impact |
|-------|---------|--------|
| RPC rate limiting | 429 errors | Failed transactions |
| Network congestion | High latency | Poor UX |
| Blockhash expiration | Tx dropped | Lost transactions |
| Insufficient priority fee | Tx stuck | Delayed execution |
| Account not found | RPC lag | State inconsistency |

---

## ğŸŸ¡ PM/EM Depth

### Capacity Planning

| Component | Metric | Scaling Strategy |
|-----------|--------|------------------|
| RPC calls | Requests/sec | Higher tier, multi-provider |
| Transactions | TPS needed | Priority fees, parallel submission |
| WebSocket | Concurrent connections | Connection pooling |
| Indexing | Query volume | Caching, read replicas |
| Storage | Account data | Off-chain where possible |

### Cost Estimation (Monthly)

| Item | Low Volume | Medium | High |
|------|------------|--------|------|
| RPC Provider | Varies | Varies | Varies |
| Indexing | Varies | Varies | Varies |
| Transaction fees | Varies | Varies | Varies |
| Infrastructure | Varies | Varies | Varies |
| **Total** | **Varies** | **Varies** | **Varies** |

### SLA Considerations

| Metric | Target (example) | Measurement |
|--------|------------------|-------------|
| Availability | 99.9% | Uptime monitoring |
| Tx success rate | 99% | Transaction tracking |
| P99 latency | < 5s | Performance monitoring |
| Recovery time | < 1 hour | Incident tracking |

Targets should reflect your product and current network conditions.

---

## ğŸ”µ Engineer Depth

### Robust Transaction Handling

```typescript
interface TransactionConfig {
  maxRetries: number;
  baseBackoff: number;
  maxBackoff: number;
  priorityFee: "low" | "medium" | "high" | "dynamic";
  skipPreflight: boolean;
  confirmationStrategy: "blockhash" | "signature" | "hybrid";
}

class RobustTransactionSender {
  private connection: Connection;
  private config: TransactionConfig;

  constructor(connection: Connection, config: Partial<TransactionConfig> = {}) {
    this.connection = connection;
    this.config = {
      maxRetries: 3,
      baseBackoff: 500,
      maxBackoff: 10000,
      priorityFee: "dynamic",
      skipPreflight: false,
      confirmationStrategy: "hybrid",
      ...config,
    };
  }

  async sendTransaction(
    transaction: Transaction,
    signers: Keypair[]
  ): Promise<string> {
    let lastError: Error | null = null;
    let attempt = 0;

    while (attempt < this.config.maxRetries) {
      try {
        // Refresh blockhash on each attempt
        const { blockhash, lastValidBlockHeight } =
          await this.connection.getLatestBlockhash("finalized");

        transaction.recentBlockhash = blockhash;
        transaction.feePayer = signers[0].publicKey;

        // Add priority fee
        await this.addPriorityFee(transaction);

        // Sign
        transaction.sign(...signers);

        // Send
        const signature = await this.connection.sendRawTransaction(
          transaction.serialize(),
          {
            skipPreflight: this.config.skipPreflight,
            preflightCommitment: "confirmed",
            maxRetries: 0, // We handle retries ourselves
          }
        );

        // Confirm with appropriate strategy
        await this.confirmTransaction(
          signature,
          blockhash,
          lastValidBlockHeight
        );

        return signature;
      } catch (error) {
        lastError = error as Error;
        attempt++;

        if (!this.isRetryable(error)) {
          throw error;
        }

        if (attempt < this.config.maxRetries) {
          const backoff = Math.min(
            this.config.baseBackoff * Math.pow(2, attempt),
            this.config.maxBackoff
          );
          await this.sleep(backoff);
        }
      }
    }

    throw lastError || new Error("Transaction failed after retries");
  }

  private async addPriorityFee(transaction: Transaction): Promise<void> {
    let microLamports: number;

    switch (this.config.priorityFee) {
      case "low":
        microLamports = 1000;
        break;
      case "medium":
        microLamports = 10000;
        break;
      case "high":
        microLamports = 100000;
        break;
      case "dynamic":
        microLamports = await this.getDynamicPriorityFee(transaction);
        break;
    }

    // Prepend priority fee instructions
    const priorityIx = ComputeBudgetProgram.setComputeUnitPrice({
      microLamports,
    });

    transaction.instructions = [priorityIx, ...transaction.instructions];
  }

  private async getDynamicPriorityFee(transaction: Transaction): Promise<number> {
    // Use Helius or similar API for priority fee estimation
    try {
      const accounts = transaction.instructions
        .flatMap((ix) => ix.keys.map((k) => k.pubkey.toString()));

      const response = await fetch(
        `https://mainnet.helius-rpc.com/?api-key=${process.env.HELIUS_API_KEY}`,
        {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            jsonrpc: "2.0",
            id: "1",
            method: "getPriorityFeeEstimate",
            params: [{
              accountKeys: [...new Set(accounts)],
              options: { recommended: true },
            }],
          }),
        }
      );

      const data = await response.json();
      return data.result?.priorityFeeEstimate || 10000;
    } catch {
      return 10000; // Default fallback
    }
  }

  private async confirmTransaction(
    signature: string,
    blockhash: string,
    lastValidBlockHeight: number
  ): Promise<void> {
    if (this.config.confirmationStrategy === "blockhash") {
      await this.connection.confirmTransaction({
        signature,
        blockhash,
        lastValidBlockHeight,
      });
    } else if (this.config.confirmationStrategy === "signature") {
      await this.pollSignatureStatus(signature);
    } else {
      // Hybrid: race between blockhash expiry and confirmation
      await Promise.race([
        this.connection.confirmTransaction({
          signature,
          blockhash,
          lastValidBlockHeight,
        }),
        this.pollSignatureStatus(signature),
      ]);
    }
  }

  private async pollSignatureStatus(
    signature: string,
    timeout = 60000
  ): Promise<void> {
    const start = Date.now();

    while (Date.now() - start < timeout) {
      const status = await this.connection.getSignatureStatus(signature);

      if (status.value?.confirmationStatus === "confirmed" ||
          status.value?.confirmationStatus === "finalized") {
        if (status.value.err) {
          throw new Error(`Transaction failed: ${JSON.stringify(status.value.err)}`);
        }
        return;
      }

      await this.sleep(1000);
    }

    throw new Error("Transaction confirmation timeout");
  }

  private isRetryable(error: any): boolean {
    const message = error?.message?.toLowerCase() || "";

    // Non-retryable errors
    if (message.includes("insufficient funds")) return false;
    if (message.includes("account not found")) return false;
    if (message.includes("invalid signature")) return false;

    // Retryable errors
    if (message.includes("blockhash not found")) return true;
    if (message.includes("rate limit")) return true;
    if (message.includes("timeout")) return true;
    if (error?.status === 429) return true;
    if (error?.status >= 500) return true;

    return false;
  }

  private sleep(ms: number): Promise<void> {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
}
```

### Congestion Handling

```typescript
class CongestionManager {
  private connection: Connection;
  private currentCongestion: "low" | "medium" | "high" = "low";

  async assessCongestion(): Promise<"low" | "medium" | "high"> {
    const recentPerformance = await this.connection.getRecentPerformanceSamples(5);

    if (recentPerformance.length === 0) return "medium";

    const avgTps = recentPerformance.reduce(
      (sum, sample) => sum + sample.numTransactions / sample.samplePeriodSecs,
      0
    ) / recentPerformance.length;

    // Thresholds should be tuned to your own workload and current network conditions
    if (avgTps > 3000) {
      this.currentCongestion = "high";
    } else if (avgTps > 1500) {
      this.currentCongestion = "medium";
    } else {
      this.currentCongestion = "low";
    }

    return this.currentCongestion;
  }

  getRecommendedPriorityFee(): number {
    switch (this.currentCongestion) {
      case "low":
        return 1000;
      case "medium":
        return 10000;
      case "high":
        return 100000;
    }
  }

  shouldDelayNonCritical(): boolean {
    return this.currentCongestion === "high";
  }

  getMaxBatchSize(): number {
    switch (this.currentCongestion) {
      case "low":
        return 100;
      case "medium":
        return 50;
      case "high":
        return 10;
    }
  }
}
```

### Circuit Breaker Pattern

```typescript
interface CircuitBreakerConfig {
  failureThreshold: number;
  resetTimeout: number;
  halfOpenRequests: number;
}

enum CircuitState {
  CLOSED = "closed",
  OPEN = "open",
  HALF_OPEN = "half_open",
}

class CircuitBreaker {
  private state: CircuitState = CircuitState.CLOSED;
  private failures = 0;
  private lastFailureTime = 0;
  private halfOpenSuccesses = 0;
  private config: CircuitBreakerConfig;

  constructor(config: Partial<CircuitBreakerConfig> = {}) {
    this.config = {
      failureThreshold: 5,
      resetTimeout: 30000,
      halfOpenRequests: 3,
      ...config,
    };
  }

  async execute<T>(operation: () => Promise<T>): Promise<T> {
    if (this.state === CircuitState.OPEN) {
      if (Date.now() - this.lastFailureTime > this.config.resetTimeout) {
        this.state = CircuitState.HALF_OPEN;
        this.halfOpenSuccesses = 0;
      } else {
        throw new Error("Circuit breaker is open");
      }
    }

    try {
      const result = await operation();

      if (this.state === CircuitState.HALF_OPEN) {
        this.halfOpenSuccesses++;
        if (this.halfOpenSuccesses >= this.config.halfOpenRequests) {
          this.state = CircuitState.CLOSED;
          this.failures = 0;
        }
      } else {
        this.failures = 0;
      }

      return result;
    } catch (error) {
      this.failures++;
      this.lastFailureTime = Date.now();

      if (this.failures >= this.config.failureThreshold) {
        this.state = CircuitState.OPEN;
      }

      throw error;
    }
  }

  getState(): CircuitState {
    return this.state;
  }

  reset(): void {
    this.state = CircuitState.CLOSED;
    this.failures = 0;
  }
}

// Usage
const rpcCircuitBreaker = new CircuitBreaker({
  failureThreshold: 5,
  resetTimeout: 30000,
});

async function getBalanceWithCircuitBreaker(pubkey: PublicKey): Promise<number> {
  return rpcCircuitBreaker.execute(() => connection.getBalance(pubkey));
}
```

### Graceful Degradation

```typescript
interface FeatureFlags {
  enableRealTimeUpdates: boolean;
  enableHistoricalData: boolean;
  enablePriorityTransactions: boolean;
  maxBatchSize: number;
}

class DegradationManager {
  private flags: FeatureFlags = {
    enableRealTimeUpdates: true,
    enableHistoricalData: true,
    enablePriorityTransactions: true,
    maxBatchSize: 100,
  };

  private healthScores = {
    rpc: 100,
    websocket: 100,
    indexer: 100,
  };

  updateHealthScore(service: keyof typeof this.healthScores, score: number): void {
    this.healthScores[service] = Math.max(0, Math.min(100, score));
    this.evaluateDegradation();
  }

  private evaluateDegradation(): void {
    // Disable real-time if WebSocket unhealthy
    if (this.healthScores.websocket < 50) {
      this.flags.enableRealTimeUpdates = false;
      console.warn("Disabled real-time updates due to WebSocket issues");
    } else {
      this.flags.enableRealTimeUpdates = true;
    }

    // Disable historical data if indexer unhealthy
    if (this.healthScores.indexer < 50) {
      this.flags.enableHistoricalData = false;
      console.warn("Disabled historical data due to indexer issues");
    } else {
      this.flags.enableHistoricalData = true;
    }

    // Reduce batch size if RPC stressed
    if (this.healthScores.rpc < 75) {
      this.flags.maxBatchSize = 25;
    } else if (this.healthScores.rpc < 90) {
      this.flags.maxBatchSize = 50;
    } else {
      this.flags.maxBatchSize = 100;
    }
  }

  getFlags(): FeatureFlags {
    return { ...this.flags };
  }
}

// Usage in components
function useRealtimeBalance(pubkey: PublicKey) {
  const { flags } = useDegradationManager();

  if (flags.enableRealTimeUpdates) {
    return useWebSocketBalance(pubkey);
  } else {
    return usePolledBalance(pubkey, 10000); // Fallback to polling
  }
}
```

### Queue-Based Processing

```typescript
import Bull from "bull";

interface TransactionJob {
  id: string;
  transaction: string; // Base64 encoded
  signers: string[]; // Base64 encoded keypairs
  priority: number;
  createdAt: number;
}

class TransactionQueue {
  private queue: Bull.Queue<TransactionJob>;
  private connection: Connection;

  constructor(redisUrl: string, connection: Connection) {
    this.queue = new Bull("transactions", redisUrl, {
      defaultJobOptions: {
        attempts: 3,
        backoff: {
          type: "exponential",
          delay: 1000,
        },
        removeOnComplete: 100,
        removeOnFail: 50,
      },
    });

    this.connection = connection;
    this.setupProcessor();
  }

  private setupProcessor(): void {
    this.queue.process(5, async (job) => {
      const { transaction: txBase64, signers: signersBase64 } = job.data;

      // Decode transaction
      const transaction = Transaction.from(
        Buffer.from(txBase64, "base64")
      );

      // Decode signers
      const signers = signersBase64.map((s) =>
        Keypair.fromSecretKey(Buffer.from(s, "base64"))
      );

      // Send transaction
      const sender = new RobustTransactionSender(this.connection);
      const signature = await sender.sendTransaction(transaction, signers);

      return { signature };
    });

    this.queue.on("failed", (job, err) => {
      console.error(`Job ${job.id} failed:`, err.message);
    });

    this.queue.on("completed", (job, result) => {
      console.log(`Job ${job.id} completed:`, result.signature);
    });
  }

  async addTransaction(
    transaction: Transaction,
    signers: Keypair[],
    priority = 0
  ): Promise<string> {
    const job = await this.queue.add(
      {
        id: `tx-${Date.now()}-${Math.random().toString(36).slice(2)}`,
        transaction: transaction.serialize({ requireAllSignatures: false }).toString("base64"),
        signers: signers.map((s) => Buffer.from(s.secretKey).toString("base64")),
        priority,
        createdAt: Date.now(),
      },
      {
        priority,
      }
    );

    return job.id.toString();
  }

  async getJobStatus(jobId: string): Promise<{
    status: string;
    result?: any;
    error?: string;
  }> {
    const job = await this.queue.getJob(jobId);
    if (!job) {
      return { status: "not_found" };
    }

    const state = await job.getState();
    return {
      status: state,
      result: job.returnvalue,
      error: job.failedReason,
    };
  }
}
```

### Multi-Region Deployment

```typescript
// config/regions.ts
interface RegionConfig {
  name: string;
  rpcEndpoint: string;
  wsEndpoint: string;
  latencyTarget: number;
}

const regions: RegionConfig[] = [
  {
    name: "us-east",
    rpcEndpoint: process.env.RPC_US_EAST!,
    wsEndpoint: process.env.WS_US_EAST!,
    latencyTarget: 50,
  },
  {
    name: "eu-west",
    rpcEndpoint: process.env.RPC_EU_WEST!,
    wsEndpoint: process.env.WS_EU_WEST!,
    latencyTarget: 100,
  },
  {
    name: "ap-southeast",
    rpcEndpoint: process.env.RPC_AP_SOUTHEAST!,
    wsEndpoint: process.env.WS_AP_SOUTHEAST!,
    latencyTarget: 150,
  },
];

class RegionalConnectionManager {
  private connections: Map<string, Connection> = new Map();
  private latencies: Map<string, number> = new Map();

  constructor() {
    for (const region of regions) {
      this.connections.set(
        region.name,
        new Connection(region.rpcEndpoint, "confirmed")
      );
    }

    this.startLatencyMonitoring();
  }

  private async startLatencyMonitoring(): Promise<void> {
    setInterval(async () => {
      for (const [name, connection] of this.connections) {
        const start = Date.now();
        try {
          await connection.getSlot();
          this.latencies.set(name, Date.now() - start);
        } catch {
          this.latencies.set(name, Infinity);
        }
      }
    }, 30000);
  }

  getBestConnection(): Connection {
    let bestRegion = regions[0].name;
    let bestLatency = Infinity;

    for (const [name, latency] of this.latencies) {
      if (latency < bestLatency) {
        bestLatency = latency;
        bestRegion = name;
      }
    }

    return this.connections.get(bestRegion)!;
  }

  getConnectionForRegion(region: string): Connection | undefined {
    return this.connections.get(region);
  }
}
```

### Health Check Endpoint

```typescript
interface HealthStatus {
  status: "healthy" | "degraded" | "unhealthy";
  checks: {
    rpc: { status: string; latency?: number; error?: string };
    websocket: { status: string; connected?: boolean; error?: string };
    database: { status: string; latency?: number; error?: string };
    queue: { status: string; pending?: number; error?: string };
  };
  version: string;
  uptime: number;
}

app.get("/health", async (req, res) => {
  const startTime = process.uptime();

  const checks = {
    rpc: await checkRPC(),
    websocket: await checkWebSocket(),
    database: await checkDatabase(),
    queue: await checkQueue(),
  };

  const allHealthy = Object.values(checks).every(
    (c) => c.status === "healthy"
  );

  const anyUnhealthy = Object.values(checks).some(
    (c) => c.status === "unhealthy"
  );

  const status: HealthStatus = {
    status: allHealthy ? "healthy" : anyUnhealthy ? "unhealthy" : "degraded",
    checks,
    version: process.env.VERSION || "unknown",
    uptime: startTime,
  };

  const httpStatus = status.status === "healthy" ? 200 :
                     status.status === "degraded" ? 200 : 503;

  res.status(httpStatus).json(status);
});

async function checkRPC(): Promise<{ status: string; latency?: number; error?: string }> {
  try {
    const start = Date.now();
    await connection.getSlot();
    return { status: "healthy", latency: Date.now() - start };
  } catch (error) {
    return {
      status: "unhealthy",
      error: error instanceof Error ? error.message : "Unknown",
    };
  }
}
```

---

## Common Patterns

### Feature Flagging for Rollouts

```typescript
interface FeatureConfig {
  enabled: boolean;
  rolloutPercentage: number;
  allowList: string[];
  denyList: string[];
}

class FeatureManager {
  private features: Map<string, FeatureConfig> = new Map();

  isEnabled(featureName: string, userId: string): boolean {
    const config = this.features.get(featureName);
    if (!config || !config.enabled) return false;

    // Check deny list
    if (config.denyList.includes(userId)) return false;

    // Check allow list
    if (config.allowList.includes(userId)) return true;

    // Percentage rollout
    const hash = this.hashUserId(userId);
    return hash < config.rolloutPercentage;
  }

  private hashUserId(userId: string): number {
    let hash = 0;
    for (let i = 0; i < userId.length; i++) {
      hash = ((hash << 5) - hash) + userId.charCodeAt(i);
      hash |= 0;
    }
    return Math.abs(hash) % 100;
  }
}
```

---

## Key Takeaways

1. **Retry with backoff** â€” network issues are common
2. **Dynamic priority fees** â€” adapt to congestion
3. **Circuit breakers** â€” prevent cascade failures
4. **Graceful degradation** â€” keep core features working
5. **Queue important operations** â€” don't lose transactions
6. **Multi-region for resilience** â€” geographic redundancy
7. **Health checks everywhere** â€” know your system state
8. **Feature flags for safety** â€” roll out carefully

---

## Conclusion

You've completed the Infrastructure section. You now understand:

- RPC provider selection and management
- Indexing solutions for historical data
- Deployment strategies and CI/CD
- Monitoring and observability
- Security best practices
- Production resilience patterns

---

## Next: Appendices

â†’ [Appendix A: Glossary](../appendices/appendix-a-glossary.md)
