---
title: "4.10 Program Optimization"
description: "Learn about 4.10 Program Optimization in the Solana onboarding curriculum."
---

> *"The fastest code is the code that doesn't run. The cheapest operation is the one you don't do."*

---

## Why This Matters

Solana programs have resource constraints: compute units, transaction size, and account data limits. Efficient programs cost less to run, fit more operations per transaction, and provide better user experience. Understanding optimization techniques helps you build programs that scale.

> âš ï¸ **Note**: Resource limits and compute costs vary by release. Verify current values in the Solana source code (as of [`solana-labs/solana`](https://github.com/solana-labs/solana)).

---

## ğŸŸ¢ General Understanding

### Resource Constraints

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Solana Resource Limits                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                      â”‚
â”‚   COMPUTE UNITS                                                     â”‚
â”‚   Default: cluster-configured                                       â”‚
â”‚   Maximum: cluster-configured                                       â”‚
â”‚   Per instruction: varies by operation                              â”‚
â”‚                                                                      â”‚
â”‚   TRANSACTION SIZE                                                  â”‚
â”‚   Maximum: version-dependent                                        â”‚
â”‚   Includes: signatures, addresses, instructions, data               â”‚
â”‚                                                                      â”‚
â”‚   ACCOUNT DATA                                                      â”‚
â”‚   Maximum per account: protocol-defined                             â”‚
â”‚   Maximum realloc per instruction: protocol-defined                 â”‚
â”‚                                                                      â”‚
â”‚   ACCOUNTS PER TRANSACTION                                          â”‚
â”‚   Legacy messages: protocol-defined                                 â”‚
â”‚   v0 messages: more via address lookup tables                       â”‚
â”‚                                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Cost Breakdown

| Operation | Approximate CUs |
|-----------|-----------------|
| Basic instruction | Varies |
| SHA256 hash | Varies |
| Ed25519 verify | Varies |
| Account creation (CPI) | Varies |
| Token transfer (CPI) | Varies |
| Borsh serialization | Varies with size |
| PDA derivation | Varies |

### Optimization Workflow (Practical)

```
Measure CU usage
  â†’ Identify hot spots
  â†’ Apply one change
  â†’ Re-measure
```

---

## ğŸŸ¡ PM/EM Depth

### Optimization Priority

```
OPTIMIZATION HIERARCHY:

1. ALGORITHM FIRST
   - Better algorithms beat micro-optimizations
   - O(n) vs O(nÂ²) matters more than anything

2. ARCHITECTURE SECOND
   - Account structure affects everything
   - Poor design can't be optimized away

3. IMPLEMENTATION THIRD
   - Compute unit savings
   - Memory efficiency
   - Serialization optimization

4. MICRO-OPTIMIZATION LAST
   - Only after profiling
   - Diminishing returns
```

### When to Optimize

```
OPTIMIZE WHEN:
  âœ“ Transaction fails due to CU limit
  âœ“ Complex operations timing out
  âœ“ Users complaining about costs
  âœ“ Approaching account size limits

DON'T OPTIMIZE WHEN:
  âœ— Code is still in development
  âœ— No performance problems exist
  âœ— Optimization hurts readability significantly
  âœ— Before you've measured the actual problem
```

---

## ğŸ”µ Engineer Depth

### 1. Compute Unit Optimization

#### Measure First

```rust
use anchor_lang::solana_program::log::sol_log_compute_units;

pub fn my_instruction(ctx: Context<MyInstruction>) -> Result<()> {
    sol_log_compute_units();  // Log remaining CUs

    // ... operation 1 ...

    sol_log_compute_units();  // See how many operation 1 used

    // ... operation 2 ...

    sol_log_compute_units();  // See how many operation 2 used

    Ok(())
}
```

#### Avoid Redundant Operations

```rust
// INEFFICIENT: Multiple PDA derivations
pub fn inefficient(ctx: Context<MyContext>) -> Result<()> {
    let (pda1, bump1) = Pubkey::find_program_address(seeds, &program_id);
    // ... use pda1 ...

    let (pda2, bump2) = Pubkey::find_program_address(seeds, &program_id);  // Same seeds!
    // ... use pda2 ...

    Ok(())
}

// EFFICIENT: Store and reuse
pub fn efficient(ctx: Context<MyContext>) -> Result<()> {
    let (pda, bump) = Pubkey::find_program_address(seeds, &program_id);

    // Reuse pda and bump throughout
    // Or better: use stored bump from account

    Ok(())
}

// BEST: Use stored bump (avoid find_program_address entirely)
#[account]
pub struct MyAccount {
    pub bump: u8,  // Stored during initialization
}

pub fn best(ctx: Context<MyContext>) -> Result<()> {
    // Use ctx.bumps.my_account or stored account.bump
    // find_program_address costs extra CUs (measure on your cluster)
    // create_program_address with known bump is cheaper
    Ok(())
}
```

#### Minimize CPIs

```rust
// INEFFICIENT: Multiple CPI calls
pub fn multiple_transfers(ctx: Context<MultiTransfer>) -> Result<()> {
    // Each CPI has overhead
    token::transfer(ctx1, 100)?;  // CPI overhead adds up
    token::transfer(ctx2, 200)?;
    token::transfer(ctx3, 300)?;
    // Total: multiple CPI overheads

    Ok(())
}

// EFFICIENT: Batch when possible
// Or redesign to minimize required operations
```

### 2. Account Data Optimization

#### Compact Data Structures

```rust
// WASTEFUL: Using larger types than needed
#[account]
pub struct WastefulAccount {
    pub status: u64,      // 8 bytes, but only 0-3 values
    pub count: u64,       // 8 bytes, but max 1000
    pub is_active: bool,  // 1 byte (could combine with status)
    pub is_frozen: bool,  // 1 byte
    pub padding: [u8; 6], // Alignment padding
}
// Size: 32 bytes

// EFFICIENT: Right-sized types
#[account]
pub struct EfficientAccount {
    pub status: u8,       // 1 byte (0-3 values)
    pub count: u16,       // 2 bytes (0-65535)
    pub flags: u8,        // 1 byte (bit flags for booleans)
}
// Size: 4 bytes + 8 discriminator = 12 bytes vs 40 bytes
// Saves rent!
```

#### Bit Flags for Booleans

```rust
// Instead of multiple booleans:
pub struct WithBooleans {
    pub is_active: bool,     // 1 byte
    pub is_frozen: bool,     // 1 byte
    pub is_verified: bool,   // 1 byte
    pub is_premium: bool,    // 1 byte
}
// 4 bytes

// Use bit flags:
pub struct WithFlags {
    pub flags: u8,  // 1 byte for 8 booleans
}

impl WithFlags {
    const ACTIVE: u8 = 1 << 0;
    const FROZEN: u8 = 1 << 1;
    const VERIFIED: u8 = 1 << 2;
    const PREMIUM: u8 = 1 << 3;

    pub fn is_active(&self) -> bool {
        self.flags & Self::ACTIVE != 0
    }

    pub fn set_active(&mut self, value: bool) {
        if value {
            self.flags |= Self::ACTIVE;
        } else {
            self.flags &= !Self::ACTIVE;
        }
    }
}
```

#### Zero-Copy Deserialization

```rust
use anchor_lang::prelude::*;

// NORMAL: Copies data into Rust struct
#[account]
pub struct NormalAccount {
    pub data: [u8; 1000],
}

// ZERO-COPY: Directly references account data
#[account(zero_copy)]
#[repr(C)]
pub struct ZeroCopyAccount {
    pub data: [u8; 1000],
}

// Access with AccountLoader instead of Account
#[derive(Accounts)]
pub struct UseZeroCopy<'info> {
    #[account(mut)]
    pub data: AccountLoader<'info, ZeroCopyAccount>,
}

pub fn use_zero_copy(ctx: Context<UseZeroCopy>) -> Result<()> {
    let data = ctx.accounts.data.load_mut()?;
    data.data[0] = 42;
    Ok(())
}

// Benefits:
// - No deserialization cost on load
// - Lower compute usage
// - Better for large accounts
// Drawbacks:
// - Must use #[repr(C)]
// - No dynamic sizing (no Vec, String)
// - Slightly more complex API
```

### 3. Serialization Optimization

#### Avoid Unnecessary Serialization

```rust
// INEFFICIENT: Serialize entire account when only updating one field
pub fn update_one_field(ctx: Context<Update>) -> Result<()> {
    let account = &mut ctx.accounts.my_account;
    account.last_updated = Clock::get()?.unix_timestamp;
    // Anchor serializes entire account on exit
    Ok(())
}

// For large accounts, consider manual field updates
pub fn update_one_field_manual(ctx: Context<UpdateManual>) -> Result<()> {
    let account_info = &ctx.accounts.my_account.to_account_info();
    let mut data = account_info.data.borrow_mut();

    // Only update the specific bytes
    let timestamp = Clock::get()?.unix_timestamp;
    let offset = 8 + 32;  // discriminator + other fields
    data[offset..offset + 8].copy_from_slice(&timestamp.to_le_bytes());

    Ok(())
}
```

### 4. Transaction Size Optimization

#### Use Address Lookup Tables

```typescript
// Without ALT: Each address is 32 bytes
// 10 accounts = 320 bytes just for addresses

// With ALT: References are 1 byte per address
import { AddressLookupTableProgram } from "@solana/web3.js";

// Create lookup table
const [createIx, lookupTableAddress] = AddressLookupTableProgram.createLookupTable({
  authority: payer.publicKey,
  payer: payer.publicKey,
  recentSlot: await connection.getSlot(),
});

// Extend with addresses
const extendIx = AddressLookupTableProgram.extendLookupTable({
  lookupTable: lookupTableAddress,
  authority: payer.publicKey,
  payer: payer.publicKey,
  addresses: [address1, address2, address3],
});

// Use in transaction
const lookupTableAccount = await connection.getAddressLookupTable(lookupTableAddress);

const messageV0 = new TransactionMessage({
  payerKey: payer.publicKey,
  recentBlockhash,
  instructions: [myInstruction],
}).compileToV0Message([lookupTableAccount.value]);

const transaction = new VersionedTransaction(messageV0);
```

#### Minimize Instruction Data

```rust
// WASTEFUL: Passing data that could be derived
pub fn wasteful_instruction(
    ctx: Context<Wasteful>,
    user_pda: Pubkey,      // Can be derived from user
    vault_pda: Pubkey,     // Can be derived from user + vault_id
    vault_id: u64,
    user: Pubkey,          // Already in accounts
) -> Result<()> { ... }

// EFFICIENT: Derive on-chain
pub fn efficient_instruction(
    ctx: Context<Efficient>,
    vault_id: u64,
) -> Result<()> {
    // Derive PDAs on-chain instead of passing
    let user = ctx.accounts.user.key();
    let (user_pda, _) = Pubkey::find_program_address(
        &[b"user", user.as_ref()],
        ctx.program_id,
    );
    // ...
    Ok(())
}
```

### 5. Memory Optimization

#### Avoid Large Stack Allocations

```rust
// DANGEROUS: Large array on stack
pub fn stack_overflow(ctx: Context<Process>) -> Result<()> {
    let buffer: [u8; 100_000] = [0; 100_000];  // Stack overflow!
    Ok(())
}

// SAFE: Use heap or process in chunks
pub fn heap_allocation(ctx: Context<Process>) -> Result<()> {
    let buffer: Vec<u8> = vec![0; 100_000];  // Heap allocated
    Ok(())
}

// BETTER: Process in chunks if possible
pub fn chunked_processing(ctx: Context<Process>) -> Result<()> {
    let chunk_size = 1000;
    for i in 0..100 {
        let chunk: [u8; 1000] = [0; 1000];
        // Process chunk...
    }
    Ok(())
}
```

### 6. Loop Optimization

```rust
// INEFFICIENT: Repeated work in loop
pub fn inefficient_loop(ctx: Context<Loop>, items: Vec<Item>) -> Result<()> {
    for item in items.iter() {
        let clock = Clock::get()?;  // Called every iteration!
        let now = clock.unix_timestamp;
        // Process item...
    }
    Ok(())
}

// EFFICIENT: Hoist invariants
pub fn efficient_loop(ctx: Context<Loop>, items: Vec<Item>) -> Result<()> {
    let clock = Clock::get()?;  // Called once
    let now = clock.unix_timestamp;

    for item in items.iter() {
        // Process item with pre-fetched now
    }
    Ok(())
}

// ALSO: Consider early exits
pub fn early_exit(ctx: Context<Loop>, items: Vec<Item>) -> Result<()> {
    for item in items.iter() {
        if item.is_invalid() {
            continue;  // Skip invalid items early
        }
        // Expensive processing only for valid items
    }
    Ok(())
}
```

### 7. Request Compute Budget

```typescript
import { ComputeBudgetProgram } from "@solana/web3.js";

// Request more compute units
const modifyComputeUnits = ComputeBudgetProgram.setComputeUnitLimit({
  units: 400_000,  // Request 400k instead of default 200k
});

// Set priority fee (in micro-lamports per CU)
const addPriorityFee = ComputeBudgetProgram.setComputeUnitPrice({
  microLamports: 1_000,  // Higher priority
});

const transaction = new Transaction()
  .add(modifyComputeUnits)
  .add(addPriorityFee)
  .add(yourInstruction);
```

### 8. Preflight Optimization

```typescript
// Skip preflight for known-good transactions
const signature = await connection.sendTransaction(transaction, [signer], {
  skipPreflight: true,  // Faster, but no simulation
  preflightCommitment: "processed",
});

// Or use simulateTransaction for debugging without sending
const simulation = await connection.simulateTransaction(transaction);
console.log("Compute units used:", simulation.value.unitsConsumed);
```

---

## Profiling Tools

### Compute Unit Logging

```rust
// Add to Cargo.toml
// [features]
// debug = []

#[cfg(feature = "debug")]
use anchor_lang::solana_program::log::sol_log_compute_units;

pub fn profiled_instruction(ctx: Context<Profiled>) -> Result<()> {
    #[cfg(feature = "debug")]
    sol_log_compute_units();

    // Operation 1
    expensive_operation_1()?;

    #[cfg(feature = "debug")]
    {
        msg!("After operation 1");
        sol_log_compute_units();
    }

    // Operation 2
    expensive_operation_2()?;

    #[cfg(feature = "debug")]
    {
        msg!("After operation 2");
        sol_log_compute_units();
    }

    Ok(())
}
```

### Transaction Analysis

```typescript
// Get detailed transaction info
const tx = await connection.getTransaction(signature, {
  commitment: "confirmed",
  maxSupportedTransactionVersion: 0,
});

console.log("Compute units consumed:", tx.meta.computeUnitsConsumed);
console.log("Fee:", tx.meta.fee);
console.log("Logs:", tx.meta.logMessages);
```

---

## Optimization Checklist

```
â–¡ Stored bumps instead of finding PDAs
â–¡ Minimized CPI calls
â–¡ Right-sized data types
â–¡ Used bit flags for booleans
â–¡ Zero-copy for large accounts
â–¡ Address lookup tables for many accounts
â–¡ Hoisted loop invariants
â–¡ Early exits in loops
â–¡ Measured before optimizing
â–¡ Profiled compute unit usage
```

---

## Key Takeaways

1. **Measure first** â€” don't optimize blindly
2. **Store bumps** â€” avoid find_program_address
3. **Minimize CPIs** â€” each has ~4000 CU overhead
4. **Right-size types** â€” u8 vs u64 matters
5. **Zero-copy for large data** â€” skip deserialization
6. **Use lookup tables** â€” compress transaction size
7. **Request more CUs** â€” when needed with priority fee
8. **Algorithm over micro-optimization** â€” big-O wins

---

## End of Part 4

You now know how to:
- Set up your development environment
- Write Solana programs with Anchor
- Understand accounts and PDAs deeply
- Make cross-program invocations
- Work with SPL tokens
- Create and manage NFTs
- Use Token-2022 extensions
- Test programs thoroughly
- Secure programs against attacks
- Optimize for performance

**Next: Client Development**

â†’ [Part 5: Client Development](../part-5-client-development/5.1-client-architectures.md)
