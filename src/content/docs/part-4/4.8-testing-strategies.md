---
title: "4.8 Testing Strategies"
description: "Learn about 4.8 Testing Strategies in the Solana onboarding curriculum."
---

> *"Code without tests is legacy code from the moment it's written."*

---

## Why This Matters

Solana programs handle real money. A bug in production can mean permanent loss of funds. Unlike traditional software where you can quickly patch issues, deployed programs are immutable (unless using upgradeable patterns). Comprehensive testing is not optional â€” it's essential.

---

## ðŸŸ¢ General Understanding

### Testing Layers

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      Testing Pyramid                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                      â”‚
â”‚                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                              â”‚
â”‚                        â”‚   E2E/      â”‚   Slow, expensive            â”‚
â”‚                        â”‚   Mainnet   â”‚   But realistic              â”‚
â”‚                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                              â”‚
â”‚                   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                           â”‚
â”‚                   â”‚   Integration       â”‚   Local validator         â”‚
â”‚                   â”‚   Tests             â”‚   Multiple programs       â”‚
â”‚                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                           â”‚
â”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                      â”‚
â”‚              â”‚   Program Tests               â”‚   BankClient          â”‚
â”‚              â”‚   (Anchor)                    â”‚   Fast iteration      â”‚
â”‚              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                      â”‚
â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                 â”‚
â”‚         â”‚   Unit Tests                            â”‚   Rust tests     â”‚
â”‚         â”‚   (Pure logic)                          â”‚   Fastest        â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â”‚
â”‚                                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### What to Test

| Category | Examples | Priority |
|----------|----------|----------|
| **Happy Path** | Normal operations work | Critical |
| **Authorization** | Only allowed users can act | Critical |
| **Edge Cases** | Zero amounts, max values | High |
| **Error Handling** | Invalid inputs rejected | High |
| **State Transitions** | Before/after states correct | High |
| **Math Overflow** | Large numbers don't break | Critical |
| **Reentrancy** | Ensure CPIs can't create unexpected state changes | Critical |

### Risk-to-Test Mapping

| Risk | Test Type | Example |
|------|-----------|---------|
| Unauthorized access | Unit + integration | Missing signer should fail |
| Overflow/underflow | Unit | Large values revert |
| CPI failure | Integration | Token transfer failure bubbles up |
| State drift | Integration | Before/after snapshots |

---

## ðŸŸ¡ PM/EM Depth

### Testing Environments

```
SOLANA TEST ENVIRONMENTS:

1. BankClient (Fastest)
   - In-process validator simulation
   - No network overhead
   - Great for unit tests
   - Limited to single program

2. Local Validator (solana-test-validator)
   - Full local node
   - Supports multiple programs
   - Deploy and test like production
   - Good for integration tests

3. Devnet (Real network)
   - Actual Solana network
   - Free SOL via airdrop
   - Test with real conditions
   - E2E testing

4. Mainnet (Production)
   - Careful! Real money
   - Final validation only
   - Shadow testing patterns
```

### Test Coverage Guidelines

```
COVERAGE TARGETS:

Critical paths (authorization, funds):  100%
Core business logic:                     95%
Error handling:                          90%
Edge cases:                              85%
Integration scenarios:                   80%

WHAT MUST BE TESTED:

âœ“ Every public instruction
âœ“ Every constraint validation
âœ“ Every error path
âœ“ Account ownership checks
âœ“ Signer requirements
âœ“ PDA derivations
âœ“ Math operations (especially divisions)
âœ“ State transitions
```

### Testing Strategy

```
DEVELOPMENT FLOW:

1. Write failing test first (TDD)
2. Implement minimum to pass
3. Refactor for quality
4. Add edge case tests
5. Add error path tests
6. Integration test
7. Deploy to devnet
8. E2E verification
```

---

## ðŸ”µ Engineer Depth

### Anchor Test Setup

```typescript
// tests/my_program.ts
import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { MyProgram } from "../target/types/my_program";
import { expect } from "chai";
import { Keypair, PublicKey, LAMPORTS_PER_SOL } from "@solana/web3.js";

describe("my_program", () => {
  // Configure the client
  const provider = anchor.AnchorProvider.env();
  anchor.setProvider(provider);

  const program = anchor.workspace.MyProgram as Program<MyProgram>;

  // Test accounts
  let user: Keypair;
  let userAccount: PublicKey;

  before(async () => {
    user = Keypair.generate();

    // Airdrop SOL for testing
    const signature = await provider.connection.requestAirdrop(
      user.publicKey,
      10 * LAMPORTS_PER_SOL
    );
    await provider.connection.confirmTransaction(signature);

    // Derive PDA
    [userAccount] = PublicKey.findProgramAddressSync(
      [Buffer.from("user"), user.publicKey.toBuffer()],
      program.programId
    );
  });

  describe("initialize", () => {
    it("creates account with correct initial state", async () => {
      await program.methods
        .initialize()
        .accounts({
          user: user.publicKey,
          userAccount,
          systemProgram: anchor.web3.SystemProgram.programId,
        })
        .signers([user])
        .rpc();

      const account = await program.account.userAccount.fetch(userAccount);

      expect(account.owner.toString()).to.equal(user.publicKey.toString());
      expect(account.balance.toNumber()).to.equal(0);
      expect(account.initialized).to.be.true;
    });

    it("fails if account already exists", async () => {
      try {
        await program.methods
          .initialize()
          .accounts({
            user: user.publicKey,
            userAccount,
            systemProgram: anchor.web3.SystemProgram.programId,
          })
          .signers([user])
          .rpc();

        expect.fail("Should have thrown");
      } catch (err) {
        expect(err.message).to.include("already in use");
      }
    });
  });
});
```

### Testing Error Conditions

```typescript
describe("error handling", () => {
  it("rejects unauthorized access", async () => {
    const attacker = Keypair.generate();

    try {
      await program.methods
        .withdraw(new anchor.BN(100))
        .accounts({
          userAccount,
          authority: attacker.publicKey,
        })
        .signers([attacker])
        .rpc();

      expect.fail("Should have rejected unauthorized access");
    } catch (err) {
      // Check for specific error
      expect(err.error.errorCode.code).to.equal("Unauthorized");
      expect(err.error.errorCode.number).to.equal(6000);
    }
  });

  it("rejects invalid amount", async () => {
    try {
      await program.methods
        .transfer(new anchor.BN(0)) // Zero amount
        .accounts({
          from: fromAccount,
          to: toAccount,
          authority: user.publicKey,
        })
        .signers([user])
        .rpc();

      expect.fail("Should have rejected zero amount");
    } catch (err) {
      expect(err.error.errorCode.code).to.equal("InvalidAmount");
    }
  });

  it("handles insufficient balance", async () => {
    try {
      await program.methods
        .withdraw(new anchor.BN(1_000_000_000_000)) // More than balance
        .accounts({
          userAccount,
          authority: user.publicKey,
        })
        .signers([user])
        .rpc();

      expect.fail("Should have rejected insufficient balance");
    } catch (err) {
      expect(err.error.errorCode.code).to.equal("InsufficientBalance");
    }
  });
});
```

### Testing PDA Derivations

```typescript
describe("PDA validation", () => {
  it("derives correct PDA", async () => {
    const [expected, bump] = PublicKey.findProgramAddressSync(
      [Buffer.from("vault"), user.publicKey.toBuffer()],
      program.programId
    );

    const account = await program.account.vault.fetch(expected);

    expect(account.bump).to.equal(bump);
  });

  it("rejects wrong PDA", async () => {
    const wrongPda = Keypair.generate().publicKey;

    try {
      await program.methods
        .deposit(new anchor.BN(100))
        .accounts({
          vault: wrongPda, // Wrong PDA
          user: user.publicKey,
        })
        .signers([user])
        .rpc();

      expect.fail("Should have rejected wrong PDA");
    } catch (err) {
      expect(err.toString()).to.include("ConstraintSeeds");
    }
  });
});
```

### Integration Tests with Multiple Programs

```typescript
describe("CPI integration", () => {
  const tokenProgram = spl.TOKEN_PROGRAM_ID;

  it("transfers tokens via CPI", async () => {
    // Setup token accounts
    const mint = await createMint(
      provider.connection,
      payer,
      mintAuthority.publicKey,
      null,
      9
    );

    const fromAta = await createAssociatedTokenAccount(
      provider.connection,
      payer,
      mint,
      user.publicKey
    );

    const toAta = await createAssociatedTokenAccount(
      provider.connection,
      payer,
      mint,
      recipient.publicKey
    );

    // Mint tokens
    await mintTo(
      provider.connection,
      payer,
      mint,
      fromAta,
      mintAuthority,
      1000
    );

    // Test our program's transfer function
    await program.methods
      .transferTokens(new anchor.BN(500))
      .accounts({
        from: fromAta,
        to: toAta,
        authority: user.publicKey,
        tokenProgram,
      })
      .signers([user])
      .rpc();

    // Verify
    const fromBalance = await getAccount(provider.connection, fromAta);
    const toBalance = await getAccount(provider.connection, toAta);

    expect(Number(fromBalance.amount)).to.equal(500);
    expect(Number(toBalance.amount)).to.equal(500);
  });
});
```

### Rust Unit Tests

```rust
// In your program's lib.rs or separate test module

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_calculate_fee() {
        // Pure function test - no blockchain needed
        assert_eq!(calculate_fee(1000, 100), 10); // 1% of 1000
        assert_eq!(calculate_fee(1000, 500), 50); // 5% of 1000
        assert_eq!(calculate_fee(0, 100), 0);     // Zero amount
    }

    #[test]
    fn test_validate_amount() {
        assert!(validate_amount(100).is_ok());
        assert!(validate_amount(0).is_err());
        assert!(validate_amount(u64::MAX).is_ok());
    }

    #[test]
    fn test_overflow_protection() {
        // Test that checked math prevents overflow
        let result = safe_add(u64::MAX, 1);
        assert!(result.is_err());

        let result = safe_add(100, 200);
        assert_eq!(result.unwrap(), 300);
    }

    #[test]
    fn test_pda_derivation() {
        let program_id = Pubkey::new_unique();
        let user = Pubkey::new_unique();

        let (pda, bump) = Pubkey::find_program_address(
            &[b"user-account", user.as_ref()],
            &program_id,
        );

        // Verify we can recreate with the bump
        let recreated = Pubkey::create_program_address(
            &[b"user-account", user.as_ref(), &[bump]],
            &program_id,
        ).unwrap();

        assert_eq!(pda, recreated);
    }
}
```

### Testing with BankClient

```rust
use solana_program_test::*;
use solana_sdk::{
    signature::Keypair,
    signer::Signer,
    transaction::Transaction,
};

#[tokio::test]
async fn test_with_bank_client() {
    // Setup test environment
    let program_id = Pubkey::new_unique();
    let mut program_test = ProgramTest::new(
        "my_program",
        program_id,
        processor!(process_instruction),
    );

    // Start test context
    let (mut banks_client, payer, recent_blockhash) = program_test.start().await;

    // Create test transaction
    let user = Keypair::new();

    let ix = create_initialize_instruction(
        &program_id,
        &user.pubkey(),
        &payer.pubkey(),
    );

    let transaction = Transaction::new_signed_with_payer(
        &[ix],
        Some(&payer.pubkey()),
        &[&payer, &user],
        recent_blockhash,
    );

    // Execute and verify
    banks_client.process_transaction(transaction).await.unwrap();

    // Fetch and check account state
    let account = banks_client.get_account(user.pubkey()).await.unwrap().unwrap();
    assert_eq!(account.owner, program_id);
}
```

### Testing State Transitions

```typescript
describe("state machine", () => {
  it("follows correct state transitions", async () => {
    // Initial state: Created
    await program.methods
      .create()
      .accounts({ ... })
      .rpc();

    let state = await program.account.item.fetch(itemPda);
    expect(state.status).to.deep.equal({ created: {} });

    // Transition: Created -> Active
    await program.methods
      .activate()
      .accounts({ ... })
      .rpc();

    state = await program.account.item.fetch(itemPda);
    expect(state.status).to.deep.equal({ active: {} });

    // Transition: Active -> Completed
    await program.methods
      .complete()
      .accounts({ ... })
      .rpc();

    state = await program.account.item.fetch(itemPda);
    expect(state.status).to.deep.equal({ completed: {} });
  });

  it("rejects invalid transitions", async () => {
    // Cannot go from Created directly to Completed
    try {
      await program.methods
        .complete()
        .accounts({ ... })
        .rpc();

      expect.fail("Should reject invalid transition");
    } catch (err) {
      expect(err.error.errorCode.code).to.equal("InvalidStateTransition");
    }
  });
});
```

### Fuzz Testing

```typescript
import { randomBytes } from "crypto";

describe("fuzz testing", () => {
  it("handles random inputs gracefully", async () => {
    for (let i = 0; i < 100; i++) {
      const randomAmount = new anchor.BN(
        randomBytes(8).readBigUInt64LE(0).toString()
      );
      const randomString = randomBytes(32).toString("hex");

      try {
        await program.methods
          .processData(randomAmount, randomString)
          .accounts({ ... })
          .rpc();

        // If it succeeds, verify state is valid
        const account = await program.account.data.fetch(dataPda);
        expect(account).to.not.be.null;
      } catch (err) {
        // If it fails, it should be a known error
        expect(err.error.errorCode).to.not.be.undefined;
      }
    }
  });
});
```

---

## Test Utilities

### Helper Functions

```typescript
// tests/utils.ts

export async function airdrop(
  connection: Connection,
  address: PublicKey,
  amount: number = LAMPORTS_PER_SOL
): Promise<void> {
  const signature = await connection.requestAirdrop(address, amount);
  await connection.confirmTransaction(signature);
}

export async function createTestUser(
  connection: Connection
): Promise<Keypair> {
  const user = Keypair.generate();
  await airdrop(connection, user.publicKey, 10 * LAMPORTS_PER_SOL);
  return user;
}

export function expectError(
  err: any,
  errorCode: string
): void {
  expect(err.error.errorCode.code).to.equal(errorCode);
}

export async function sleep(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms));
}

export async function advanceSlots(
  connection: Connection,
  slots: number
): Promise<void> {
  // Only works on local validator
  for (let i = 0; i < slots; i++) {
    await sleep(400); // Slot time
  }
}
```

### Test Fixtures

```typescript
// tests/fixtures.ts

export interface TestContext {
  provider: anchor.AnchorProvider;
  program: Program<MyProgram>;
  admin: Keypair;
  users: Keypair[];
  mint: PublicKey;
}

export async function setupTestContext(): Promise<TestContext> {
  const provider = anchor.AnchorProvider.env();
  anchor.setProvider(provider);

  const program = anchor.workspace.MyProgram as Program<MyProgram>;
  const admin = Keypair.generate();
  const users = await Promise.all(
    [0, 1, 2].map(() => createTestUser(provider.connection))
  );

  await airdrop(provider.connection, admin.publicKey, 100 * LAMPORTS_PER_SOL);

  // Create test mint
  const mint = await createMint(
    provider.connection,
    admin,
    admin.publicKey,
    null,
    9
  );

  return { provider, program, admin, users, mint };
}
```

---

## Common Testing Patterns

### Pattern: Before/After State Comparison

```typescript
it("deposit increases balance correctly", async () => {
  const amount = 1000;

  // Before state
  const beforeBalance = (await program.account.vault.fetch(vaultPda)).balance.toNumber();
  const beforeUserSol = await provider.connection.getBalance(user.publicKey);

  // Action
  await program.methods
    .deposit(new anchor.BN(amount))
    .accounts({ vault: vaultPda, user: user.publicKey })
    .signers([user])
    .rpc();

  // After state
  const afterBalance = (await program.account.vault.fetch(vaultPda)).balance.toNumber();
  const afterUserSol = await provider.connection.getBalance(user.publicKey);

  // Assertions
  expect(afterBalance - beforeBalance).to.equal(amount);
  expect(beforeUserSol - afterUserSol).to.be.greaterThan(amount); // + fees
});
```

### Pattern: Event Testing

```typescript
it("emits correct events", async () => {
  const listener = program.addEventListener("DepositEvent", (event, slot) => {
    expect(event.user.toString()).to.equal(user.publicKey.toString());
    expect(event.amount.toNumber()).to.equal(1000);
  });

  await program.methods
    .deposit(new anchor.BN(1000))
    .accounts({ ... })
    .rpc();

  // Clean up
  await program.removeEventListener(listener);
});
```

---

## Key Takeaways

1. **Test everything** â€” bugs mean lost funds
2. **Multiple layers** â€” unit, integration, E2E
3. **Error paths** â€” test what should fail
4. **Authorization** â€” verify access controls
5. **Edge cases** â€” zero, max, overflow
6. **State transitions** â€” before/after verification
7. **Fuzz testing** â€” random inputs for robustness
8. **Local first** â€” iterate fast, deploy when ready

---
