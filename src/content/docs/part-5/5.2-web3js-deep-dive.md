---
title: "5.2 @solana/web3.js Deep Dive"
description: "Learn about 5.2 @solana/web3.js Deep Dive in the Solana onboarding curriculum."
---

> *"web3.js is your toolbox for everything Solana â€” connections, transactions, accounts, and more."*

---

## Why This Matters

@solana/web3.js is the foundational SDK for Solana development. Whether you're using Anchor, building a wallet, or writing scripts, you'll use web3.js. Understanding its core concepts deeply unlocks the full power of Solana development.

---

## ðŸŸ¢ General Understanding

### Core Components

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     @solana/web3.js Components                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                      â”‚
â”‚   Connection                                                        â”‚
â”‚   â””â”€â”€ RPC client for network communication                         â”‚
â”‚                                                                      â”‚
â”‚   Keypair                                                           â”‚
â”‚   â””â”€â”€ Ed25519 key pair for signing                                 â”‚
â”‚                                                                      â”‚
â”‚   PublicKey                                                         â”‚
â”‚   â””â”€â”€ 32-byte account address                                      â”‚
â”‚                                                                      â”‚
â”‚   Transaction                                                       â”‚
â”‚   â””â”€â”€ Container for instructions                                   â”‚
â”‚                                                                      â”‚
â”‚   TransactionInstruction                                            â”‚
â”‚   â””â”€â”€ Single operation with program, accounts, data                â”‚
â”‚                                                                      â”‚
â”‚   SystemProgram                                                     â”‚
â”‚   â””â”€â”€ Built-in program for basic operations                        â”‚
â”‚                                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Read Flow (Mental Model)

```
Get account â†’ Deserialize bytes â†’ Render UI
```

If the account schema changes, the UI breaks first. Keep IDLs/types in sync.

---

## ðŸŸ¡ PM/EM Depth

### Installation & Setup

```bash
npm install @solana/web3.js
# or
yarn add @solana/web3.js
```

### Quick Start

```typescript
import {
  Connection,
  PublicKey,
  Keypair,
  LAMPORTS_PER_SOL,
} from "@solana/web3.js";

// Connect to network
const connection = new Connection("https://api.devnet.solana.com", "confirmed");

// Generate a keypair
const keypair = Keypair.generate();
console.log("Public Key:", keypair.publicKey.toString());

// Get balance
const balance = await connection.getBalance(keypair.publicKey);
console.log("Balance:", balance / LAMPORTS_PER_SOL, "SOL");

// Request airdrop (devnet only)
const signature = await connection.requestAirdrop(
  keypair.publicKey,
  LAMPORTS_PER_SOL
);
await connection.confirmTransaction(signature);
```

---

## ðŸ”µ Engineer Depth

### Connection

```typescript
import { Connection, Commitment } from "@solana/web3.js";

// Basic connection
const connection = new Connection("https://api.devnet.solana.com");

// With commitment level
const confirmedConnection = new Connection(
  "https://api.devnet.solana.com",
  "confirmed"
);

// Full configuration
const fullConnection = new Connection(
  "https://api.devnet.solana.com",
  {
    commitment: "confirmed",
    wsEndpoint: "wss://api.devnet.solana.com",
    httpHeaders: { "x-api-key": "your-key" },
    confirmTransactionInitialTimeout: 60000,
  }
);

// Commitment levels:
// "processed" - Transaction processed (not yet confirmed)
// "confirmed" - Supermajority confirmed
// "finalized" - Maximum certainty (for high-value operations)
```

### Connection Methods

```typescript
// Account operations
const balance = await connection.getBalance(publicKey);
const accountInfo = await connection.getAccountInfo(publicKey);
const multipleAccounts = await connection.getMultipleAccountsInfo([pk1, pk2]);

// Transaction operations
const signature = await connection.sendTransaction(transaction, [signer]);
const status = await connection.confirmTransaction(signature, "confirmed");
const tx = await connection.getTransaction(signature);

// Slot/block operations
const slot = await connection.getSlot();
const blockTime = await connection.getBlockTime(slot);
const block = await connection.getBlock(slot);

// Program accounts
const accounts = await connection.getProgramAccounts(programId, {
  filters: [
    { dataSize: 100 },
    { memcmp: { offset: 0, bytes: "base58encodeddata" } },
  ],
});

// Signatures for address
const signatures = await connection.getSignaturesForAddress(publicKey, {
  limit: 10,
});
```

### Keypair

```typescript
import { Keypair } from "@solana/web3.js";
import * as fs from "fs";

// Generate new keypair
const newKeypair = Keypair.generate();

// From secret key (Uint8Array)
const fromSecret = Keypair.fromSecretKey(secretKeyArray);

// From seed (deterministic)
const seed = new Uint8Array(32).fill(1);
const fromSeed = Keypair.fromSeed(seed);

// Load from file (Solana CLI format)
const loadKeypair = (path: string): Keypair => {
  const secretKey = JSON.parse(fs.readFileSync(path, "utf-8"));
  return Keypair.fromSecretKey(Uint8Array.from(secretKey));
};
const wallet = loadKeypair("~/.config/solana/id.json");

// Properties
console.log("Public Key:", newKeypair.publicKey.toString());
console.log("Secret Key:", newKeypair.secretKey);
```

### PublicKey

```typescript
import { PublicKey } from "@solana/web3.js";

// From string
const pk1 = new PublicKey("11111111111111111111111111111111");

// From buffer
const pk2 = new PublicKey(Buffer.from(bytes));

// Well-known addresses
const systemProgram = PublicKey.default; // System program: 11111111...
const tokenProgram = new PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");

// PDA derivation
const [pda, bump] = PublicKey.findProgramAddressSync(
  [Buffer.from("seed"), userPubkey.toBuffer()],
  programId
);

// Create PDA with known bump
const pdaWithBump = PublicKey.createProgramAddressSync(
  [Buffer.from("seed"), userPubkey.toBuffer(), Buffer.from([bump])],
  programId
);

// Comparisons
const areEqual = pk1.equals(pk2);
const isOnCurve = PublicKey.isOnCurve(pk1.toBytes()); // PDAs are not

// Utility
const bytes = pk1.toBytes();   // Uint8Array
const base58 = pk1.toBase58(); // String
const buffer = pk1.toBuffer(); // Buffer
```

### Transaction

```typescript
import {
  Transaction,
  TransactionInstruction,
  SystemProgram,
  LAMPORTS_PER_SOL,
} from "@solana/web3.js";

// Create transaction
const transaction = new Transaction();

// Add instructions
transaction.add(
  SystemProgram.transfer({
    fromPubkey: sender.publicKey,
    toPubkey: recipient,
    lamports: 0.1 * LAMPORTS_PER_SOL,
  })
);

// Set metadata
transaction.recentBlockhash = (await connection.getLatestBlockhash()).blockhash;
transaction.feePayer = sender.publicKey;

// Sign
transaction.sign(sender);

// Or partial sign
transaction.partialSign(signer1);
transaction.partialSign(signer2);

// Serialize for sending
const serialized = transaction.serialize();

// Send
const signature = await connection.sendRawTransaction(serialized);
```

### TransactionInstruction

```typescript
import { TransactionInstruction, PublicKey } from "@solana/web3.js";

// Create custom instruction
const instruction = new TransactionInstruction({
  keys: [
    { pubkey: account1, isSigner: true, isWritable: true },
    { pubkey: account2, isSigner: false, isWritable: true },
    { pubkey: account3, isSigner: false, isWritable: false },
  ],
  programId: myProgramId,
  data: Buffer.from([/* instruction data */]),
});

// Using with program IDL (Anchor)
const anchorInstruction = await program.methods
  .myInstruction(arg1, arg2)
  .accounts({
    account1: pubkey1,
    account2: pubkey2,
  })
  .instruction(); // Get instruction without sending
```

### VersionedTransaction (V0)

```typescript
import {
  VersionedTransaction,
  TransactionMessage,
  AddressLookupTableAccount,
} from "@solana/web3.js";

// Create versioned transaction with lookup table
const lookupTableAccount = await connection.getAddressLookupTable(lookupTableAddress);

const message = new TransactionMessage({
  payerKey: payer.publicKey,
  recentBlockhash: (await connection.getLatestBlockhash()).blockhash,
  instructions: [instruction1, instruction2],
}).compileToV0Message([lookupTableAccount.value!]);

const versionedTx = new VersionedTransaction(message);
versionedTx.sign([payer]);

const signature = await connection.sendTransaction(versionedTx);
```

### Compute Budget

```typescript
import { ComputeBudgetProgram } from "@solana/web3.js";

// Request more compute units
const modifyComputeUnits = ComputeBudgetProgram.setComputeUnitLimit({
  units: 400_000,
});

// Set priority fee
const addPriorityFee = ComputeBudgetProgram.setComputeUnitPrice({
  microLamports: 1_000, // In micro-lamports per CU
});

// Add to transaction FIRST
transaction.add(modifyComputeUnits);
transaction.add(addPriorityFee);
transaction.add(yourInstruction);
```

### System Program

```typescript
import { SystemProgram, LAMPORTS_PER_SOL } from "@solana/web3.js";

// Transfer SOL
const transferIx = SystemProgram.transfer({
  fromPubkey: sender.publicKey,
  toPubkey: recipient,
  lamports: 0.1 * LAMPORTS_PER_SOL,
});

// Create account
const createAccountIx = SystemProgram.createAccount({
  fromPubkey: payer.publicKey,
  newAccountPubkey: newAccount.publicKey,
  lamports: await connection.getMinimumBalanceForRentExemption(100),
  space: 100,
  programId: myProgramId,
});

// Allocate space
const allocateIx = SystemProgram.allocate({
  accountPubkey: account.publicKey,
  space: 100,
});

// Assign owner
const assignIx = SystemProgram.assign({
  accountPubkey: account.publicKey,
  programId: newOwner,
});

// Create account with seed
const createWithSeedIx = SystemProgram.createAccountWithSeed({
  fromPubkey: payer.publicKey,
  basePubkey: payer.publicKey,
  seed: "my-seed",
  newAccountPubkey: derivedAddress,
  lamports: rentExempt,
  space: 100,
  programId: myProgramId,
});
```

### Account Subscriptions

```typescript
// Subscribe to account changes
const subscriptionId = connection.onAccountChange(
  accountPublicKey,
  (accountInfo, context) => {
    console.log("Account changed:", accountInfo.data);
    console.log("Slot:", context.slot);
  },
  "confirmed"
);

// Subscribe to program accounts
const programSubId = connection.onProgramAccountChange(
  programId,
  (keyedAccountInfo, context) => {
    console.log("Key:", keyedAccountInfo.accountId.toString());
    console.log("Data:", keyedAccountInfo.accountInfo.data);
  },
  "confirmed"
);

// Subscribe to logs
const logsSubId = connection.onLogs(
  programId,
  (logs, context) => {
    console.log("Signature:", logs.signature);
    console.log("Logs:", logs.logs);
  },
  "confirmed"
);

// Unsubscribe
await connection.removeAccountChangeListener(subscriptionId);
await connection.removeProgramAccountChangeListener(programSubId);
await connection.removeOnLogsListener(logsSubId);
```

### Error Handling

```typescript
import { SendTransactionError } from "@solana/web3.js";

try {
  const signature = await connection.sendTransaction(transaction, [signer]);
} catch (error) {
  if (error instanceof SendTransactionError) {
    console.log("Transaction logs:", error.logs);

    // Check for specific errors
    if (error.logs?.some(log => log.includes("insufficient funds"))) {
      console.log("Not enough SOL");
    }
  }
}

// Confirm with error details
try {
  const result = await connection.confirmTransaction(signature, "confirmed");

  if (result.value.err) {
    console.log("Transaction failed:", result.value.err);
  }
} catch (error) {
  console.log("Confirmation error:", error);
}
```

### Simulating Transactions

```typescript
// Simulate before sending
const simulation = await connection.simulateTransaction(transaction);

if (simulation.value.err) {
  console.log("Simulation failed:", simulation.value.err);
  console.log("Logs:", simulation.value.logs);
} else {
  console.log("Simulation passed");
  console.log("Compute units:", simulation.value.unitsConsumed);

  // Now safe to send
  const signature = await connection.sendTransaction(transaction, [signer], {
    skipPreflight: true, // Already simulated
  });
}
```

### Batch Operations

```typescript
// Fetch multiple accounts in one call
const accountInfos = await connection.getMultipleAccountsInfo([
  pubkey1,
  pubkey2,
  pubkey3,
]);

// Process results
accountInfos.forEach((info, index) => {
  if (info === null) {
    console.log(`Account ${index} not found`);
  } else {
    console.log(`Account ${index}:`, info.data);
  }
});

// Batch RPC calls (using direct fetch)
const requests = [
  { method: "getBalance", params: [pubkey1.toString()] },
  { method: "getBalance", params: [pubkey2.toString()] },
];

const response = await fetch(rpcUrl, {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify(requests.map((req, id) => ({
    jsonrpc: "2.0",
    id,
    ...req,
  }))),
});

const results = await response.json();
```

---

## Common Patterns

### Retry Logic

```typescript
async function sendWithRetry(
  connection: Connection,
  transaction: Transaction,
  signers: Keypair[],
  maxRetries = 3
): Promise<string> {
  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      // Refresh blockhash on retry
      transaction.recentBlockhash = (
        await connection.getLatestBlockhash()
      ).blockhash;

      transaction.sign(...signers);

      const signature = await connection.sendRawTransaction(
        transaction.serialize(),
        { skipPreflight: false }
      );

      await connection.confirmTransaction(signature, "confirmed");
      return signature;
    } catch (error) {
      if (attempt === maxRetries - 1) throw error;
      console.log(`Retry ${attempt + 1}/${maxRetries}`);
      await new Promise(r => setTimeout(r, 1000 * (attempt + 1)));
    }
  }
  throw new Error("Max retries exceeded");
}
```

### Airdrop Helper

```typescript
async function ensureFunded(
  connection: Connection,
  publicKey: PublicKey,
  minBalance: number = LAMPORTS_PER_SOL
): Promise<void> {
  const balance = await connection.getBalance(publicKey);

  if (balance < minBalance) {
    const signature = await connection.requestAirdrop(publicKey, minBalance);
    await connection.confirmTransaction(signature);
    console.log(`Airdropped ${minBalance / LAMPORTS_PER_SOL} SOL`);
  }
}
```

---

## Key Takeaways

1. **Connection is your RPC client** â€” configure commitment levels
2. **Keypair for signing** â€” secure your secret keys
3. **PublicKey is everywhere** â€” addresses, program IDs, PDAs
4. **Transaction contains instructions** â€” build, sign, send
5. **Use VersionedTransaction for ALTs** â€” more accounts per tx
6. **Set compute budget** â€” when you need more CUs
7. **Simulate before sending** â€” catch errors early
8. **Subscribe for real-time** â€” WebSocket updates

---
