---
title: "6.2 Indexing Solutions"
description: "Learn about 6.2 Indexing Solutions in the Solana onboarding curriculum."
---

> *"The blockchain stores everything â€” but finding it is another story."*

---

## Why This Matters

Solana processes thousands of transactions per second. While the network stores all data, querying historical information efficiently requires specialized indexing solutions. Understanding when and how to use indexers is crucial for building performant applications.

---

## ğŸŸ¢ General Understanding

### The Indexing Problem

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     Why Indexing is Needed                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                      â”‚
â”‚   WITHOUT INDEXING                    WITH INDEXING                 â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚   â”‚ "Find all NFTs   â”‚                â”‚ "Find all NFTs   â”‚          â”‚
â”‚   â”‚  owned by user"  â”‚                â”‚  owned by user"  â”‚          â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚            â”‚                                   â”‚                     â”‚
â”‚            â–¼                                   â–¼                     â”‚
â”‚   Scan ALL accounts                   Query indexed database        â”‚
â”‚   (millions of accounts)              (milliseconds)                â”‚
â”‚            â”‚                                   â”‚                     â”‚
â”‚            â–¼                                   â–¼                     â”‚
â”‚   â±ï¸ Minutes to hours                 â±ï¸ < 100ms                    â”‚
â”‚   ğŸ’° Expensive compute                ğŸ’° Simple lookup               â”‚
â”‚   âŒ Impractical                      âœ… Production-ready            â”‚
â”‚                                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Indexing Solutions Landscape

| Solution | Type | Best For |
|----------|------|----------|
| **Helius** | Managed API | NFTs, tokens, transactions, webhooks |
| **The Graph** | Decentralized | Custom subgraphs, complex queries |
| **Shyft** | Managed API | NFT focus, real-time data |
| **Geyser + DB** | Self-hosted | Maximum control, custom schemas |
| **Custom PostgreSQL** | Self-hosted | Specific use cases, full control |
| **Geyser Plugins** | Real-time | Custom streaming, low latency |

### Indexing Pipeline (Mental Model)

```
RPC/Geyser â†’ Ingest â†’ Transform â†’ Store â†’ Query API
```

Each step can fail independently; monitor them separately.

---

## ğŸŸ¡ PM/EM Depth

### Solution Selection Matrix

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Indexing Solution Selection                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                      â”‚
â”‚   USE CASE                         RECOMMENDED SOLUTION             â”‚
â”‚   â”œâ”€â”€ NFT galleries, marketplaces  â”œâ”€â”€ Helius DAS API               â”‚
â”‚   â”œâ”€â”€ Token analytics              â”œâ”€â”€ Helius Enhanced APIs         â”‚
â”‚   â”œâ”€â”€ Custom complex queries       â”œâ”€â”€ The Graph subgraphs          â”‚
â”‚   â”œâ”€â”€ Real-time streaming          â”œâ”€â”€ Geyser plugins               â”‚
â”‚   â”œâ”€â”€ Historical transaction data  â”œâ”€â”€ Helius/Shyft APIs            â”‚
â”‚   â””â”€â”€ Full control requirements    â””â”€â”€ Custom indexer               â”‚
â”‚                                                                      â”‚
â”‚   TEAM CONSIDERATIONS                                                â”‚
â”‚   â”œâ”€â”€ < 3 devs: Use managed solutions (Helius, Shyft)               â”‚
â”‚   â”œâ”€â”€ 3-10 devs: Consider The Graph or managed + custom             â”‚
â”‚   â””â”€â”€ > 10 devs: Custom indexer may be justified                    â”‚
â”‚                                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Cost vs Complexity Trade-offs

| Approach | Setup Time | Maintenance | Cost | Flexibility |
|----------|------------|-------------|------|-------------|
| Managed APIs | Hours | None | $$-$$$ | Limited |
| The Graph | Days | Low | $-$$ | High |
| Geyser + Custom | Weeks | High | $-$$$$ | Maximum |
| Full Custom | Months | Very High | $$$$$ | Maximum |

---

## ğŸ”µ Engineer Depth

### Helius DAS API (Digital Asset Standard)

```typescript
// Helius DAS API for NFTs and compressed NFTs
const HELIUS_API_KEY = process.env.HELIUS_API_KEY;

interface DASAsset {
  id: string;
  content: {
    metadata: {
      name: string;
      symbol: string;
      description: string;
    };
    links: {
      image: string;
    };
  };
  ownership: {
    owner: string;
  };
  compression?: {
    compressed: boolean;
    tree: string;
  };
}

// Get all assets by owner
async function getAssetsByOwner(
  owner: string,
  page = 1,
  limit = 1000
): Promise<DASAsset[]> {
  const response = await fetch(
    `https://mainnet.helius-rpc.com/?api-key=${HELIUS_API_KEY}`,
    {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        jsonrpc: "2.0",
        id: "my-id",
        method: "getAssetsByOwner",
        params: {
          ownerAddress: owner,
          page,
          limit,
          displayOptions: {
            showFungible: true,
            showNativeBalance: true,
          },
        },
      }),
    }
  );

  const data = await response.json();
  return data.result.items;
}

// Get single asset by ID
async function getAsset(assetId: string): Promise<DASAsset> {
  const response = await fetch(
    `https://mainnet.helius-rpc.com/?api-key=${HELIUS_API_KEY}`,
    {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        jsonrpc: "2.0",
        id: "my-id",
        method: "getAsset",
        params: { id: assetId },
      }),
    }
  );

  const data = await response.json();
  return data.result;
}

// Search assets with filters
async function searchAssets(params: {
  ownerAddress?: string;
  creatorAddress?: string;
  collection?: string;
  burnt?: boolean;
}) {
  const response = await fetch(
    `https://mainnet.helius-rpc.com/?api-key=${HELIUS_API_KEY}`,
    {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        jsonrpc: "2.0",
        id: "my-id",
        method: "searchAssets",
        params: {
          ...params,
          page: 1,
          limit: 1000,
        },
      }),
    }
  );

  return response.json();
}

// Get assets by collection
async function getAssetsByGroup(
  groupKey: string,
  groupValue: string
) {
  const response = await fetch(
    `https://mainnet.helius-rpc.com/?api-key=${HELIUS_API_KEY}`,
    {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        jsonrpc: "2.0",
        id: "my-id",
        method: "getAssetsByGroup",
        params: {
          groupKey,  // "collection"
          groupValue, // collection address
          page: 1,
          limit: 1000,
        },
      }),
    }
  );

  return response.json();
}
```

### Transaction History Indexing

```typescript
// Helius parsed transaction history
interface ParsedTransaction {
  signature: string;
  timestamp: number;
  type: string;
  source: string;
  fee: number;
  description: string;
  nativeTransfers?: Array<{
    fromUserAccount: string;
    toUserAccount: string;
    amount: number;
  }>;
  tokenTransfers?: Array<{
    fromUserAccount: string;
    toUserAccount: string;
    tokenAmount: number;
    mint: string;
  }>;
}

async function getTransactionHistory(
  address: string,
  options: {
    before?: string;
    limit?: number;
    type?: string;
  } = {}
): Promise<ParsedTransaction[]> {
  const params = new URLSearchParams({
    "api-key": HELIUS_API_KEY,
  });

  if (options.before) params.append("before", options.before);
  if (options.limit) params.append("limit", options.limit.toString());
  if (options.type) params.append("type", options.type);

  const response = await fetch(
    `https://api.helius.xyz/v0/addresses/${address}/transactions?${params}`
  );

  return response.json();
}

// Paginate through all history
async function getAllTransactionHistory(address: string): Promise<ParsedTransaction[]> {
  const allTransactions: ParsedTransaction[] = [];
  let before: string | undefined;

  while (true) {
    const batch = await getTransactionHistory(address, {
      before,
      limit: 100,
    });

    if (batch.length === 0) break;

    allTransactions.push(...batch);
    before = batch[batch.length - 1].signature;

    // Rate limiting
    await new Promise(r => setTimeout(r, 100));
  }

  return allTransactions;
}
```

### Custom Indexer with Geyser

```typescript
// Geyser plugin streams account updates
// This runs as a validator plugin (Rust)

// TypeScript client to consume Geyser stream
import { Client } from "@triton-one/yellowstone-grpc";

interface AccountUpdate {
  pubkey: string;
  lamports: bigint;
  owner: string;
  data: Buffer;
  slot: bigint;
}

class GeyserIndexer {
  private client: Client;
  private db: Database;

  constructor(geyserEndpoint: string, db: Database) {
    this.client = new Client(geyserEndpoint, undefined, undefined);
    this.db = db;
  }

  async startIndexing(programId: string): Promise<void> {
    const stream = await this.client.subscribe();

    // Subscribe to program accounts
    await stream.write({
      accounts: {
        myFilter: {
          owner: [programId],
        },
      },
      slots: {},
      transactions: {},
      blocks: {},
      blocksMeta: {},
      commitment: 1, // Confirmed
    });

    // Process updates
    for await (const message of stream) {
      if (message.account) {
        await this.processAccountUpdate({
          pubkey: message.account.account.pubkey.toString(),
          lamports: message.account.account.lamports,
          owner: message.account.account.owner.toString(),
          data: Buffer.from(message.account.account.data),
          slot: message.account.slot,
        });
      }
    }
  }

  private async processAccountUpdate(update: AccountUpdate): Promise<void> {
    // Parse account data based on your program's schema
    const parsed = this.parseAccountData(update.data);

    // Store in database
    await this.db.upsert("accounts", {
      pubkey: update.pubkey,
      slot: update.slot,
      ...parsed,
    });
  }

  private parseAccountData(data: Buffer): Record<string, any> {
    // Implement your account parsing logic
    // This depends on your program's account structure
    return {};
  }
}
```

### The Graph Subgraph

```yaml
# subgraph.yaml
specVersion: 0.0.5
schema:
  file: ./schema.graphql
dataSources:
  - kind: solana
    name: MyProgram
    network: solana-mainnet-beta
    source:
      address: "YourProgramId..."
      startBlock: 150000000
    mapping:
      kind: solana/BlockHandler
      apiVersion: 0.0.5
      language: wasm/assemblyscript
      entities:
        - Account
        - Transaction
      blockHandlers:
        - handler: handleBlock
      file: ./src/mapping.ts
```

```graphql
# schema.graphql
type Account @entity {
  id: ID!
  owner: String!
  balance: BigInt!
  lastUpdated: BigInt!
  transactions: [Transaction!]! @derivedFrom(field: "account")
}

type Transaction @entity {
  id: ID!
  account: Account!
  amount: BigInt!
  timestamp: BigInt!
  type: String!
}
```

```typescript
// src/mapping.ts
import { Block } from "@graphprotocol/graph-ts";
import { Account, Transaction } from "../generated/schema";

export function handleBlock(block: Block): void {
  // Process instructions in the block
  for (let i = 0; i < block.instructions.length; i++) {
    const instruction = block.instructions[i];

    if (instruction.programId.equals(PROGRAM_ID)) {
      processInstruction(instruction, block);
    }
  }
}

function processInstruction(instruction: Instruction, block: Block): void {
  // Parse and store data
  const data = instruction.data;
  const accounts = instruction.accounts;

  // Create entities
  let account = Account.load(accounts[0].toString());
  if (!account) {
    account = new Account(accounts[0].toString());
    account.owner = accounts[1].toString();
    account.balance = BigInt.zero();
  }

  // Update based on instruction
  account.lastUpdated = block.slot;
  account.save();
}
```

### PostgreSQL Custom Indexer

```typescript
// Custom indexer with PostgreSQL storage
import { Pool } from "pg";
import { Connection, PublicKey } from "@solana/web3.js";

interface IndexedAccount {
  pubkey: string;
  owner: string;
  data: any;
  slot: number;
  updated_at: Date;
}

class PostgresIndexer {
  private pool: Pool;
  private connection: Connection;
  private programId: PublicKey;

  constructor(dbUrl: string, rpcUrl: string, programId: string) {
    this.pool = new Pool({ connectionString: dbUrl });
    this.connection = new Connection(rpcUrl);
    this.programId = new PublicKey(programId);
  }

  async initialize(): Promise<void> {
    await this.pool.query(`
      CREATE TABLE IF NOT EXISTS indexed_accounts (
        pubkey TEXT PRIMARY KEY,
        owner TEXT NOT NULL,
        data JSONB,
        slot BIGINT NOT NULL,
        updated_at TIMESTAMP DEFAULT NOW()
      );

      CREATE INDEX IF NOT EXISTS idx_owner ON indexed_accounts(owner);
      CREATE INDEX IF NOT EXISTS idx_slot ON indexed_accounts(slot);
      CREATE INDEX IF NOT EXISTS idx_data ON indexed_accounts USING GIN(data);
    `);
  }

  async indexAllAccounts(): Promise<void> {
    console.log("Starting full index...");

    const accounts = await this.connection.getProgramAccounts(this.programId);

    for (const { pubkey, account } of accounts) {
      const parsed = this.parseAccountData(account.data);

      await this.pool.query(
        `INSERT INTO indexed_accounts (pubkey, owner, data, slot)
         VALUES ($1, $2, $3, $4)
         ON CONFLICT (pubkey)
         DO UPDATE SET data = $3, slot = $4, updated_at = NOW()`,
        [
          pubkey.toString(),
          account.owner.toString(),
          JSON.stringify(parsed),
          await this.connection.getSlot(),
        ]
      );
    }

    console.log(`Indexed ${accounts.length} accounts`);
  }

  async subscribeToUpdates(): Promise<void> {
    this.connection.onProgramAccountChange(
      this.programId,
      async (accountInfo, context) => {
        const parsed = this.parseAccountData(accountInfo.accountInfo.data);

        await this.pool.query(
          `INSERT INTO indexed_accounts (pubkey, owner, data, slot)
           VALUES ($1, $2, $3, $4)
           ON CONFLICT (pubkey)
           DO UPDATE SET data = $3, slot = $4, updated_at = NOW()`,
          [
            accountInfo.accountId.toString(),
            accountInfo.accountInfo.owner.toString(),
            JSON.stringify(parsed),
            context.slot,
          ]
        );
      },
      "confirmed"
    );
  }

  // Query methods
  async getAccountsByOwner(owner: string): Promise<IndexedAccount[]> {
    const result = await this.pool.query(
      `SELECT * FROM indexed_accounts WHERE owner = $1`,
      [owner]
    );
    return result.rows;
  }

  async queryByData(jsonPath: string, value: any): Promise<IndexedAccount[]> {
    const result = await this.pool.query(
      `SELECT * FROM indexed_accounts WHERE data @> $1`,
      [JSON.stringify({ [jsonPath]: value })]
    );
    return result.rows;
  }

  private parseAccountData(data: Buffer): any {
    // Implement your parsing logic
    return {};
  }
}
```

### Caching Layer

```typescript
import Redis from "ioredis";

class CachedIndexer {
  private indexer: PostgresIndexer;
  private redis: Redis;
  private cacheTTL = 60; // seconds

  constructor(indexer: PostgresIndexer, redisUrl: string) {
    this.indexer = indexer;
    this.redis = new Redis(redisUrl);
  }

  async getAccountsByOwner(owner: string): Promise<IndexedAccount[]> {
    const cacheKey = `accounts:owner:${owner}`;

    // Check cache
    const cached = await this.redis.get(cacheKey);
    if (cached) {
      return JSON.parse(cached);
    }

    // Query indexer
    const accounts = await this.indexer.getAccountsByOwner(owner);

    // Cache result
    await this.redis.setex(
      cacheKey,
      this.cacheTTL,
      JSON.stringify(accounts)
    );

    return accounts;
  }

  async invalidateCache(owner: string): Promise<void> {
    const cacheKey = `accounts:owner:${owner}`;
    await this.redis.del(cacheKey);
  }

  // Subscribe to updates and invalidate cache
  async subscribeToUpdates(): Promise<void> {
    this.indexer.subscribeToUpdates();

    // Also invalidate related cache entries
    // Implementation depends on your update logic
  }
}
```

---

## Common Patterns

### Hybrid Approach

```typescript
// Use managed APIs for standard queries, custom for specific needs
class HybridIndexer {
  private helius: HeliusClient;
  private customIndexer: PostgresIndexer;

  async getAssets(owner: string) {
    // Use Helius for NFT data (their specialty)
    return this.helius.getAssetsByOwner(owner);
  }

  async getCustomProgramData(filters: any) {
    // Use custom indexer for program-specific data
    return this.customIndexer.queryByData(filters);
  }

  async getTransactionHistory(address: string) {
    // Use Helius for parsed transactions
    return this.helius.getTransactionHistory(address);
  }
}
```

---

## Key Takeaways

1. **Don't query RPC for historical data** â€” use indexers
2. **Managed APIs first** â€” Helius, Shyft handle most use cases
3. **DAS API for NFTs** â€” standard for NFT/token queries
4. **Geyser for real-time** â€” lowest latency streaming
5. **Custom indexers for specific needs** â€” complex queries, full control
6. **Cache aggressively** â€” reduce indexer load
7. **Consider maintenance burden** â€” managed vs self-hosted
8. **Plan for scale** â€” indexer choice affects scaling options

---
