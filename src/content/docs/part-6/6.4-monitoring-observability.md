---
title: "6.4 Monitoring & Observability"
description: "Learn about 6.4 Monitoring & Observability in the Solana onboarding curriculum."
---

> *"You can't fix what you can't see â€” observability is not optional in production."*

---

## Why This Matters

Solana applications have unique monitoring challenges: transactions can fail silently, RPC providers can rate limit you, and on-chain state changes happen in milliseconds. A comprehensive observability strategy helps you understand system behavior, detect issues early, and debug problems quickly.

---

## ðŸŸ¢ General Understanding

### Observability Pillars

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Three Pillars of Observability                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                      â”‚
â”‚   METRICS                  LOGS                    TRACES           â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚   â”‚ Quantitative â”‚         â”‚ Qualitative  â”‚        â”‚ Distributed  â”‚ â”‚
â”‚   â”‚ measurements â”‚         â”‚ events       â”‚        â”‚ causality    â”‚ â”‚
â”‚   â”‚              â”‚         â”‚              â”‚        â”‚              â”‚ â”‚
â”‚   â”‚ â€¢ Tx success â”‚         â”‚ â€¢ Errors     â”‚        â”‚ â€¢ Request    â”‚ â”‚
â”‚   â”‚   rate       â”‚         â”‚ â€¢ Warnings   â”‚        â”‚   flow       â”‚ â”‚
â”‚   â”‚ â€¢ Latency    â”‚         â”‚ â€¢ Debug info â”‚        â”‚ â€¢ Dependenciesâ”‚ â”‚
â”‚   â”‚ â€¢ CU usage   â”‚         â”‚ â€¢ Audit trailâ”‚        â”‚ â€¢ Timing     â”‚ â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                      â”‚
â”‚   SOLANA-SPECIFIC ADDITIONS                                         â”‚
â”‚   â”œâ”€â”€ Transaction signatures for linking                            â”‚
â”‚   â”œâ”€â”€ Slot numbers for ordering                                     â”‚
â”‚   â”œâ”€â”€ Program logs for debugging                                    â”‚
â”‚   â””â”€â”€ Account state snapshots                                       â”‚
â”‚                                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### What to Monitor

| Category | Metrics | Why |
|----------|---------|-----|
| **Transactions** | Success rate, latency, CU usage | Core functionality |
| **RPC** | Response time, error rate, quota | Infrastructure health |
| **On-chain** | Account balances, program state | Business logic |
| **Users** | Active wallets, transaction volume | Engagement |
| **Costs** | SOL spent on fees, rent | Economics |

### Alerting Flow (Mental Model)

```
Metric spike â†’ Alert â†’ Triage â†’ Fix â†’ Postmortem
```

If you skip triage discipline, you will chase noise instead of root causes.

---

## ðŸŸ¡ PM/EM Depth

### Monitoring Stack

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Recommended Monitoring Stack                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                      â”‚
â”‚   COLLECTION                STORAGE              VISUALIZATION      â”‚
â”‚   â”œâ”€â”€ Application code      â”œâ”€â”€ Prometheus       â”œâ”€â”€ Grafana        â”‚
â”‚   â”œâ”€â”€ Helius webhooks       â”œâ”€â”€ InfluxDB         â”œâ”€â”€ Datadog        â”‚
â”‚   â”œâ”€â”€ RPC instrumentation   â”œâ”€â”€ TimescaleDB      â””â”€â”€ Custom         â”‚
â”‚   â””â”€â”€ Log aggregators       â””â”€â”€ Elasticsearch         dashboards     â”‚
â”‚                                                                      â”‚
â”‚   ALERTING                  ANALYSIS                                â”‚
â”‚   â”œâ”€â”€ PagerDuty             â”œâ”€â”€ Distributed tracing                 â”‚
â”‚   â”œâ”€â”€ OpsGenie              â”œâ”€â”€ Log analysis                        â”‚
â”‚   â””â”€â”€ Slack/Discord         â””â”€â”€ Anomaly detection                   â”‚
â”‚                                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Key Performance Indicators (KPIs)

| KPI | Target (example) | Alert Threshold (example) |
|-----|------------------|---------------------------|
| Transaction success rate | > 99% | < 95% |
| P50 latency | < 500ms | > 1s |
| P99 latency | < 2s | > 5s |
| RPC error rate | < 1% | > 5% |
| Confirmation time | < 30s | > 60s |
| Daily active wallets | Growing | -20% week/week |

These thresholds are illustrative; tune to your product and current network conditions.

### State Compression (Compressed NFTs)

State compression stores large datasets (like NFTs) in a Merkle tree:

- On-chain accounts store only the tree roots and small proofs.
- Individual assets are proven with Merkle proofs, not full on-chain data.
- Indexers or RPC extensions are typically required to query ownership.

**Operational Implications**
- Monitor tree update latency (mint/burn/transfer indexing).
- Ensure your indexer supports compressed assets.
- Treat proofs as part of your data integrity checks.

---

## ðŸ”µ Engineer Depth

### Transaction Monitoring

```typescript
import { Connection, Transaction, Keypair } from "@solana/web3.js";
import * as prometheus from "prom-client";

// Prometheus metrics
const txSuccessCounter = new prometheus.Counter({
  name: "solana_tx_success_total",
  help: "Total successful transactions",
  labelNames: ["program", "instruction"],
});

const txFailureCounter = new prometheus.Counter({
  name: "solana_tx_failure_total",
  help: "Total failed transactions",
  labelNames: ["program", "instruction", "error_type"],
});

const txLatencyHistogram = new prometheus.Histogram({
  name: "solana_tx_latency_seconds",
  help: "Transaction confirmation latency",
  labelNames: ["program", "instruction"],
  buckets: [0.1, 0.5, 1, 2, 5, 10, 30],
});

const cuUsageHistogram = new prometheus.Histogram({
  name: "solana_compute_units_used",
  help: "Compute units consumed per transaction",
  labelNames: ["program", "instruction"],
  buckets: [10000, 50000, 100000, 200000, 400000, 800000, 1400000],
});

interface MonitoredTxResult {
  signature: string;
  success: boolean;
  latencyMs: number;
  computeUnits?: number;
  error?: string;
  slot: number;
}

async function sendAndMonitorTransaction(
  connection: Connection,
  transaction: Transaction,
  signers: Keypair[],
  metadata: { program: string; instruction: string }
): Promise<MonitoredTxResult> {
  const startTime = Date.now();

  try {
    // Get latest blockhash
    const { blockhash, lastValidBlockHeight } =
      await connection.getLatestBlockhash("confirmed");

    transaction.recentBlockhash = blockhash;
    transaction.feePayer = signers[0].publicKey;
    transaction.sign(...signers);

    // Send transaction
    const signature = await connection.sendRawTransaction(
      transaction.serialize(),
      { skipPreflight: false }
    );

    // Confirm transaction
    const confirmation = await connection.confirmTransaction(
      {
        signature,
        blockhash,
        lastValidBlockHeight,
      },
      "confirmed"
    );

    const latencyMs = Date.now() - startTime;

    if (confirmation.value.err) {
      // Transaction failed on-chain
      txFailureCounter.inc({
        program: metadata.program,
        instruction: metadata.instruction,
        error_type: "on_chain_error",
      });

      return {
        signature,
        success: false,
        latencyMs,
        error: JSON.stringify(confirmation.value.err),
        slot: confirmation.context.slot,
      };
    }

    // Get transaction details for CU usage
    const txDetails = await connection.getTransaction(signature, {
      commitment: "confirmed",
    });

    const computeUnits = txDetails?.meta?.computeUnitsConsumed || 0;

    // Record metrics
    txSuccessCounter.inc({
      program: metadata.program,
      instruction: metadata.instruction,
    });

    txLatencyHistogram.observe(
      { program: metadata.program, instruction: metadata.instruction },
      latencyMs / 1000
    );

    cuUsageHistogram.observe(
      { program: metadata.program, instruction: metadata.instruction },
      computeUnits
    );

    return {
      signature,
      success: true,
      latencyMs,
      computeUnits,
      slot: confirmation.context.slot,
    };
  } catch (error) {
    const latencyMs = Date.now() - startTime;

    txFailureCounter.inc({
      program: metadata.program,
      instruction: metadata.instruction,
      error_type: error instanceof Error ? error.name : "unknown",
    });

    return {
      signature: "",
      success: false,
      latencyMs,
      error: error instanceof Error ? error.message : "Unknown error",
      slot: 0,
    };
  }
}
```

### RPC Health Monitoring

```typescript
const rpcLatencyHistogram = new prometheus.Histogram({
  name: "rpc_request_latency_seconds",
  help: "RPC request latency",
  labelNames: ["method", "provider"],
  buckets: [0.01, 0.05, 0.1, 0.5, 1, 2, 5],
});

const rpcErrorCounter = new prometheus.Counter({
  name: "rpc_errors_total",
  help: "Total RPC errors",
  labelNames: ["method", "provider", "error_type"],
});

const rpcRateLimitCounter = new prometheus.Counter({
  name: "rpc_rate_limits_total",
  help: "Total RPC rate limit hits",
  labelNames: ["provider"],
});

class MonitoredConnection {
  private connection: Connection;
  private provider: string;

  constructor(rpcUrl: string, provider: string) {
    this.connection = new Connection(rpcUrl, "confirmed");
    this.provider = provider;
  }

  async getBalance(pubkey: PublicKey): Promise<number> {
    return this.instrument("getBalance", () =>
      this.connection.getBalance(pubkey)
    );
  }

  async getAccountInfo(pubkey: PublicKey) {
    return this.instrument("getAccountInfo", () =>
      this.connection.getAccountInfo(pubkey)
    );
  }

  private async instrument<T>(
    method: string,
    operation: () => Promise<T>
  ): Promise<T> {
    const startTime = Date.now();

    try {
      const result = await operation();

      rpcLatencyHistogram.observe(
        { method, provider: this.provider },
        (Date.now() - startTime) / 1000
      );

      return result;
    } catch (error) {
      const errorType = this.classifyError(error);

      rpcErrorCounter.inc({
        method,
        provider: this.provider,
        error_type: errorType,
      });

      if (errorType === "rate_limit") {
        rpcRateLimitCounter.inc({ provider: this.provider });
      }

      throw error;
    }
  }

  private classifyError(error: any): string {
    const message = error?.message?.toLowerCase() || "";

    if (message.includes("rate limit") || error?.status === 429) {
      return "rate_limit";
    }
    if (message.includes("timeout")) {
      return "timeout";
    }
    if (error?.status >= 500) {
      return "server_error";
    }
    return "unknown";
  }
}
```

### Structured Logging

```typescript
import pino from "pino";

interface SolanaLogContext {
  signature?: string;
  slot?: number;
  program?: string;
  instruction?: string;
  wallet?: string;
  amount?: number;
}

const logger = pino({
  level: process.env.LOG_LEVEL || "info",
  formatters: {
    level: (label) => ({ level: label }),
  },
  timestamp: pino.stdTimeFunctions.isoTime,
});

function createTxLogger(baseContext: SolanaLogContext) {
  return logger.child(baseContext);
}

// Usage
async function processDeposit(
  wallet: PublicKey,
  amount: number,
  signature: string
) {
  const txLogger = createTxLogger({
    signature,
    program: "vault",
    instruction: "deposit",
    wallet: wallet.toString(),
    amount,
  });

  txLogger.info("Starting deposit");

  try {
    // Process deposit
    const result = await executeDeposit(wallet, amount);

    txLogger.info({ slot: result.slot, cu: result.computeUnits }, "Deposit successful");
  } catch (error) {
    txLogger.error(
      { error: error instanceof Error ? error.message : "Unknown" },
      "Deposit failed"
    );
    throw error;
  }
}
```

### Helius Webhook Monitoring

```typescript
// Webhook receiver for Helius transaction monitoring
import express from "express";

const app = express();
app.use(express.json());

// Metrics for webhook events
const webhookEventsCounter = new prometheus.Counter({
  name: "helius_webhook_events_total",
  help: "Total webhook events received",
  labelNames: ["type", "program"],
});

const webhookLatencyHistogram = new prometheus.Histogram({
  name: "helius_webhook_latency_seconds",
  help: "Time from transaction to webhook receipt",
  labelNames: ["type"],
  buckets: [0.5, 1, 2, 5, 10, 30, 60],
});

interface HeliusWebhookPayload {
  type: string;
  signature: string;
  timestamp: number;
  slot: number;
  nativeTransfers?: Array<{
    fromUserAccount: string;
    toUserAccount: string;
    amount: number;
  }>;
  tokenTransfers?: Array<{
    mint: string;
    fromUserAccount: string;
    toUserAccount: string;
    tokenAmount: number;
  }>;
  accountData?: Array<{
    account: string;
    nativeBalanceChange: number;
  }>;
}

app.post("/webhooks/helius", async (req, res) => {
  const payload = req.body as HeliusWebhookPayload[];

  for (const event of payload) {
    // Calculate latency (timestamp is in seconds)
    const latencySeconds = Date.now() / 1000 - event.timestamp;

    webhookEventsCounter.inc({
      type: event.type,
      program: extractProgram(event),
    });

    webhookLatencyHistogram.observe(
      { type: event.type },
      latencySeconds
    );

    // Process the event
    await processWebhookEvent(event);
  }

  res.status(200).send("OK");
});

async function processWebhookEvent(event: HeliusWebhookPayload) {
  // Store in database, trigger alerts, update state, etc.
  logger.info({
    signature: event.signature,
    type: event.type,
    slot: event.slot,
  }, "Webhook event processed");
}

function extractProgram(event: HeliusWebhookPayload): string {
  // Extract program from event details
  return "unknown";
}
```

### Grafana Dashboard

```json
{
  "dashboard": {
    "title": "Solana Application Dashboard",
    "panels": [
      {
        "title": "Transaction Success Rate",
        "type": "stat",
        "targets": [
          {
            "expr": "sum(rate(solana_tx_success_total[5m])) / (sum(rate(solana_tx_success_total[5m])) + sum(rate(solana_tx_failure_total[5m]))) * 100",
            "legendFormat": "Success Rate %"
          }
        ],
        "thresholds": {
          "steps": [
            { "color": "red", "value": null },
            { "color": "yellow", "value": 95 },
            { "color": "green", "value": 99 }
          ]
        }
      },
      {
        "title": "Transaction Latency",
        "type": "graph",
        "targets": [
          {
            "expr": "histogram_quantile(0.50, rate(solana_tx_latency_seconds_bucket[5m]))",
            "legendFormat": "P50"
          },
          {
            "expr": "histogram_quantile(0.99, rate(solana_tx_latency_seconds_bucket[5m]))",
            "legendFormat": "P99"
          }
        ]
      },
      {
        "title": "RPC Errors by Type",
        "type": "timeseries",
        "targets": [
          {
            "expr": "sum by (error_type) (rate(rpc_errors_total[5m]))",
            "legendFormat": "{{error_type}}"
          }
        ]
      },
      {
        "title": "Compute Units Usage",
        "type": "heatmap",
        "targets": [
          {
            "expr": "sum(rate(solana_compute_units_used_bucket[5m])) by (le)",
            "format": "heatmap"
          }
        ]
      }
    ]
  }
}
```

### Alerting Rules

```yaml
# alerting-rules.yml
groups:
  - name: solana-alerts
    rules:
      - alert: HighTransactionFailureRate
        expr: |
          sum(rate(solana_tx_failure_total[5m])) /
          (sum(rate(solana_tx_success_total[5m])) + sum(rate(solana_tx_failure_total[5m])))
          > 0.05
        for: 5m
        labels:
          severity: critical
        annotations:
          summary: "High transaction failure rate"
          description: "Transaction failure rate is {{ $value | humanizePercentage }}"

      - alert: HighTransactionLatency
        expr: |
          histogram_quantile(0.99, rate(solana_tx_latency_seconds_bucket[5m])) > 5
        for: 10m
        labels:
          severity: warning
        annotations:
          summary: "High transaction latency"
          description: "P99 latency is {{ $value | humanizeDuration }}"

      - alert: RPCRateLimiting
        expr: |
          sum(rate(rpc_rate_limits_total[5m])) > 1
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "RPC rate limiting detected"
          description: "Provider {{ $labels.provider }} is rate limiting"

      - alert: LowSOLBalance
        expr: |
          solana_wallet_balance_sol{wallet="fee_payer"} < 1
        for: 1m
        labels:
          severity: critical
        annotations:
          summary: "Low SOL balance"
          description: "Fee payer balance is {{ $value }} SOL"

      - alert: WebhookLag
        expr: |
          histogram_quantile(0.99, rate(helius_webhook_latency_seconds_bucket[5m])) > 30
        for: 10m
        labels:
          severity: warning
        annotations:
          summary: "High webhook latency"
          description: "Webhook delivery lag is {{ $value | humanizeDuration }}"
```

### Account Balance Monitoring

```typescript
// Monitor critical account balances
const accountBalanceGauge = new prometheus.Gauge({
  name: "solana_wallet_balance_sol",
  help: "Account balance in SOL",
  labelNames: ["wallet", "name"],
});

interface MonitoredWallet {
  address: string;
  name: string;
  minBalance: number;
}

class BalanceMonitor {
  private connection: Connection;
  private wallets: MonitoredWallet[];
  private interval: NodeJS.Timeout | null = null;

  constructor(connection: Connection, wallets: MonitoredWallet[]) {
    this.connection = connection;
    this.wallets = wallets;
  }

  start(intervalMs = 60000): void {
    this.updateBalances();
    this.interval = setInterval(() => this.updateBalances(), intervalMs);
  }

  stop(): void {
    if (this.interval) {
      clearInterval(this.interval);
      this.interval = null;
    }
  }

  private async updateBalances(): Promise<void> {
    for (const wallet of this.wallets) {
      try {
        const balance = await this.connection.getBalance(
          new PublicKey(wallet.address)
        );

        const balanceSol = balance / LAMPORTS_PER_SOL;

        accountBalanceGauge.set(
          { wallet: wallet.address, name: wallet.name },
          balanceSol
        );

        if (balanceSol < wallet.minBalance) {
          logger.warn({
            wallet: wallet.name,
            balance: balanceSol,
            minBalance: wallet.minBalance,
          }, "Low balance warning");
        }
      } catch (error) {
        logger.error({
          wallet: wallet.name,
          error: error instanceof Error ? error.message : "Unknown",
        }, "Failed to fetch balance");
      }
    }
  }
}

// Usage
const balanceMonitor = new BalanceMonitor(connection, [
  {
    address: "Fee111...",
    name: "fee_payer",
    minBalance: 1,
  },
  {
    address: "Vault...",
    name: "protocol_vault",
    minBalance: 10,
  },
]);

balanceMonitor.start();
```

---

## Common Patterns

### Error Classification

```typescript
enum TransactionErrorType {
  INSUFFICIENT_FUNDS = "insufficient_funds",
  PROGRAM_ERROR = "program_error",
  SLIPPAGE = "slippage",
  TIMEOUT = "timeout",
  RPC_ERROR = "rpc_error",
  UNKNOWN = "unknown",
}

function classifyTransactionError(error: any): TransactionErrorType {
  const message = error?.message?.toLowerCase() || "";
  const logs = error?.logs || [];

  if (message.includes("insufficient funds") ||
      message.includes("insufficient lamports")) {
    return TransactionErrorType.INSUFFICIENT_FUNDS;
  }

  if (logs.some((log: string) => log.includes("slippage"))) {
    return TransactionErrorType.SLIPPAGE;
  }

  if (message.includes("timeout") ||
      message.includes("blockhash not found")) {
    return TransactionErrorType.TIMEOUT;
  }

  if (error?.logs) {
    return TransactionErrorType.PROGRAM_ERROR;
  }

  return TransactionErrorType.UNKNOWN;
}
```

---

## Key Takeaways

1. **Instrument everything** â€” transactions, RPC calls, webhooks
2. **Use structured logging** â€” include signatures, slots, context
3. **Set up dashboards** â€” visualize trends and anomalies
4. **Configure alerts** â€” catch issues before users do
5. **Monitor costs** â€” track SOL usage and RPC quotas
6. **Track business metrics** â€” not just technical health
7. **Use webhooks** â€” for real-time event monitoring
8. **Test your alerting** â€” verify alerts fire correctly

---
