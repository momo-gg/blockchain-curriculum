---
title: "6.5 Security Best Practices"
description: "Learn about 6.5 Security Best Practices in the Solana onboarding curriculum."
---

> *"In blockchain, security is not a feature â€” it's the foundation."*

---

## Why This Matters

Solana applications handle real value. A single vulnerability can lead to loss of funds, damaged reputation, and legal liability. Security must be considered at every layer: smart contracts, client applications, infrastructure, and operations.

---

## ğŸŸ¢ General Understanding

### Security Layers

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Security Defense Layers                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                      â”‚
â”‚   LAYER 1: SMART CONTRACT                                           â”‚
â”‚   â”œâ”€â”€ Input validation                                              â”‚
â”‚   â”œâ”€â”€ Access control                                                â”‚
â”‚   â”œâ”€â”€ Reentrancy protection                                         â”‚
â”‚   â””â”€â”€ Safe math operations                                          â”‚
â”‚                                                                      â”‚
â”‚   LAYER 2: CLIENT APPLICATION                                       â”‚
â”‚   â”œâ”€â”€ Secure key management                                         â”‚
â”‚   â”œâ”€â”€ Transaction verification                                      â”‚
â”‚   â”œâ”€â”€ Phishing protection                                           â”‚
â”‚   â””â”€â”€ Input sanitization                                            â”‚
â”‚                                                                      â”‚
â”‚   LAYER 3: INFRASTRUCTURE                                           â”‚
â”‚   â”œâ”€â”€ RPC endpoint security                                         â”‚
â”‚   â”œâ”€â”€ API authentication                                            â”‚
â”‚   â”œâ”€â”€ Network isolation                                             â”‚
â”‚   â””â”€â”€ Secret management                                             â”‚
â”‚                                                                      â”‚
â”‚   LAYER 4: OPERATIONS                                               â”‚
â”‚   â”œâ”€â”€ Access controls                                               â”‚
â”‚   â”œâ”€â”€ Audit logging                                                 â”‚
â”‚   â”œâ”€â”€ Incident response                                             â”‚
â”‚   â””â”€â”€ Key rotation                                                  â”‚
â”‚                                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Common Attack Vectors

| Attack | Impact | Prevention |
|--------|--------|------------|
| Private key theft | Total loss | Hardware wallets, multisig |
| Smart contract exploit | Fund drain | Audits, formal verification |
| Phishing | User losses | Domain security, warnings |
| RPC manipulation | Wrong data | Verified endpoints |
| Supply chain | Code injection | Dependency auditing |

---

## ğŸŸ¡ PM/EM Depth

### Security Checklist

| Phase | Tasks | Status |
|-------|-------|--------|
| **Development** | | |
| | Code review process | â˜ |
| | Dependency scanning | â˜ |
| | Static analysis tools | â˜ |
| **Pre-Launch** | | |
| | Security audit | â˜ |
| | Bug bounty program | â˜ |
| | Penetration testing | â˜ |
| **Production** | | |
| | Monitoring/alerting | â˜ |
| | Incident response plan | â˜ |
| | Key management policy | â˜ |
| **Ongoing** | | |
| | Regular audits | â˜ |
| | Dependency updates | â˜ |
| | Security training | â˜ |

### Audit Provider Selection

| Criteria | Weight |
|----------|--------|
| Solana expertise | High |
| Past audit quality | High |
| Response time | Medium |
| Cost | Medium |
| Reputation | High |

**Notable Solana Auditors:**
- OtterSec
- Neodyme
- Trail of Bits
- Halborn
- Kudelski Security

---

## ğŸ”µ Engineer Depth

### Secure Key Management

```typescript
// âŒ NEVER: Store keys in code or environment variables for production
const privateKey = process.env.PRIVATE_KEY; // DANGEROUS

// âœ… Use hardware security modules (HSM) or secure enclaves
// Solana uses Ed25519 keys, so your signer must support Ed25519.
// Many teams use dedicated remote signers/HSMs that expose an Ed25519 signing API.

// âœ… Use multisig for critical operations
import Squads from "@sqds/sdk";

class MultisigAuthority {
  private squads: Squads;
  private multisigAddress: PublicKey;

  async createUpgradeProposal(
    programId: PublicKey,
    bufferAddress: PublicKey
  ): Promise<PublicKey> {
    const [txBuilder] = await this.squads.createTransaction(
      this.multisigAddress,
      1
    );

    // Add upgrade instruction
    // Requires multiple signers to execute

    return txBuilder.publicKey;
  }
}
```

### Secure Transaction Building

```typescript
// âœ… Always verify transaction before signing
interface TransactionVerification {
  expectedPrograms: PublicKey[];
  expectedAccounts: {
    pubkey: PublicKey;
    isSigner: boolean;
    isWritable: boolean;
  }[];
  maxLamports: number;
}

function verifyTransaction(
  transaction: Transaction,
  verification: TransactionVerification
): { valid: boolean; errors: string[] } {
  const errors: string[] = [];

  // Check programs
  for (const ix of transaction.instructions) {
    const isExpected = verification.expectedPrograms.some(
      (p) => p.equals(ix.programId)
    );

    if (!isExpected) {
      errors.push(`Unexpected program: ${ix.programId.toString()}`);
    }
  }

  // Check account permissions
  for (const ix of transaction.instructions) {
    for (const key of ix.keys) {
      const expected = verification.expectedAccounts.find(
        (a) => a.pubkey.equals(key.pubkey)
      );

      if (expected) {
        if (key.isWritable && !expected.isWritable) {
          errors.push(
            `Unexpected writable: ${key.pubkey.toString()}`
          );
        }
        if (key.isSigner && !expected.isSigner) {
          errors.push(
            `Unexpected signer: ${key.pubkey.toString()}`
          );
        }
      }
    }
  }

  // Check max lamports (simple heuristic)
  // In practice, decode instructions to verify exact amounts

  return {
    valid: errors.length === 0,
    errors,
  };
}

// âœ… Simulate before sending
async function safeTransactionSend(
  connection: Connection,
  transaction: Transaction,
  signers: Keypair[],
  verification: TransactionVerification
): Promise<string> {
  // Step 1: Verify transaction structure
  const verifyResult = verifyTransaction(transaction, verification);
  if (!verifyResult.valid) {
    throw new Error(`Transaction verification failed: ${verifyResult.errors.join(", ")}`);
  }

  // Step 2: Simulate transaction
  const simulation = await connection.simulateTransaction(transaction);
  if (simulation.value.err) {
    throw new Error(`Simulation failed: ${JSON.stringify(simulation.value.err)}`);
  }

  // Step 3: Send transaction
  transaction.sign(...signers);
  const signature = await connection.sendRawTransaction(
    transaction.serialize()
  );

  return signature;
}
```

### API Security

```typescript
import rateLimit from "express-rate-limit";
import helmet from "helmet";
import { body, validationResult } from "express-validator";

const app = express();

// Security middleware
app.use(helmet());
app.use(express.json({ limit: "10kb" })); // Limit body size

// Rate limiting
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // Limit each IP to 100 requests per windowMs
  message: "Too many requests, please try again later",
});
app.use("/api", limiter);

// Stricter limit for transaction endpoints
const txLimiter = rateLimit({
  windowMs: 60 * 1000, // 1 minute
  max: 10,
  message: "Transaction rate limit exceeded",
});
app.use("/api/transactions", txLimiter);

// Input validation
app.post(
  "/api/transfer",
  [
    body("recipient")
      .isString()
      .isLength({ min: 32, max: 44 })
      .matches(/^[1-9A-HJ-NP-Za-km-z]+$/) // Base58
      .withMessage("Invalid recipient address"),
    body("amount")
      .isFloat({ min: 0, max: 1000000000 })
      .withMessage("Invalid amount"),
  ],
  async (req, res) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }

    // Validate the address is a valid PublicKey
    try {
      new PublicKey(req.body.recipient);
    } catch {
      return res.status(400).json({ error: "Invalid public key" });
    }

    // Process transfer
  }
);

// CORS configuration
import cors from "cors";

app.use(cors({
  origin: process.env.ALLOWED_ORIGINS?.split(",") || ["https://myapp.com"],
  methods: ["GET", "POST"],
  allowedHeaders: ["Content-Type", "Authorization"],
}));
```

### Secret Management

```typescript
// âœ… Use secret managers, not environment variables
import { SecretsManagerClient, GetSecretValueCommand } from "@aws-sdk/client-secrets-manager";

class SecretManager {
  private client: SecretsManagerClient;
  private cache: Map<string, { value: string; expires: number }> = new Map();
  private cacheTTL = 5 * 60 * 1000; // 5 minutes

  constructor() {
    this.client = new SecretsManagerClient({ region: process.env.AWS_REGION });
  }

  async getSecret(secretName: string): Promise<string> {
    // Check cache
    const cached = this.cache.get(secretName);
    if (cached && cached.expires > Date.now()) {
      return cached.value;
    }

    // Fetch from Secrets Manager
    const command = new GetSecretValueCommand({ SecretId: secretName });
    const response = await this.client.send(command);

    if (!response.SecretString) {
      throw new Error(`Secret ${secretName} not found`);
    }

    // Cache the value
    this.cache.set(secretName, {
      value: response.SecretString,
      expires: Date.now() + this.cacheTTL,
    });

    return response.SecretString;
  }

  async getRPCUrl(): Promise<string> {
    const secrets = JSON.parse(await this.getSecret("solana/rpc"));
    return secrets.url;
  }

  async getDeployerKeypair(): Promise<Keypair> {
    const secrets = JSON.parse(await this.getSecret("solana/deployer"));
    return Keypair.fromSecretKey(
      Uint8Array.from(JSON.parse(secrets.keypair))
    );
  }
}
```

### Frontend Security

```typescript
// âœ… Verify transactions match user intent
interface TransferIntent {
  recipient: string;
  amount: number;
  token?: string;
}

async function buildAndVerifyTransfer(
  intent: TransferIntent,
  wallet: WalletAdapter
): Promise<Transaction> {
  // Build transaction
  const transaction = await buildTransferTransaction(intent);

  // Display transaction summary to user
  const summary = extractTransactionSummary(transaction);

  // Compare with intent
  if (summary.recipient !== intent.recipient) {
    throw new Error("Recipient mismatch - possible attack");
  }

  if (summary.amount !== intent.amount) {
    throw new Error("Amount mismatch - possible attack");
  }

  return transaction;
}

// âœ… Domain verification
function verifyAppDomain(): boolean {
  const trustedDomains = [
    "myapp.com",
    "www.myapp.com",
    "app.myapp.com",
  ];

  const currentDomain = window.location.hostname;

  if (!trustedDomains.includes(currentDomain)) {
    console.error("Running on untrusted domain:", currentDomain);
    return false;
  }

  // Check for SSL
  if (window.location.protocol !== "https:") {
    console.error("Not using HTTPS");
    return false;
  }

  return true;
}

// âœ… Phishing warning for wallet connections
function WalletConnectWarning() {
  return (
    <div className="bg-yellow-100 p-4 rounded-lg mb-4">
      <h3 className="font-bold">Security Reminder</h3>
      <ul className="text-sm mt-2">
        <li>âœ“ Verify you're on {window.location.hostname}</li>
        <li>âœ“ Check the URL starts with https://</li>
        <li>âœ“ Never share your seed phrase</li>
        <li>âœ“ Review transaction details before signing</li>
      </ul>
    </div>
  );
}
```

### Smart Contract Security Patterns

```rust
// âœ… Owner check pattern
pub fn transfer_authority(
    ctx: Context<TransferAuthority>,
    new_authority: Pubkey,
) -> Result<()> {
    let config = &mut ctx.accounts.config;

    // Verify current authority
    require_keys_eq!(
        config.authority,
        ctx.accounts.authority.key(),
        CustomError::UnauthorizedAuthority
    );

    // Set new authority
    config.authority = new_authority;

    emit!(AuthorityTransferred {
        old_authority: ctx.accounts.authority.key(),
        new_authority,
    });

    Ok(())
}

// âœ… Timelock pattern for sensitive operations
#[account]
pub struct PendingOperation {
    pub operation_type: u8,
    pub data: Vec<u8>,
    pub initiator: Pubkey,
    pub execute_after: i64,
    pub executed: bool,
}

pub fn initiate_operation(
    ctx: Context<InitiateOperation>,
    operation_type: u8,
    data: Vec<u8>,
) -> Result<()> {
    let pending = &mut ctx.accounts.pending_operation;
    let clock = Clock::get()?;

    pending.operation_type = operation_type;
    pending.data = data;
    pending.initiator = ctx.accounts.authority.key();
    pending.execute_after = clock.unix_timestamp + TIMELOCK_DURATION;
    pending.executed = false;

    Ok(())
}

pub fn execute_operation(ctx: Context<ExecuteOperation>) -> Result<()> {
    let pending = &mut ctx.accounts.pending_operation;
    let clock = Clock::get()?;

    require!(!pending.executed, CustomError::AlreadyExecuted);
    require!(
        clock.unix_timestamp >= pending.execute_after,
        CustomError::TimelockNotExpired
    );

    // Execute the operation
    match pending.operation_type {
        0 => execute_type_0(&pending.data)?,
        1 => execute_type_1(&pending.data)?,
        _ => return Err(CustomError::InvalidOperationType.into()),
    }

    pending.executed = true;

    Ok(())
}

// âœ… Emergency pause
#[account]
pub struct GlobalConfig {
    pub authority: Pubkey,
    pub paused: bool,
    pub pause_authority: Pubkey,
}

pub fn pause(ctx: Context<Pause>) -> Result<()> {
    let config = &mut ctx.accounts.config;
    config.paused = true;

    emit!(ProtocolPaused {
        by: ctx.accounts.pause_authority.key(),
    });

    Ok(())
}

// Use in other instructions
pub fn deposit(ctx: Context<Deposit>, amount: u64) -> Result<()> {
    let config = &ctx.accounts.config;
    require!(!config.paused, CustomError::ProtocolPaused);

    // ... rest of deposit logic
    Ok(())
}
```

### Audit Preparation

```typescript
// Documentation for auditors
interface AuditDocumentation {
  architecture: {
    programs: string[];
    accounts: AccountStructure[];
    pdaDerivations: PDADerivation[];
    accessControls: AccessControl[];
  };
  invariants: string[];
  knownRisks: string[];
  previousAudits: AuditReport[];
  testCoverage: TestCoverage;
}

// Generate audit checklist
const auditChecklist = `
## Smart Contract Audit Checklist

### Access Control
- [ ] All admin functions have proper authority checks
- [ ] PDA bump seeds are validated
- [ ] Signer verification on all state-changing operations

### Input Validation
- [ ] All numeric inputs checked for overflow/underflow
- [ ] Account ownership validated
- [ ] Account discriminators checked

### State Management
- [ ] No uninitialized account reads
- [ ] Proper account close handling
- [ ] Rent-exempt balance maintained

### Economic Security
- [ ] No flash loan vulnerabilities
- [ ] Price oracle manipulation resistant
- [ ] Fee calculations verified

### CPI Security
- [ ] Program ID verification on CPIs
- [ ] PDA signer seeds verified
- [ ] Return data validated

### Denial of Service
- [ ] No unbounded loops
- [ ] Compute budget within limits
- [ ] No dust account attacks
`;
```

### Incident Response

```typescript
// Incident response automation
interface SecurityIncident {
  type: "unauthorized_access" | "smart_contract_exploit" | "key_compromise";
  severity: "critical" | "high" | "medium" | "low";
  description: string;
  affectedSystems: string[];
  discoveredAt: Date;
}

async function handleSecurityIncident(incident: SecurityIncident): Promise<void> {
  // 1. Immediate containment
  if (incident.severity === "critical") {
    await pauseProtocol();
    await revokeCompromisedAccess();
  }

  // 2. Notify team
  await notifySecurityTeam(incident);

  // 3. Log incident
  await logIncident(incident);

  // 4. Begin investigation
  await createIncidentTicket(incident);
}

async function pauseProtocol(): Promise<void> {
  // Emergency pause via program instruction
  const tx = await program.methods
    .pause()
    .accounts({
      config: configPda,
      pauseAuthority: pauseKeypair.publicKey,
    })
    .signers([pauseKeypair])
    .rpc();

  console.log("Protocol paused:", tx);

  // Notify all services
  await publishEvent("protocol.paused", { timestamp: Date.now() });
}
```

---

## Common Patterns

### Defense in Depth

```
Layer 1: Smart contract validation
Layer 2: Client-side verification
Layer 3: API rate limiting and authentication
Layer 4: Infrastructure isolation
Layer 5: Monitoring and alerting
Layer 6: Incident response procedures
```

---

## Key Takeaways

1. **Never store keys in code** â€” use HSMs or secret managers
2. **Multisig for critical operations** â€” remove single points of failure
3. **Audit before mainnet** â€” invest in professional security review
4. **Simulate all transactions** â€” catch errors before on-chain
5. **Rate limit everything** â€” protect against abuse
6. **Validate all inputs** â€” trust nothing
7. **Monitor continuously** â€” detect incidents early
8. **Have incident plans** â€” know what to do when things go wrong

---
